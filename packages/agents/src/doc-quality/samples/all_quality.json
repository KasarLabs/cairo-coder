{
  "source": "cairo_book",
  "version": "1.0.0",
  "metadata": {
    "owner": "cairo-lang",
    "repository": "cairo-book"
  },
  "testCases": [
    {
      "query": "How do you declare a mutable variable in Cairo?",
      "expectedTopics": ["let keyword", "mut", "variables", "immutability"],
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["variables", "syntax"]
    },
    {
      "query": "What happens if you try to reassign a variable declared without `mut`?",
      "expectedTopics": ["immutability", "let keyword", "compile error"],
      "type": "conceptual",
      "difficulty": "basic",
      "tags": ["variables", "errors"]
    },
    {
      "query": "What is the default data type if no type is specified, and how does it behave with division?",
      "expectedTopics": [
        "felt252",
        "field elements",
        "division",
        "type inference"
      ],
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["data types", "arithmetic"]
    },
    {
      "query": "How do you declare an unsigned 8-bit integer in Cairo?",
      "expectedTopics": ["u8", "integer types", "type annotation"],
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["data types", "syntax"]
    },
    {
      "query": "What is the range of values for an `i128` type?",
      "expectedTopics": ["i128", "signed integers", "range"],
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["data types", "integers"]
    },
    {
      "query": "How do you define a function with a generic type parameter?",
      "expectedTopics": ["fn keyword", "generics", "type parameters"],
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["functions", "generics"]
    },
    {
      "query": "What keyword is used to declare a function in Cairo?",
      "expectedTopics": ["fn keyword", "function declaration"],
      "type": "factual",
      "difficulty": "basic",
      "tags": ["functions", "syntax"]
    },
    {
      "query": "How do you write a single-line comment in Cairo?",
      "expectedTopics": ["comments", "//", "syntax"],
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["syntax", "documentation"]
    },
    {
      "query": "How do you create an array with initial values in Cairo?",
      "expectedTopics": ["array!", "arrays", "collections"],
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["arrays", "collections"]
    },
    {
      "query": "Why can’t you mutate an array after it has been moved?",
      "expectedTopics": [
        "ownership",
        "move semantics",
        "arrays",
        "immutability"
      ],
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["ownership", "arrays"]
    },
    {
      "query": "How do you safely access the first element of an array in Cairo?",
      "expectedTopics": ["get", "Option", "arrays"],
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["arrays", "safety"]
    },
    {
      "query": "What is the purpose of the `Felt252Dict` type in Cairo?",
      "expectedTopics": ["Felt252Dict", "dictionaries", "mutable data"],
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["dictionaries", "collections"]
    },
    {
      "query": "How do you insert a key-value pair into a `Felt252Dict`?",
      "expectedTopics": ["insert", "Felt252Dict", "key-value"],
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["dictionaries", "collections"]
    },
    {
      "query": "What happens when you access a non-existent key in a `Felt252Dict`?",
      "expectedTopics": ["get", "Felt252Dict", "default value"],
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["dictionaries", "collections"]
    },
    {
      "query": "How do you use a `for` loop to iterate over a range in Cairo?",
      "expectedTopics": ["for", "range", "iteration"],
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["loops", "control flow"]
    },
    {
      "query": "What is the difference between `loop` and `while` in Cairo?",
      "expectedTopics": ["loop", "while", "control flow", "break"],
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["loops", "control flow"]
    },
    {
      "query": "How do you define a struct with two fields in Cairo?",
      "expectedTopics": ["struct", "fields", "data structure"],
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["structs", "syntax"]
    },
    {
      "query": "What does the `#[derive(Copy, Drop)]` attribute do in Cairo?",
      "expectedTopics": ["derive", "Copy", "Drop", "traits"],
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["structs", "traits"]
    },
    {
      "query": "How do you define a method for a struct in Cairo?",
      "expectedTopics": ["impl", "method syntax", "self"],
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["structs", "methods"]
    },
    {
      "query": "How do you declare a Starknet smart contract in Cairo?",
      "expectedTopics": [
        "#[starknet::contract]",
        "mod",
        "smart contracts",
        "Starknet"
      ],
      "expectedContent": "A Starknet smart contract is declared using the `#[starknet::contract]` attribute above a module (`mod`). For example: `#[starknet::contract] mod MyContract { ... }`. This marks the module as a contract, enabling Starknet-specific features like storage and entry points.",
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["smart contracts", "syntax"]
    },
    {
      "query": "What is the purpose of the `#[storage]` attribute in a Starknet contract?",
      "expectedTopics": ["#[storage]", "struct", "state", "smart contracts"],
      "expectedContent": "The `#[storage]` attribute defines a `Storage` struct in a Starknet contract, which holds persistent state variables. For example: `#[storage] struct Storage { value: u128 }`. These variables are stored on the blockchain and accessed via contract functions.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "storage"]
    },
    {
      "query": "How do you define an external function in a Starknet contract?",
      "expectedTopics": [
        "#[external(v0)]",
        "#[abi(embed_v0)]",
        "impl",
        "smart contracts"
      ],
      "expectedContent": "External functions are defined in an `impl` block with `#[abi(embed_v0)]` or directly with `#[external(v0)]`. Example: `#[abi(embed_v0)] impl MyContractImpl of IMyContract<ContractState> { fn set_value(ref self: ContractState, x: u128) { self.value.write(x); } }`. These are callable entry points from outside the contract.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "functions"]
    },
    {
      "query": "What is the role of `ContractState` in a Starknet contract?",
      "expectedTopics": ["ContractState", "state", "smart contracts"],
      "expectedContent": "`ContractState` represents a contract’s state and is passed as a parameter (e.g., `self: ContractState`) to functions accessing or modifying storage. It provides methods like `self.value.read()` to interact with the `Storage` struct safely.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "state"]
    },
    {
      "query": "How do you define an interface for a Starknet contract?",
      "expectedTopics": [
        "#[starknet::interface]",
        "trait",
        "smart contracts",
        "ABI"
      ],
      "expectedContent": "An interface is defined with a `trait` annotated by `#[starknet::interface]`. Example: `#[starknet::interface] trait IMyContract<TContractState> { fn get_value(self: @TContractState) -> u128; }`. It specifies the contract’s public ABI for external calls.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "interfaces"]
    },
    {
      "query": "What happens if you omit `ref` in a function that modifies storage?",
      "expectedTopics": ["ref", "ContractState", "storage", "compile error"],
      "expectedContent": "Omitting `ref` in a function modifying storage (e.g., `self.value.write(x)`) causes a compile-time error. Cairo requires `ref self: ContractState` to explicitly allow state mutation.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "errors"]
    },
    {
      "query": "How do you emit an event in a Starknet contract?",
      "expectedTopics": ["#[event]", "emit", "smart contracts", "Starknet"],
      "expectedContent": "Define an event struct with `#[event]` and emit it using `self.emit()`. Example: `#[derive(Drop, starknet::Event)] struct ValueSet { value: u128 }`, then `self.emit(ValueSet { value: x });`. This logs the event on Starknet.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "events"]
    },
    {
      "query": "What is the difference between a Cairo program and a Starknet smart contract?",
      "expectedTopics": [
        "Cairo program",
        "smart contract",
        "state",
        "Starknet"
      ],
      "expectedContent": "A Cairo program is stateless, running a computation with a `main()` entry point, while a Starknet smart contract is stateful, using `#[starknet::contract]` to manage persistent data on the blockchain via `Storage`.",
      "type": "conceptual",
      "difficulty": "basic",
      "tags": ["smart contracts", "concepts"]
    },
    {
      "query": "How do you call another contract’s function from a Starknet contract?",
      "expectedTopics": [
        "contract address",
        "dispatcher",
        "interfaces",
        "smart contracts"
      ],
      "expectedContent": "Use the target contract’s interface and address with a dispatcher. Example: `IMyContractDispatcher { contract_address: addr }.get_value()`. This requires importing the interface and knowing the contract address.",
      "type": "procedural",
      "difficulty": "advanced",
      "tags": ["smart contracts", "interoperability"]
    },
    {
      "query": "What is the purpose of the `#[generate_trait]` attribute?",
      "expectedTopics": ["#[generate_trait]", "traits", "code generation"],
      "expectedContent": "`#[generate_trait]` on an `impl` block auto-generates a corresponding trait, reducing boilerplate by defining the trait based on the implemented methods.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["traits", "syntax"]
    },
    {
      "query": "How do you make a function in a module visible to other modules?",
      "expectedTopics": ["pub", "modules", "visibility"],
      "expectedContent": "Use the `pub` keyword before the function, e.g., `pub fn my_function()`. This makes it accessible outside the module.",
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["modules", "visibility"]
    },
    {
      "query": "What is the purpose of the `use` keyword in Cairo?",
      "expectedTopics": ["use", "import", "scope"],
      "type": "conceptual",
      "difficulty": "basic",
      "tags": ["modules", "syntax"]
    },
    {
      "query": "How do you create a generic struct in Cairo?",
      "expectedTopics": ["struct", "generics", "type parameters"],
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["structs", "generics"]
    },
    {
      "query": "How do you implement a trait for a generic type in Cairo?",
      "expectedTopics": ["impl", "trait", "generics", "trait bounds"],
      "type": "procedural",
      "difficulty": "advanced",
      "tags": ["traits", "generics"]
    },
    {
      "query": "What is the difference between snapshots and references in Cairo?",
      "expectedTopics": [
        "snapshots",
        "references",
        "ownership",
        "immutability"
      ],
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["ownership", "references"]
    },
    {
      "query": "What is the difference between a contract call and a library call in Starknet?",
      "expectedTopics": [
        "contract call",
        "library call",
        "state",
        "class hash"
      ],
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["smart contracts", "execution"]
    },
    {
      "query": "What is the purpose of a constructor in a Starknet contract, and how is it defined?",
      "expectedTopics": [
        "constructor",
        "#[constructor]",
        "state initialization"
      ],
      "expectedContent": "A constructor initializes a contract’s storage during deployment. It’s defined with `#[constructor]` and takes `ref self: ContractState`. Example: `#[constructor] fn constructor(ref self: ContractState, initial_value: u128) { self.value.write(initial_value); }`.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "deployment"]
    },
    {
      "query": "What are the visibility modifiers for functions in a Starknet contract?",
      "expectedTopics": [
        "visibility",
        "#[external(v0)]",
        "#[abi(embed_v0)]",
        "internal"
      ],
      "expectedContent": "Functions with `#[external(v0)]` or in an `#[abi(embed_v0)]` impl are public and callable externally. Without modifiers, functions are internal, callable only within the contract.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "visibility"]
    },
    {
      "query": "What is a negative implementation, and when is it useful?",
      "expectedTopics": ["negative impl", "traits", "type constraints"],
      "expectedContent": "A negative implementation (`impl !Trait for Type`) specifies that a type does not implement a trait. It’s useful for excluding specific types from generic default behavior.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["traits", "generics"]
    },
    {
      "query": "What are associated items in a Cairo trait?",
      "expectedTopics": [
        "associated items",
        "traits",
        "associated types",
        "associated functions"
      ],
      "expectedContent": "Associated items in traits include types, functions, and constants defined within the trait. Cairo supports associated types and functions, enabling flexible trait definitions.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["traits"]
    },
    {
      "query": "What is a storage node in Cairo, and how is it used?",
      "expectedTopics": ["storage node", "struct", "storage", "mappings"],
      "expectedContent": "A storage node is a struct within a contract’s `Storage` that can include types like `Map` or `Vec`, organizing complex state data efficiently.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["storage", "structs"]
    },
    {
      "query": "What are the benefits of using components in a Starknet contract?",
      "expectedTopics": ["components", "reusability", "modularity"],
      "expectedContent": "Components enhance modularity and reusability by encapsulating logic, storage, and events, allowing contracts to share functionality without redundant code.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "components"]
    },
    {
      "query": "How do you integrate a component into a Starknet contract?",
      "expectedTopics": ["component!()", "storage", "events"],
      "expectedContent": "Use the `component!()` macro to integrate a component, adding its storage and events to the contract’s `Storage` and `Event` structs, and alias its impl for use.",
      "type": "procedural",
      "difficulty": "advanced",
      "tags": ["smart contracts", "components"]
    },
    {
      "query": "How do you call a component’s function within a contract?",
      "expectedTopics": ["component", "dispatcher", "ComponentState"],
      "expectedContent": "Use `get_dep_component!` or `get_dep_component_mut!` to access the component’s `ComponentState`, then call its methods via the defined impl alias.",
      "type": "procedural",
      "difficulty": "advanced",
      "tags": ["smart contracts", "components"]
    },
    {
      "query": "What are the steps to upgrade a Starknet contract?",
      "expectedTopics": ["upgrade", "replace_class_syscall", "class hash"],
      "expectedContent": "Implement `replace_class_syscall` in an external function and call it with the new class hash to replace the contract’s code during an upgrade.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "upgrades"]
    },
    {
      "query": "What does the `?` operator do in Cairo?",
      "expectedTopics": ["?", "Result", "Option", "error propagation"],
      "expectedContent": "The `?` operator propagates errors from `Result` or unwraps `Option` values, simplifying error handling in functions.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["error handling", "syntax"]
    },
    {
      "query": "How does `#[should_panic]` work in Cairo testing?",
      "expectedTopics": ["#[should_panic]", "testing", "panic"],
      "expectedContent": "`#[should_panic]` marks a test that should pass only if it panics, optionally with an expected message: `#[should_panic(expected: \"message\")]`.",
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["testing", "panic"]
    },
    {
      "query": "What is the purpose of the `#[cfg(test)]` attribute?",
      "expectedTopics": ["#[cfg(test)]", "testing", "conditional compilation"],
      "expectedContent": "`#[cfg(test)]` compiles code only during `scarb test`, keeping test-specific code out of the final artifact.",
      "type": "conceptual",
      "difficulty": "basic",
      "tags": ["testing", "syntax"]
    },
    {
      "query": "What is the difference between unit tests and integration tests in Cairo?",
      "expectedTopics": ["unit tests", "integration tests", "testing"],
      "expectedContent": "Unit tests focus on individual components in isolation, while integration tests verify interactions between components or contracts via public interfaces.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["testing"]
    },
    {
      "query": "How can you test private functions in Cairo?",
      "expectedTopics": ["private functions", "testing", "module visibility"],
      "expectedContent": "Private functions can be tested in unit tests within the same module or by making parent modules accessible to the test module.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["testing", "visibility"]
    },
    {
      "query": "How do you test a Starknet contract by deploying and interacting with it?",
      "expectedTopics": ["deploy", "testing", "dispatcher", "Foundry"],
      "expectedContent": "Using Starknet Foundry, declare the contract class, deploy it with serialized constructor calldata, then use a dispatcher to call and test its entry points.",
      "type": "procedural",
      "difficulty": "advanced",
      "tags": ["testing", "smart contracts"]
    },
    {
      "query": "How do you add a dependency to a Cairo project?",
      "expectedTopics": ["Scarb.toml", "dependencies", "package manager"],
      "expectedContent": "Add dependencies in `Scarb.toml` under `[dependencies]`, e.g., `my_crate = { version = \"1.0.0\" }`.",
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["Scarb", "dependencies"]
    },
    {
      "query": "How are storage slots identified in a Starknet contract?",
      "expectedTopics": ["storage", "storage slot", "storage address"],
      "expectedContent": "Storage slots are identified by a `felt252` storage address, computed from the variable name and, for complex types, additional parameters.",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "storage"]
    },
    {
      "query": "What are the benefits of using a ZK-ISA in Cairo?",
      "expectedTopics": ["ZK-ISA", "STARKs", "efficiency"],
      "expectedContent": "A ZK-ISA optimizes for zero-knowledge proofs (e.g., STARKs), enabling faster proof generation and smaller proof sizes for scalable applications.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["Cairo VM", "zero-knowledge"]
    },
    {
      "query": "What types of procedural macros exist in Cairo?",
      "expectedTopics": [
        "procedural macros",
        "derive macros",
        "attribute-like macros",
        "function-like macros"
      ],
      "expectedContent": "Cairo supports derive macros (e.g., `#[derive]`), attribute-like macros (e.g., `#[generate_trait]`), and function-like macros (e.g., `array!`).",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["macros", "syntax"]
    },
    {
      "query": "How do you pack multiple small integers into a larger integer in Cairo?",
      "expectedTopics": [
        "bit-packing",
        "bitwise operators",
        "storage optimization"
      ],
      "expectedContent": "Use bitwise operators (shift, AND, OR) to combine smaller integers into a larger type, optimizing storage usage.",
      "type": "procedural",
      "difficulty": "advanced",
      "tags": ["data types", "optimization"]
    },
    {
      "query": "When should you use bit-packing in a Starknet contract?",
      "expectedTopics": ["bit-packing", "storage optimization", "gas costs"],
      "expectedContent": "Use bit-packing for small integers fitting within a `felt252` slot to reduce storage and gas costs.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "optimization"]
    },
    {
      "query": "How does the `#[flat]` attribute affect events in Starknet?",
      "expectedTopics": ["#[flat]", "events", "composability"],
      "expectedContent": "`#[flat]` flattens event variants, omitting variant names in serialization, aiding composability across components.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["events", "components"]
    },
    {
      "query": "What is the role of the `#[key]` attribute in Starknet events?",
      "expectedTopics": ["#[key]", "events", "indexed fields"],
      "expectedContent": "`#[key]` marks event fields as indexed, improving query efficiency on the blockchain.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["events", "Starknet"]
    },
    {
      "query": "How does the Cairo compiler enforce `nopanic` function safety?",
      "expectedTopics": ["nopanic", "compile-time checks", "panic"],
      "expectedContent": "The compiler statically ensures `nopanic` functions only call other `nopanic` functions, preventing operations that could panic.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["functions", "safety"]
    },
    {
      "query": "How does Cairo’s write-once memory model affect mutable data structures?",
      "expectedTopics": [
        "immutable memory",
        "mutable data structures",
        "Felt252Dict"
      ],
      "expectedContent": "Cairo’s write-once memory prevents overwrites, so mutability is simulated with structures like `Felt252Dict`, which creates new entries for updates.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["memory", "dictionaries"]
    },
    {
      "query": "What is the role of `ComponentState` in Starknet components?",
      "expectedTopics": ["ComponentState", "components", "storage access"],
      "expectedContent": "`ComponentState<TContractState>` provides components access to contract storage and functions, ensuring consistent state interaction.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["components", "smart contracts"]
    },
    {
      "query": "When should you use a library call instead of a contract call?",
      "expectedTopics": ["library call", "contract call", "state", "gas costs"],
      "expectedContent": "Library calls execute in the caller's context (storage changes, environment variables, etc.), while contract calls execute in the called contract's context.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["smart contracts", "execution"]
    },
    {
      "query": "What architectural pattern does OpenZeppelin Contracts for Cairo use?",
      "expectedTopics": ["components", "architecture", "design pattern"],
      "expectedContent": "OpenZeppelin Contracts for Cairo uses a component-based architecture where components are modular building blocks containing storage, events, and implementations that must be explicitly instantiated, promoting composition over inheritance.",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["architecture", "components"]
    },
    {
      "query": "How does the component model in Cairo contracts differ from the inheritance model in Solidity contracts?",
      "expectedTopics": ["components", "inheritance", "Solidity comparison"],
      "expectedContent": "Unlike inheritance in Solidity, Cairo components must be explicitly instantiated and integrated. This promotes a more explicit composition model with greater separation of concerns and granular implementations.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["architecture", "Solidity", "comparison"]
    },
    {
      "query": "How do you customize the behavior of a component in OpenZeppelin Contracts for Cairo?",
      "expectedTopics": ["customization", "hooks", "custom implementations"],
      "expectedContent": "Components can be customized using hooks (to insert custom logic before/after operations), custom implementations (to modify component behavior), and the Immutable Config pattern (to define constants for components).",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["customization", "hooks", "configuration"]
    },
    {
      "query": "How do you implement ERC20 token with OpenZeppelin Contracts for Cairo?",
      "expectedTopics": ["ERC20", "token implementation", "ERC20Component"],
      "expectedContent": "Implement ERC20 by instantiating the ERC20Component, configuring options like name, symbol, and decimals, and using the provided functions such as transfer, approve, and mint.",
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["ERC20", "tokens", "implementation"]
    },
    {
      "query": "What are the supported decimals configuration options for ERC20 tokens?",
      "expectedTopics": ["ERC20", "decimals", "configuration"],
      "expectedContent": "ERC20 tokens support decimals configuration through either a static approach using ImmutableConfig (default is 18) or a storage approach for dynamic decimals, which is useful for factory contracts.",
      "type": "factual",
      "difficulty": "basic",
      "tags": ["ERC20", "decimals", "configuration"]
    },
    {
      "query": "How does OpenZeppelin Contracts for Cairo handle method naming conventions?",
      "expectedTopics": [
        "naming conventions",
        "interfaces",
        "snake_case",
        "camelCase"
      ],
      "expectedContent": "OpenZeppelin Contracts for Cairo supports dual interfaces with both snake_case (Cairo standard) and camelCase (EVM compatibility) method naming conventions.",
      "type": "factual",
      "difficulty": "basic",
      "tags": ["interfaces", "naming", "conventions"]
    },
    {
      "query": "How do you implement access control in OpenZeppelin Contracts for Cairo?",
      "expectedTopics": [
        "access control",
        "OwnableComponent",
        "AccessControlComponent"
      ],
      "expectedContent": "Use either OwnableComponent for simple admin patterns with a single owner, or AccessControlComponent for role-based access control with custom roles, role administration, and permission management.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["security", "access control", "permissions"]
    },
    {
      "query": "What security components are available in OpenZeppelin Contracts for Cairo?",
      "expectedTopics": [
        "security",
        "Initializable",
        "Pausable",
        "ReentrancyGuard"
      ],
      "expectedContent": "Security components include Initializable (one-time initialization), Pausable (emergency stop mechanism), and ReentrancyGuard (protection against reentrancy attacks).",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["security", "components"]
    },
    {
      "query": "How does contract upgradeability work in Starknet compared to EVM chains?",
      "expectedTopics": ["upgrades", "replace_class", "proxy patterns"],
      "expectedContent": "Starknet uses native upgradeability through the replace_class syscall, eliminating the need for proxy patterns as used in EVM chains. UpgradeableComponent implements this secure upgrade pattern.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["upgrades", "Starknet", "EVM comparison"]
    },
    {
      "query": "What is the purpose of the Votes component in OpenZeppelin Contracts for Cairo?",
      "expectedTopics": ["governance", "voting", "delegation"],
      "expectedContent": "The Votes component provides token-based voting power tracking and delegation, working with both ERC20 and ERC721 tokens, and using historical snapshots to prevent double voting in governance systems.",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["governance", "voting", "delegation"]
    },
    {
      "query": "How do you implement on-chain governance with OpenZeppelin Contracts for Cairo?",
      "expectedTopics": ["governance", "Governor", "proposals", "voting"],
      "expectedContent": "Implement on-chain governance using the Governor component (for proposals, voting, and execution), Votes component (for token-based voting power), and optionally the Timelock Controller (for delayed execution).",
      "type": "procedural",
      "difficulty": "advanced",
      "tags": ["governance", "proposals", "voting"]
    },
    {
      "query": "What is the purpose of the Timelock Controller in governance systems?",
      "expectedTopics": ["governance", "timelock", "execution delay"],
      "expectedContent": "The Timelock Controller adds mandatory time delays between proposal approval and execution, allowing users to exit if they disagree with decisions, enhancing security for governance actions.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["governance", "timelock", "security"]
    },
    {
      "query": "How do you implement a Multisig wallet with OpenZeppelin Contracts for Cairo?",
      "expectedTopics": ["multisig", "multiple signers", "quorum"],
      "expectedContent": "Use the Multisig component which implements collective decision-making requiring multiple signers to approve transactions, with configurable quorum requirements and transaction lifecycle management.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["multisig", "security", "governance"]
    },
    {
      "query": "How does token URI work in the ERC721 implementation?",
      "expectedTopics": ["ERC721", "token URI", "metadata"],
      "expectedContent": "The ERC721 implementation stores a base URI as a ByteArray and concatenates it with the token ID to form complete token URIs for metadata retrieval.",
      "type": "factual",
      "difficulty": "basic",
      "tags": ["ERC721", "metadata", "NFT"]
    },
    {
      "query": "What is the purpose of the SRC5 introspection standard?",
      "expectedTopics": ["SRC5", "introspection", "interface detection"],
      "expectedContent": "SRC5 is Starknet's interface detection standard (similar to ERC165) that allows contracts to declare which interfaces they support and for others to query this support.",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["standards", "introspection", "interfaces"]
    },
    {
      "query": "How do you implement ERC1155 multi-token standard with OpenZeppelin Contracts for Cairo?",
      "expectedTopics": ["ERC1155", "multi-token", "fungible and non-fungible"],
      "expectedContent": "Implement ERC1155 by instantiating the ERC1155Component which supports both fungible and non-fungible tokens with batch operations and per-token metadata.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["ERC1155", "tokens", "implementation"]
    },
    {
      "query": "What testing utilities does OpenZeppelin provide for Cairo contracts?",
      "expectedTopics": ["testing", "Starknet Foundry", "test utilities"],
      "expectedContent": "OpenZeppelin provides testing utilities in the openzeppelin_testing package to facilitate testing with Starknet Foundry, with version decoupled from cairo-contracts.",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["testing", "development", "tools"]
    },
    {
      "query": "How do you implement the Permit extension for ERC20 tokens?",
      "expectedTopics": ["ERC20", "permit", "signatures"],
      "expectedContent": "Implement Permit by integrating the ERC20PermitComponent which enables gas-less approvals through off-chain signatures, following the EIP-2612 standard.",
      "type": "procedural",
      "difficulty": "advanced",
      "tags": ["ERC20", "permit", "signatures"]
    },
    {
      "query": "What is the Universal Deployer Contract (UDC) and how is it used?",
      "expectedTopics": ["UDC", "deployment", "contracts"],
      "expectedContent": "The Universal Deployer Contract (UDC) is a utility contract for deploying other contracts on Starknet, allowing for deterministic addresses and simplified deployment processes.",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["deployment", "tools", "infrastructure"]
    },
    {
      "query": "How do you implement safe transfers in ERC721?",
      "expectedTopics": ["ERC721", "safe transfer", "receiver contracts"],
      "expectedContent": "Safe transfers in ERC721 check if the recipient is a contract implementing the IERC721Receiver interface and call onERC721Received to ensure the recipient can handle the token.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["ERC721", "safety", "transfers"]
    },
    {
      "query": "What are the security considerations when upgrading contracts?",
      "expectedTopics": ["upgrades", "security", "storage"],
      "expectedContent": "Security considerations for upgrades include handling API changes, ensuring storage compatibility, preventing storage collisions, and properly migrating data when needed.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["upgrades", "security", "storage"]
    },
    {
      "query": "How does the Pausable component work to provide emergency stop functionality?",
      "expectedTopics": ["security", "Pausable", "emergency stop"],
      "expectedContent": "The Pausable component provides an emergency stop mechanism with pause/unpause functions and a modifier to restrict functions when paused, useful for responding to discovered vulnerabilities.",
      "type": "factual",
      "difficulty": "basic",
      "tags": ["security", "emergency", "controls"]
    },
    {
      "query": "What is the difference between OwnableComponent and AccessControlComponent?",
      "expectedTopics": ["access control", "ownership", "roles"],
      "expectedContent": "OwnableComponent provides a simple ownership model with a single owner, while AccessControlComponent offers granular role-based access control with custom roles and role administration capabilities.",
      "type": "conceptual",
      "difficulty": "basic",
      "tags": ["security", "access control", "comparison"]
    },
    {
      "query": "How do you implement custom token supply mechanisms in ERC20?",
      "expectedTopics": ["ERC20", "supply", "minting", "burning"],
      "expectedContent": "Customize token supply by integrating supply-related components like ERC20MintableComponent for minting or ERC20BurnableComponent for burning, allowing flexible supply management.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["ERC20", "supply", "customization"]
    },
    {
      "query": "How do you use the Initializable component to secure contract initialization?",
      "expectedTopics": [
        "security",
        "initialization",
        "constructor alternative"
      ],
      "expectedContent": "Use the Initializable component to implement one-time initialization for contracts, replacing constructors and ensuring functions can only be called once during setup.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["security", "initialization", "patterns"]
    },
    {
      "query": "What is account abstraction in Starknet?",
      "expectedTopics": [
        "account abstraction",
        "account contracts",
        "smart accounts"
      ],
      "expectedContent": "In Starknet, all accounts are smart contracts with programmable logic - there are no EOAs (Externally Owned Accounts). This means accounts can have custom signature verification, transaction validation, and fee payment mechanisms.",
      "type": "conceptual",
      "difficulty": "basic",
      "tags": ["accounts", "architecture"]
    },
    {
      "query": "How are account contracts deployed in Starknet?",
      "expectedTopics": [
        "account deployment",
        "Universal Deployer",
        "DEPLOY_ACCOUNT"
      ],
      "expectedContent": "Account contracts can be deployed either through a DEPLOY_ACCOUNT transaction (which requires a pre-funded account) or using the Universal Deployer Contract (UDC), which provides a standardized way to deploy contracts with deterministic addresses.",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["accounts", "deployment"]
    },
    {
      "query": "What functions must a Starknet account contract implement?",
      "expectedTopics": [
        "account interface",
        "required functions",
        "validation"
      ],
      "expectedContent": "Starknet account contracts must implement __validate__, __execute__, __validate_declare__, and __validate_deploy__ functions. These handle transaction validation, execution, class declaration, and deployment validation respectively.",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["accounts", "smart contracts", "interface"]
    },
    {
      "query": "What is Cairo and Sierra in the context of Starknet?",
      "expectedTopics": ["Cairo", "Sierra", "compilation", "smart contracts"],
      "expectedContent": "Cairo is the native programming language for Starknet. Sierra (Safe Intermediate Representation) is an intermediate language between Cairo and Cairo Assembly (Casm). Cairo code is first compiled to Sierra, which ensures all executions are provable before final compilation to Casm.",
      "type": "conceptual",
      "difficulty": "basic",
      "tags": ["Cairo", "smart contracts", "compilation"]
    },
    {
      "query": "How are contract classes and instances separated in Starknet?",
      "expectedTopics": [
        "contract class",
        "contract instance",
        "class hash",
        "deployment"
      ],
      "expectedContent": "Starknet separates contract code (class) from contract state (instance). Contract classes are declared once and identified by a class hash, while instances are deployed with references to their class and maintain their own state. Multiple instances can use the same class.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "architecture"]
    },
    {
      "query": "What hash functions are available in Starknet?",
      "expectedTopics": [
        "hash functions",
        "Pedersen",
        "Poseidon",
        "Starknet Keccak"
      ],
      "expectedContent": "Starknet provides three hash functions: Pedersen hash (efficient for proving but lower security), Poseidon hash (optimized for ZK-proving systems), and Starknet Keccak (compatible with Ethereum's keccak256 but using only the first 250 bits).",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["cryptography", "hash functions"]
    },
    {
      "query": "How is the Starknet state structured?",
      "expectedTopics": ["state", "Merkle-Patricia tries", "state commitment"],
      "expectedContent": "Starknet state consists of two Merkle-Patricia tries: the contracts trie (mapping addresses to contract states) and the classes trie (mapping class hashes to compiled class hashes). The state commitment combines the roots of these two tries.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["state", "architecture"]
    },
    {
      "query": "What is the transaction flow in Starknet?",
      "expectedTopics": [
        "transaction flow",
        "validation",
        "execution",
        "fee mechanism"
      ],
      "expectedContent": "Transactions in Starknet go through: 1) Validation (checking signature and nonce), 2) Execution (performing the transaction's operations), 3) Fee charging (based on resource usage), and 4) State update (committing changes to the state).",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["transactions", "architecture"]
    },
    {
      "query": "How does L1-L2 messaging work in Starknet?",
      "expectedTopics": [
        "L1-L2 messaging",
        "L1 handler",
        "messaging mechanism"
      ],
      "expectedContent": "L1-L2 messaging uses specialized functions: sending messages from L1 to L2 involves the Starknet core contract and L1 handler functions on L2, while L2-to-L1 messages use send_message_to_l1 system call and can be consumed by L1 contracts through the core contract.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["messaging", "interoperability"]
    },
    {
      "query": "What is the STRK token and its utility?",
      "expectedTopics": ["STRK", "native token", "token economics"],
      "expectedContent": "STRK is Starknet's native token used for transaction fees, staking (securing the network), and governance. It has a fixed initial supply of 10 billion tokens with a planned distribution across early contributors, investors, foundation reserves, and community initiatives.",
      "type": "factual",
      "difficulty": "basic",
      "tags": ["economics", "token"]
    },
    {
      "query": "How does staking work in Starknet?",
      "expectedTopics": ["staking", "validators", "delegation", "rewards"],
      "expectedContent": "Staking in Starknet allows STRK holders to become validators (requiring 20,000 STRK on mainnet) or delegators. Validators run nodes and can enable delegation pools, while delegators can stake without running nodes. Rewards are distributed based on stake amount and a minting curve formula.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["staking", "consensus"]
    },
    {
      "query": "What is the minting curve formula for Starknet staking rewards?",
      "expectedTopics": ["minting curve", "staking rewards", "token inflation"],
      "expectedContent": "The minting curve formula is M = (C/10) × √S, where S is the staking rate percentage, M is the minting rate percentage, and C is the annual minting rate cap (1.6%). This creates a reward system that incentivizes staking while maintaining a balance.",
      "type": "factual",
      "difficulty": "advanced",
      "tags": ["staking", "economics"]
    },
    {
      "query": "How does the StarkGate bridge work?",
      "expectedTopics": ["StarkGate", "bridge", "token bridging", "L1-L2"],
      "expectedContent": "StarkGate bridges assets between Ethereum (L1) and Starknet (L2). For deposits, tokens are locked in L1 contracts and minted on L2. For withdrawals, tokens are burned on L2 and unlocked on L1. The bridge includes security measures like withdrawal limits and transaction verification.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["bridge", "interoperability"]
    },
    {
      "query": "What is the withdrawal process from Starknet to Ethereum?",
      "expectedTopics": ["withdrawal", "L2-L1", "bridge", "finalization"],
      "expectedContent": "Withdrawals from Starknet to Ethereum involve: 1) Initiating withdrawal on L2 (burning tokens), 2) Waiting for L2 state update to be proven and verified on L1, 3) Finalizing the withdrawal on L1 to receive tokens (permissionless process that anyone can trigger).",
      "type": "procedural",
      "difficulty": "intermediate",
      "tags": ["bridge", "withdrawal"]
    },
    {
      "query": "What is a class hash in Starknet?",
      "expectedTopics": ["class hash", "contract classes", "declaration"],
      "expectedContent": "A class hash uniquely identifies a contract class (code) in Starknet. It's derived from the Sierra representation of the contract and is used to reference contract code during deployment. Contract classes must be declared (registered) on Starknet before they can be used.",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "deployment"]
    },
    {
      "query": "What is a compiled class hash in Starknet?",
      "expectedTopics": [
        "compiled class hash",
        "CASM",
        "Sierra",
        "compilation"
      ],
      "expectedContent": "A compiled class hash uniquely identifies the CASM (Cairo Assembly) representation of a contract. It's derived from the compiled Sierra code and is stored in the classes trie. The compiled class hash enables on-chain verification of Cairo code execution.",
      "type": "factual",
      "difficulty": "advanced",
      "tags": ["smart contracts", "compilation"]
    },
    {
      "query": "How are contract addresses determined in Starknet?",
      "expectedTopics": [
        "contract address",
        "address calculation",
        "deployment"
      ],
      "expectedContent": "Contract addresses in Starknet are deterministically calculated based on the deployer address, salt (random value), contract class hash, and constructor calldata. This enables counterfactual deployment and address prediction before actual deployment.",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["smart contracts", "deployment"]
    },
    {
      "query": "What are the main development tools for Starknet?",
      "expectedTopics": [
        "development tools",
        "Scarb",
        "Starknet Foundry",
        "Starkli"
      ],
      "expectedContent": "Key Starknet development tools include Scarb (package manager/build system), Starknet Foundry (smart contract development framework), VS Code Cairo extension (editor support), Starknet Devnet (local development), and Starkli (CLI for interaction).",
      "type": "factual",
      "difficulty": "basic",
      "tags": ["tools", "development"]
    },
    {
      "query": "How can I set up a local Starknet development environment?",
      "expectedTopics": ["development environment", "devnet", "setup"],
      "expectedContent": "Set up a Starknet development environment by: 1) Installing Scarb for Cairo compilation, 2) Installing Starkli for contract interaction, 3) Setting up a local devnet or connecting to Sepolia testnet, and 4) Optionally installing IDE extensions and Starknet Foundry for testing.",
      "type": "procedural",
      "difficulty": "basic",
      "tags": ["tools", "devnet", "quickstart"]
    },
    {
      "query": "What frameworks exist for building dApps on Starknet?",
      "expectedTopics": ["dApp development", "frameworks", "frontend"],
      "expectedContent": "Frameworks for Starknet dApp development include Scaffold-Stark (Next.js-based starter), Starknet React (React hooks), wallet connection libraries like Get Starknet and Starknetkit, Invisible SDK (email-based onboarding), and Starkweb (TypeScript toolkit).",
      "type": "factual",
      "difficulty": "intermediate",
      "tags": ["tools", "dapps", "frontend"]
    },
    {
      "query": "How does the fee mechanism work in Starknet?",
      "expectedTopics": ["fee mechanism", "gas", "transaction fees"],
      "expectedContent": "Starknet's fee mechanism calculates costs based on actual resource usage (computation, storage, etc.). Fees can be paid in both ETH and STRK tokens. A portion of STRK fees is converted to ETH to cover L1 costs, while some STRK is burned. Fee estimation is provided before transaction execution.",
      "type": "conceptual",
      "difficulty": "intermediate",
      "tags": ["fees", "economics"]
    },
    {
      "query": "What wallets support Starknet?",
      "expectedTopics": ["wallets", "account contracts", "user interface"],
      "expectedContent": "Starknet-compatible wallets include ArgentX, Braavos, MetaMask Snaps, Ledger hardware wallet support, and various other options with features like social recovery, multisig functionality, and bundled transaction support.",
      "type": "factual",
      "difficulty": "basic",
      "tags": ["wallets", "ecosystem"]
    },
    {
      "query": "How do system calls work in Cairo contracts?",
      "expectedTopics": ["system calls", "contract interaction", "OS"],
      "expectedContent": "System calls in Cairo contracts are special functions that interact with the Starknet Operating System. They include calls for storage access, contract deployment, L1 messaging, emitting events, getting execution information, and other privileged operations not directly accessible through Cairo code.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["smart contracts", "cairo", "system calls"]
    },
    {
      "query": "What is data availability in Starknet?",
      "expectedTopics": ["data availability", "state updates", "volition"],
      "expectedContent": "Data availability in Starknet refers to how state update data is made available. Starknet uses a hybrid approach called Volition, where users can choose between Full Rollup mode (data posted on Ethereum L1) or Validium mode (data kept off-chain with data availability committee verification).",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["architecture", "scalability"]
    },
    {
      "query": "How do Starknet full nodes work?",
      "expectedTopics": ["full nodes", "synchronization", "state management"],
      "expectedContent": "Starknet full nodes (like Pathfinder, Juno, Madara) maintain a local copy of the network state, process transactions, and serve RPC requests. They synchronize with the network by processing blocks from L1 and other sequencers, rebuilding the state trie, and validating state transitions.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["nodes", "infrastructure"]
    },
    {
      "query": "What is the SHARP prover system in Starknet?",
      "expectedTopics": ["SHARP", "provers", "STARK proofs", "verification"],
      "expectedContent": "SHARP (Shared Prover) is Starknet's proving system that generates STARK proofs for state transitions. It batches multiple state updates into a single proof for efficiency, processes proofs asynchronously from transaction execution, and submits verification to Ethereum L1 to ensure finality and security.",
      "type": "conceptual",
      "difficulty": "advanced",
      "tags": ["provers", "zk-proofs", "verification"]
    }
  ]
}
