{
  "version": "1.0.0",
  "timestamp": 1752258151089,
  "optimizerType": "MiPRO",
  "optimizerConfig": {
    "numCandidates": 5,
    "initTemperature": 0.7,
    "maxBootstrappedDemos": 15,
    "maxLabeledDemos": 10,
    "numTrials": 8,
    "minibatch": true,
    "minibatchSize": 25,
    "minibatchFullEvalSteps": 10,
    "programAwareProposer": true,
    "dataAwareProposer": true,
    "tipAwareProposer": true,
    "fewshotAwareProposer": true,
    "earlyStoppingTrials": 5,
    "minImprovementThreshold": 0.01,
    "bayesianOptimization": false,
    "acquisitionFunction": "expected_improvement",
    "explorationWeight": 0.1,
    "sampleCount": 1
  },
  "currentRound": 5,
  "totalRounds": 5,
  "bestScore": 0,
  "bestConfiguration": {
    "instruction": "Analyze the input systematically and provide a precise, well-reasoned response. Be very specific and detailed in your instructions.",
    "bootstrappedDemos": 1,
    "labeledExamples": 1
  },
  "scoreHistory": [0, 0, 0, 0, 0],
  "configurationHistory": [
    {
      "instruction": "Analyze the input systematically and provide a precise, well-reasoned response. Be very specific and detailed in your instructions.",
      "bootstrappedDemos": 0,
      "labeledExamples": 7
    },
    {
      "instruction": "Think through this step-by-step, considering all relevant factors before responding. Focus on step-by-step reasoning in your instructions.",
      "bootstrappedDemos": 1,
      "labeledExamples": 8
    },
    {
      "instruction": "Examine the input carefully and generate an accurate, detailed answer. Provide clear constraints and guidelines in your instructions.",
      "bootstrappedDemos": 1,
      "labeledExamples": 9
    },
    {
      "instruction": "Process the information methodically and deliver a clear, comprehensive response. Keep your instructions concise and to the point.",
      "bootstrappedDemos": 0,
      "labeledExamples": 7
    },
    {
      "instruction": "Consider the context thoroughly and provide a thoughtful, accurate answer. Emphasize accuracy and precision in your instructions.",
      "bootstrappedDemos": 0,
      "labeledExamples": 2
    }
  ],
  "stats": {
    "totalCalls": 0,
    "successfulDemos": 0,
    "estimatedTokenUsage": 0,
    "earlyStopped": true,
    "resourceUsage": {
      "totalTokens": 0,
      "totalTime": 262222,
      "avgLatencyPerEval": 0,
      "costByModel": {}
    },
    "convergenceInfo": {
      "converged": true,
      "finalImprovement": 0,
      "stagnationRounds": 5,
      "convergenceThreshold": 0.01
    },
    "earlyStopping": {
      "bestScoreRound": 0,
      "patienceExhausted": true,
      "reason": "No improvement for 5 trials"
    }
  },
  "optimizerState": {
    "bootstrappedDemos": 1,
    "labeledExamples": 10,
    "instructions": 5,
    "optimizedGen": true,
    "final": true
  },
  "examples": [
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n// This exercise won't compile... Can you make it compile?\n\n\n\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "No specific context was provided. To make a Cairo file compile, it must contain valid Cairo syntax. A minimal compilable Cairo program can be an empty library file or a file containing a basic function, such as `fn main() {}`.",
      "expected": {
        "answer": "```cairo\n\n// This exercise won't compile... Can you make it compile?\n\nfn main() {\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// This exercise doesn't do anything yet but it still compiles! Cairo file getting run\n// needs to have a `main` function. So this file is a valid Cairo file.\n// Other exercises will require you to write Cairo code to make the exercise file compile.\n\n// I AM NOT DONE\n\nfn main() {}\n\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "The Cairo Virtual Machine (Cairo VM) is a process VM designed for provable general-purpose computing. A Cairo program (`.cairo`) compiles into Cairo bytecode (CASM), which the VM interprets to generate an execution trace. This trace is used by the Cairo Prover to generate a STARK proof, proving correct program execution. The VM produces two key outputs for proof generation: **AIR Private Input (Witness)** (execution trace, memory) and **AIR Public Input** (initial/final states, public memory, configuration).\n\nThe Cairo machine is a theoretical model defining a STARK-friendly Von Neumann architecture, implementing a Turing-complete process VM. It has a **CPU (Execution Model)** with a custom zero-knowledge ISA (ZK-ISA) and registers (`pc`, `ap`, `fp`), and a **Memory Model** defining interaction with a non-deterministic Read-only Memory.\n\nThere are two versions:\n*   **Deterministic Machine (Prover)**: Verifies the validity of an execution trace and memory.\n*   **Non-deterministic Machine (Verifier)**: Relies on the deterministic machine, taking initial/final states and partial memory to verify if a valid trace exists.\n\n**Arithmetic Intermediate Representation (AIR)** is an arithmetization technique converting computations into polynomial equations for proof systems. The Cairo machine is a collection of AIRs forming a Turing-complete machine for the Cairo ISA, abstracting AIR writing for developers. Each component (CPU, Memory, Builtins) has its own AIR.\n\n**Cairo Memory Model**:\nCairo uses a **non-deterministic read-only memory model**, meaning memory addresses and values are asserted by the prover and values are immutable once assigned (write-once). Memory addresses are contiguous. This model prioritizes efficiency in proof generation.\n\nMemory is organized into dynamically expanding **segments**, each with a unique identifier and offset (`<segment_id>:<offset>`), forming a **relocatable value**. At execution end, these are transformed into a single, contiguous memory address space with a **relocation table**.\n\nCairo's memory segments:\n*   **Program Segment**: Stores bytecode (instructions). `pc` starts here. Fixed size.\n*   **Execution Segment**: Stores runtime data (variables, call frames, pointers). `ap` and `fp` start here.\n*   **Builtin Segment**: Stores builtins, each with its own dynamically allocated segment.\n*   **User Segment**: Stores program outputs, arrays, dynamically allocated data.\n\nSegment Layout: Segment 0 = Program, Segment 1 = Execution, Segment 2 to x = Builtin, Segment x+1 to y = User.\n\nExample of memory handling:\n```cairo\n%builtins output\n\nfunc main(output_ptr: felt*) -> (output_ptr: felt*) {\n\n    // We are allocating three different values to segment 1.\n    [ap] = 10, ap++;\n    [ap] = 100, ap++;\n    [ap] = [ap - 2] + [ap - 1], ap++;\n\n    // We set value of output_ptr to the address of where the output will be stored.\n    // This is part of the output builtin requirement.\n    [ap] = output_ptr, ap++;\n\n    // Asserts that output_ptr equals to 110.\n    assert [output_ptr] = 110;\n\n    // Returns the output_ptr + 1 as the next unused memory address.\n    return (output_ptr=output_ptr + 1);\n}\n```\n\n**Cairo VM Instruction Set and Execution Flow**:\nCairo programs compile into Casm code. Each instruction and argument increments the Program Counter (PC) by 1. `call` and `ret` instructions implement a function stack.\n*   `call`: Jumps to a given PC value (relative `rel` or absolute `abs`).\n*   `ret`: Jumps back to the instruction immediately following the `call`.\n\nExample Casm code and execution flow:\n```cairo,noplayground\n1\tcall rel 3\n2\tret\n3\tcall rel 9\n4\t[ap + 0] = 1, ap++\n5\t[ap + 0] = [ap + -1] + [ap + -2], ap++\n6\tret\n7\t[ap + 0] = 1, ap++\n8\tret\n9\t[ap + 0] = 2, ap++\n10\tret\n11\tret\n```\n1.  `call rel 3` (PC=1): Jumps to PC=4 (line 3 `call rel 9`).\n2.  `call rel 9` (PC=4): Jumps to PC=13 (line 9 `[ap + 0] = 2, ap++`).\n3.  `[ap + 0] = 2, ap++` (PC=13): Stores `2` at `ap`, increments `ap`.\n4.  `ret` (PC=14): Jumps back to line 4.\n5.  `[ap + 0] = 1, ap++` (PC=5): Stores `1` at `ap`, increments `ap`.\n6.  `[ap + 0] = [ap + -1] + [ap + -2], ap++` (PC=6): Sums `1` and `2` (from `[ap-1]` and `[ap-2]`), stores `3` at `ap`, increments `ap`.\n7.  `ret` (PC=7): Jumps back to line 2.\n8.  `ret` (PC=3): Final instruction, returns sum.\n\n**Cairo Builtins**:\nBuiltins are predefined, optimized low-level execution units embedded in the Cairo architecture to enhance performance. They operate on dedicated memory segments (memory-mapped I/O) and enforce specific constraints.\n*   **Validation Property**: Constraints a value must satisfy to be written to a builtin memory cell (e.g., Range Check accepts `[0, 2**128)`).\n*   **Deduction Property**: Builtins where some cells are constrained by a validation property.\nIf properties are not met, the Cairo VM will panic. Common builtins include Output, Pedersen, Range Check, ECDSA, Bitwise, EC OP, Keccak, Poseidon, Range Check96, AddMod, MulMod, Segment Arena, Gas, and System.\n\n**Bitwise Builtin**:\nEnables bitwise operations (AND `&`, XOR `^`, OR `|`) on field elements. Each operation consumes 5 memory cells:\n| Offset | Description   | Role   |\n| ------ | ------------- | ------ |\n| 0      | x value       | Input  |\n| 1      | y value       | Input  |\n| 2      | x & y result  | Output |\n| 3      | x ^ y result  | Output |\n| 4      | x \\| y result | Output |\n\nExample Usage:\n```cairo\nfrom starkware.cairo.common.cairo_builtins import BitwiseBuiltin\n\nfunc bitwise_ops{bitwise_ptr: BitwiseBuiltin*}(x: felt, y: felt) -> (and: felt, xor: felt, or: felt) {\n    assert [bitwise_ptr] = x;        // Input x\n    assert [bitwise_ptr + 1] = y;    // Input y\n    let and = [bitwise_ptr + 2];     // x & y\n    let xor = [bitwise_ptr + 3];     // x ^ y\n    let or = [bitwise_ptr + 4];      // x | y\n    let bitwise_ptr = bitwise_ptr + 5;\n    return (and, xor, or);\n}\n```\n\n**Keccak Builtin**:\nImplements the keccak-f1600 permutation for SHA-3 family hash functions. Uses blocks of 16 consecutive cells:\n| Cell Range    | Purpose           | Description                                            |\n| ------------- | ----------------- | ------------------------------------------------------ |\n| First 8 cells | Input state `s`   | Each cell stores 200 bits of the 1600-bit input state  |\n| Next 8 cells  | Output state `s'` | Each cell stores 200 bits of the 1600-bit output state |\nInput cells must be valid field elements < 2^200. Output state is computed lazily upon access and cached.\n\n**Output Builtin**:\nManages the memory's output segment via `output_ptr`, storing values in **public memory** for STARK proof verification. The output segment is a contiguous block of public memory cells. Values written to `output_ptr` become part of the public memory, committing the program to these outputs in the proof. The segment's boundaries are included in the public input for verification.\n\n**Range Check Builtin**:\nVerifies field elements fall within a specific range.\n*   **Standard Range Check**: `[0, 2^128-1]`\n*   **Range Check 96**: `[0, 2^96-1]`\nIt's significantly more efficient than pure Cairo implementations. Operates on a dedicated memory segment with immediate validation upon cell write.\n| Characteristic    | Description                             |\n| ----------------- | --------------------------------------- |\n| Valid values      | Field elements in range `[0, 2^128-1]`  |\n| Error conditions  | Values ≥ 2^128 or relocatable addresses |\n| Validation timing | Immediate (upon cell write)             |\nErrors occur if values are out of range or are relocatable addresses.",
      "expected": {
        "answer": "```cairo\n// This exercise doesn't do anything yet but it still compiles! Cairo file getting run\n// needs to have a `main` function. So this file is a valid Cairo file.\n// Other exercises will require you to write Cairo code to make the exercise file compile.\n\nfn main() {}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Your task is to create an `Array` which holds three elements of type `felt252`.\n// The first element should be 0.\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\nfn create_array() -> Array<felt252> {\n    let a = ArrayTrait::new(); // something to change here...\n    a.append(1);\n    a\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_array_len() {\n    let mut a = create_array();\n    assert(a.len() == 3, 'Array length is not 3');\n    assert(a.pop_front().unwrap() == 0, 'First element is not 0');\n}\n\n```\n\nHint: You can declare an array in Cairo using the following syntax:\n`let your_array = ArrayTrait::new();`\nYou can append elements to an array using the following syntax:\n`your_array.append(element);`\n\nThe `pop_front` method removes the first element from the array and returns an Option::Some(value) if the array is not empty, or Option::None() if the array is empty.\n",
      "chat_history": "",
      "context": "Functions in Cairo are declared using the `fn` keyword. An array can be declared using `ArrayTrait::new()`. Elements can be added to an array using the `append` method, e.g., `your_array.append(element);`. The `pop_front` method removes and returns the first element of an array as an `Option::Some(value)` or `Option::None()` if empty. To modify an array, it must be declared as mutable using `mut`.",
      "expected": {
        "answer": "```cairo\n// Your task is to create an `Array` which holds three elements of type `felt252`.\n// The first element should be 0.\n// Make me compile and pass the test!\n\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new();\n    a.append(0);\n    a.append(1);\n    a.append(2);\n    a\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_array_len() {\n    let mut a = create_array();\n    assert(a.len() == 3, 'Array length is not 3');\n    assert(a.pop_front().unwrap() == 0, 'First element is not 0');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Your task is to make the test pass without modifying the `create_array` function.\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\n// Don't modify this function\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new();\n    a.append(42);\n    a\n}\n\nfn remove_element_from_array(\n    ref a: Array<felt252>\n) { //TODO something to do here...Is there an array method I can use?\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2() {\n    let mut a = create_array();\n    assert(*a.at(0) == 42, 'First element is not 42');\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2_empty() {\n    let mut a = create_array();\n    remove_element_from_array(ref a);\n    assert(a.len() == 0, 'Array length is not 0');\n}\n\n```\n\nHint: How can you remove the first element from the array?\nTake a look at the previous exercise for a hint. Don't forget to call `.unwrap()` on the returned value.\nThis will prevent the `Variable not dropped` error.\n",
      "chat_history": "",
      "context": "Functions in Cairo are declared using the `fn` keyword. They can take parameters (with type annotations) and return values. The `ref` keyword indicates that a parameter is a mutable reference, allowing the function to modify the passed argument.\n\nCairo's `Array` type provides methods for manipulation. To create a new array, `ArrayTrait::new()` is used. Elements can be added using `append()`. To remove an element from the front of an array, the `pop_front()` method can be used. `pop_front()` returns a `Result` or `Option` type, so `.unwrap()` is often called on its return value to extract the contained value or panic if the operation fails (e.g., if the array is empty). The `len()` method returns the current number of elements in the array.\n\nExample of array creation and appending:\n```cairo\nlet mut a = ArrayTrait::new();\na.append(42);\n```\n\nExample of removing the first element and unwrapping:\n```cairo\na.pop_front().unwrap();\n```\n\nTesting in Cairo uses the `#[test]` attribute. The `assert!` macro is used within tests to verify conditions. If an assertion fails, the test will panic.",
      "expected": {
        "answer": "```cairo\n// Your task is to make the test pass without modifying the `create_array` function.\n// Make me compile and pass the test!\n\n\n\n// Don't modify this function\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new();\n    a.append(42);\n    a\n}\n\nfn remove_element_from_array(ref a: Array<felt252>) {\n    let _ = a.pop_front();\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2() {\n    let mut a = create_array();\n    assert(a.len() == 1, 'Array should have one element');\n    assert(*a.at(0) == 42, 'First element should be 42');\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2_empty() {\n    let mut a = create_array();\n    remove_element_from_array(ref a);\n    assert(a.len() == 0, 'Array length is not 0');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\nfn create_array() -> Array<felt252> {\n    let a = ArrayTrait::new(); // something to change here...\n    a.append(0);\n    a.append(1);\n    a.append(2);\n    a.pop_front().unwrap();\n    a\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_arrays3() {\n    let mut a = create_array();\n    //TODO modify the method called below to make the test pass.\n    // You should not change the index accessed.\n    a.at(2);\n}\n\n```\n\nHint: The test fails because you are trying to access an element that is out of bounds!\nBy using array.pop_front(), we remove the first element from the array, so the index of the last element is no longer 2.\nWithout changing the index accessed, how can we make the test pass? Is there a method that returns an option that could help us?\n",
      "chat_history": "",
      "context": "Cairo arrays can be initialized using the `array![]` macro, for example: `array![1, 2, 3]`.\n\nThe `ArrayTrait::pop_front()` method removes the first element from an array and returns an `Option<T>`. Using `.unwrap()` on the result will panic if the option is `None` (i.e., the array was empty).\n\nThe `ArrayTrait::at(index)` method provides access to an element at a specific index. If the index is out of bounds, this method will panic. To avoid panicking when accessing an element, ensure the array has enough elements at the specified index after any modifications (like `pop_front()`).",
      "expected": {
        "answer": "```cairo\n// Make me compile and pass the test!\n\n\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new(); // something to change here...\n    a.append(0);\n    a.append(1);\n    a.append(2);\n    a.pop_front().unwrap();\n    a\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_arrays3() {\n    let mut a = create_array();\n    let _ = a.get(2);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// The Felt252Dict maps a felt252 to a value of the specified type.\n// In this exercise, you will map a `felt252` key to a value of type `u32`.\n\n// Your task is to create a `Felt252Dict`  containing three elements of type `u32`.\n// The first element should map the key 'A' to the value 1, the second key 'B' to the value 2\n// and the third should map 'bob' to the value 3.\n// Make me compile and pass the test!\n\n// I AM NOT DONE\nuse core::dict::Felt252Dict;\n\nfn create_dictionary() -> Felt252Dict<u32> {\n    let mut dict: Felt252Dict<u32> = Default::default();\n//TODO\n\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_dict() {\n    let mut dict = create_dictionary();\n    assert(dict.get('A') == 1, 'First element is not 1');\n    assert(dict.get('B') == 2, 'Second element is not 2');\n    assert(dict.get('bob') == 3, 'Third element is not 3');\n}\n\n```\n\nHint: More info about the Felt252Dict type can be found in the following chapter :\nhttps://book.cairo-lang.org/ch03-02-dictionaries.html\n",
      "chat_history": "",
      "context": "`Felt252Dict`s are key-value storage structures in Cairo that use `felt252` as the key type. `felt252` keys can represent integers, short strings (31 characters or less), or other values convertible to `felt252`.\n\nTo create a `Felt252Dict`, use `Default::default()`:\n```cairo\nuse core::dict::Felt252Dict;\n\nfn main() {\n    let mut contacts: Felt252Dict<felt252> = Default::default();\n\n    // Insert values for different keys\n    contacts.insert('Daniel', 7981364);\n    contacts.insert('Ashley', 6457689);\n    contacts.insert('Katie', 4358291);\n    contacts.insert('Robert', 9561745);\n\n    // Get a value\n    let number = contacts.get('Daniel');\n    // ...\n}\n```\nValues can be inserted using the `insert` method, and retrieved using the `get` method. Keys not present in the dictionary will return the default value for the dictionary's value type (e.g., 0 for `felt252`).",
      "expected": {
        "answer": "```cairo\n// The Felt252Dict maps a felt252 to a value of the specified type.\n// In this exercise, you will map a `felt252` key to a value of type `u32`.\n\n// Your task is to create a `Felt252Dict`  containing three elements of type `u32`.\n// The first element should map the key 'A' to the value 1, the second key 'B' to the value 2\n// and the third should map 'bob' to the value 3.\n// Make me compile and pass the test!\n\nuse core::dict::Felt252Dict;\n\nfn create_dictionary() -> Felt252Dict<u32> {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    // Insert the required key-value pairs\n    dict.insert('A', 1);\n    dict.insert('B', 2);\n    dict.insert('bob', 3);\n\n    dict\n\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_dict() {\n    let mut dict = create_dictionary();\n    assert(dict.get('A') == 1, 'First element is not 1');\n    assert(dict.get('B') == 2, 'Second element is not 2');\n    assert(dict.get('bob') == 3, 'Third element is not 3');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Dictionaries can be used to simulate dynamic array : the value they store can be accessed and modified.\n// Your task is to create a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\nuse core::dict::Felt252Dict;\n\n\nfn multiply_element_by_10(ref dict: Felt252Dict<u32>, n: usize) {\n    //TODO : make a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n\n\n}\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_3() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 3);\n\n    multiply_element_by_10(ref dict, 3);\n\n    assert(dict.get(0) == 10, 'First element is not 10');\n    assert(dict.get(1) == 20, 'Second element is not 20');\n    assert(dict.get(2) == 30, 'Third element is not 30');\n}\n\n#[cfg(test)]\n#[test]\nfn test_4() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 5);\n    dict.insert(3, 10);\n\n    multiply_element_by_10(ref dict, 4);\n\n    assert(dict.get(2) == 50, 'First element is not 50');\n    assert(dict.get(3) == 100, 'First element is not 100');\n\n}\n\n```\n\nHint: More info about the Felt252Dict type can be found in the following chapter :\nhttps://book.cairo-lang.org/ch03-02-dictionaries.html\n",
      "chat_history": "",
      "context": "The provided context details various `core` library functions for `felt252` and integer types (e.g., `u32`, `u128`, `u256`), including arithmetic operations like `u32_wrapping_add` and `u256_overflowing_mul`. It also contains comprehensive examples for testing Starknet contracts using `snforge_std`, covering contract declaration and deployment, dispatcher usage, event spying (`spy_events`, `assert_emitted`), and cheatcodes (`start_cheat_caller_address`). Important rules for contract testing imports are also outlined. This context does not include specific details or examples for `Felt252Dict` operations (like `get` or `insert`) or general looping constructs, which are relevant to the query's task of modifying dictionary elements. The query itself indicates the use of `core::dict::Felt252Dict`.",
      "expected": {
        "answer": "```cairo\n// Dictionaries can be used to simulate dynamic array : the value they store can be accessed and modified.\n// Your task is to create a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n// Make me compile and pass the test!\n\nuse core::dict::Felt252Dict;\n\nfn multiply_element_by_10(ref dict: Felt252Dict<u32>, n: usize) {\n    //TODO : make a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n    for i in 0..n {\n        let current_value = dict.get(i.into());\n        dict.insert(i.into(), current_value * 10);\n    }\n}\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_3() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 3);\n\n    multiply_element_by_10(ref dict, 3);\n\n    assert(dict.get(0) == 10, 'First element is not 10');\n    assert(dict.get(1) == 20, 'Second element is not 20');\n    assert(dict.get(2) == 30, 'Third element is not 30');\n}\n\n#[cfg(test)]\n#[test]\nfn test_4() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 5);\n    dict.insert(3, 10);\n\n    multiply_element_by_10(ref dict, 4);\n\n    assert(dict.get(2) == 50, 'First element is not 50');\n    assert(dict.get(3) == 100, 'First element is not 100');\n\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Custom data structure using dicts\n// Using Felt252Dict in structs allow us to simulate mutable data structures\n// In this exercise we have a struct Team where a Felt252Dict maps the name of a player to its level and keeps track of\n// the number of player.\n// Using the methods set and get from the Felt252DictTrait, implement the required functions to interact with the team\n// Make me compile and pass the test!\n\n// I AM NOT DONE\nuse core::dict::Felt252Dict;\n\n#[derive(Destruct)]\nstruct Team {\n    level: Felt252Dict<usize>,\n    players_count: usize\n}\n\n#[generate_trait]\nimpl TeamImpl of TeamTrait {\n    fn new() -> Team {\n        //TODO : initialize empty team with 0 player\n    }\n\n    fn get_level(ref self: Team, name: felt252) -> usize {\n        //TODO\n    }\n\n    fn add_player(ref self: Team, name: felt252, level: usize) -> () {\n        //TODO\n    }\n\n    fn level_up(ref self: Team, name: felt252) {\n        //TODO\n    }\n\n    fn players_count(self: @Team) -> usize {\n        //TODO\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_add_player() {\n    let mut team = TeamTrait::new();\n    team.add_player('bob', 10);\n    team.add_player('alice', 20);\n\n    assert(team.players_count == 2, 'Wrong number of player');\n    assert(team.get_level('bob') == 10, 'Wrong level');\n    assert(team.get_level('alice') == 20, 'Wrong level');\n}\n\n#[cfg(test)]\n#[test]\nfn test_level_up() {\n    let mut team = TeamTrait::new();\n    team.add_player('bobby', 10);\n    team.level_up('bobby');\n\n    assert(team.level.get('bobby') == 11, 'Wrong level');\n}\n\n```\n\nHint: Example of dicts can be found in this chapter :\nhttps://book.cairo-lang.org/ch03-02-dictionaries.html\n",
      "chat_history": "",
      "context": "Cairo's `Felt252Dict` is a key-value storage structure that uses `felt252` as the key type. It can be initialized using `Default::default()`.\n\nExample of `Felt252Dict` usage:\n```cairo\nuse core::dict::Felt252Dict;\nuse core::default::Default;\n\nfn main() {\n    let mut contacts: Felt252Dict<felt252> = Default::default();\n\n    // Insert values for different keys\n    contacts.insert('Daniel', 7981364);\n    contacts.insert('Ashley', 6457689);\n\n    // Get a value\n    let number = contacts.get('Daniel');\n    // Keys not in the dict return the default value (0 for felt252)\n    let number_brandon = contacts.get('Brandon');\n}\n```\n\nThe `insert(key, value)` method adds or updates a value for a given key. The `get(key)` method retrieves the value associated with the key; if the key is not found, it returns the default value for the dictionary's value type (e.g., `0` for `usize` or `felt252`).",
      "expected": {
        "answer": "```cairo\n// Custom data structure using dicts\n// Using Felt252Dict in structs allow us to simulate mutable data structures\n// In this exercise we have a struct Team where a Felt252Dict maps the name of a player to its level and keeps track of\n// the number of player.\n// Using the methods set and get from the Felt252DictTrait, implement the required functions to interact with the team\n// Make me compile and pass the test!\n\nuse core::dict::Felt252Dict;\n\n#[derive(Destruct)]\nstruct Team {\n    level: Felt252Dict<usize>,\n    players_count: usize\n}\n\n#[generate_trait]\nimpl TeamImpl of TeamTrait {\n    fn new() -> Team {\n        Team {\n            level: Default::default(),\n            players_count: 0\n        }\n    }\n\n    fn get_level(ref self: Team, name: felt252) -> usize {\n        self.level.get(name)\n    }\n\n    fn add_player(ref self: Team, name: felt252, level: usize) -> () {\n        self.level.insert(name, level);\n        self.players_count += 1;\n    }\n\n    fn level_up(ref self: Team, name: felt252) {\n        let current_level = self.level.get(name);\n        self.level.insert(name, current_level + 1);\n    }\n\n    fn players_count(self: @Team) -> usize {\n        *self.players_count\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_add_player() {\n    let mut team = TeamTrait::new();\n    team.add_player('bob', 10);\n    team.add_player('alice', 20);\n\n    assert(team.players_count == 2, 'Wrong number of player');\n    assert(team.get_level('bob') == 10, 'Wrong level');\n    assert(team.get_level('alice') == 20, 'Wrong level');\n}\n\n#[cfg(test)]\n#[test]\nfn test_level_up() {\n    let mut team = TeamTrait::new();\n    team.add_player('bobby', 10);\n    team.level_up('bobby');\n\n    assert(team.level.get('bobby') == 11, 'Wrong level');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\nuse core::fmt::{Display, Formatter, Error};\n\n#[derive(Drop)]\nenum Message { // TODO: define a few types of messages as used below\n}\n\nfn main() { // don't change any of the lines inside main\n    println!(\"{}\", Message::Quit);\n    println!(\"{}\", Message::Echo);\n    println!(\"{}\", Message::Move);\n    println!(\"{}\", Message::ChangeColor);\n}\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo => format!(\"Echo\"),\n            Message::Move => format!(\"Move\"),\n            Message::ChangeColor => format!(\"ChangeColor\"),\n        };\n        f.buffer.append(@str);\n        Result::Ok(())\n    }\n}\n\n```\n\nHint: https://book.cairo-lang.org/ch06-01-enums.html",
      "chat_history": "",
      "context": "The `Result` type in Cairo is an enum used for returning and propagating errors, with variants `Ok(T)` for success and `Err(E)` for error. Its definition is:\n```cairo\nenum Result<T, E> {\n   Ok: T,\n   Err: E,\n}\n```\nFunctions that might fail and allow for recovery typically return `Result`. For example:\n```cairo\nfn parse_version(header: felt252) -> Result<felt252, felt252> {\n    match header {\n        0 => Ok(0),\n        1 => Ok(1),\\n        _ => Err('invalid version'),\n    }\n}\n```\nThe `Formatter` struct, used in `core::fmt::Display`, has a `buffer` member of type `ByteArray` (`pub buffer: ByteArray`) to which formatted output can be appended. The `core::fmt::Error` is a dedicated type for representing formatting errors.\n\nEnums in Cairo are defined using the `enum` keyword. For example, an enum with variants `Quit`, `Echo`, `Move`, and `ChangeColor` would be structured as follows:\n\n```cairo\n#[derive(Drop)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor,\n}\n```",
      "expected": {
        "answer": "```cairo\nuse core::fmt::{Display, Formatter, Error};\n\n#[derive(Drop)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor,\n}\n\nfn main() { // don't change any of the lines inside main\n    println!(\"{}\", Message::Quit);\n    println!(\"{}\", Message::Echo);\n    println!(\"{}\", Message::Move);\n    println!(\"{}\", Message::ChangeColor);\n}\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo => format!(\"Echo\"),\n            Message::Move => format!(\"Move\"),\n            Message::ChangeColor => format!(\"ChangeColor\"),\n        };\n        f.buffer.append(@str);\n        Result::Ok(())\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nuse core::fmt::{Display, Formatter, Error};\n\n#[derive(Copy, Drop)]\nenum Message { // TODO: define the different variants used below\n}\n\n\nfn main() { // don't change any of the lines inside main\n    let mut messages: Array<Message> = ArrayTrait::new();\n\n    //don't change any of the next 4 lines\n    messages.append(Message::Quit);\n    messages.append(Message::Echo('hello world'));\n    messages.append(Message::Move((10, 30)));\n    messages.append(Message::ChangeColor((0, 255, 255)));\n\n    print_messages_recursive(messages, 0)\n}\n\n// Utility function to print messages. Don't modify these.\n\ntrait MessageTrait<T> {\n    fn call(self: T);\n}\n\nimpl MessageImpl of MessageTrait<Message> {\n    fn call(self: Message) {\n        println!(\"{}\", self);\n    }\n}\n\nfn print_messages_recursive(messages: Array<Message>, index: u32) {\n    if index >= messages.len() {\n        return ();\n    }\n    let message = *messages.at(index);\n    message.call();\n    print_messages_recursive(messages, index + 1)\n}\n\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        println!(\"___MESSAGE BEGINS___\");\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo(msg) => format!(\"{}\", msg),\n            Message::Move((a, b)) => { format!(\"{} {}\", a, b) },\n            Message::ChangeColor((red, green, blue)) => { format!(\"{} {} {}\", red, green, blue) },\n        };\n        f.buffer.append(@str);\n        println!(\"___MESSAGE ENDS___\");\n        Result::Ok(())\n    }\n}\n\n```\n\nHint: You can create enumerations that have different variants with different types\nsuch as no data, structs, a single felt string, tuples, ...etc\nhttps://book.cairo-lang.org/ch06-01-enums.html\n",
      "chat_history": "",
      "context": "Cairo enums can have variants with different types, including no data, single values (like `ByteArray`), or tuples. The `#[derive(Copy, Drop)]` attribute can be used for enums whose variants contain types that are `Copy` and `Drop`.\n\nBased on the usage in the `main` function and the `impl MessageDisplay` block, the `Message` enum should be defined with the following variants and their associated types:\n- `Quit`: No associated data.\n- `Echo`: Takes a `ByteArray` as its associated data.\n- `Move`: Takes a tuple of two `u32` integers, e.g., `(u32, u32)`.\n- `ChangeColor`: Takes a tuple of three `u8` integers, e.g., `(u8, u8, u8)`.\n\nExample of enum definition with various variant types:\n```cairo\n#[derive(Copy, Drop)]\nenum Message {\n    Quit,\n    Echo: ByteArray,\n    Move: (u32, u32),\n    ChangeColor: (u8, u8, u8),\n}\n```",
      "expected": {
        "answer": "```cairo\n\nuse core::fmt::{Display, Formatter, Error};\n\n#[derive(Copy, Drop)]\nenum Message {\n    Quit,\n    Echo: felt252,\n    Move: (u32, u32),\n    ChangeColor: (u8, u8, u8),\n}\n\n\nfn main() { // don't change any of the lines inside main\n    let mut messages: Array<Message> = ArrayTrait::new();\n\n    //don't change any of the next 4 lines\n    messages.append(Message::Quit);\n    messages.append(Message::Echo('hello world'));\n    messages.append(Message::Move((10, 30)));\n    messages.append(Message::ChangeColor((0, 255, 255)));\n\n    print_messages_recursive(messages, 0)\n}\n\n// Utility function to print messages. Don't modify these.\n\ntrait MessageTrait<T> {\n    fn call(self: T);\n}\n\nimpl MessageImpl of MessageTrait<Message> {\n    fn call(self: Message) {\n        println!(\"{}\", self);\n    }\n}\n\nfn print_messages_recursive(messages: Array<Message>, index: u32) {\n    if index >= messages.len() {\n        return ();\n    }\n    let message = *messages.at(index);\n    message.call();\n    print_messages_recursive(messages, index + 1)\n}\n\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        println!(\"___MESSAGE BEGINS___\");\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo(msg) => format!(\"{}\", msg),\n            Message::Move((a, b)) => { format!(\"{} {}\", a, b) },\n            Message::ChangeColor((red, green, blue)) => { format!(\"{} {} {}\", red, green, blue) },\n        };\n        f.buffer.append(@str);\n        println!(\"___MESSAGE ENDS___\");\n        Result::Ok(())\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n\n#[derive(Drop, Copy)]\nenum Message { // TODO: implement the message variant types based on their usage below\n}\n\n#[derive(Drop, Copy)]\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\n#[derive(Drop, Copy)]\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\ntrait StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8));\n    fn quit(ref self: State);\n    fn echo(ref self: State, s: felt252);\n    fn move_position(ref self: State, p: Point);\n    fn process(ref self: State, message: Message);\n}\nimpl StateImpl of StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8)) {\n        let State { color: _, position, quit } = self;\n        self = State { color: new_color, position: position, quit: quit };\n    }\n    fn quit(ref self: State) {\n        let State { color, position, quit: _ } = self;\n        self = State { color: color, position: position, quit: true };\n    }\n\n    fn echo(ref self: State, s: felt252) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(ref self: State, p: Point) {\n        let State { color, position: _, quit } = self;\n        self = State { color: color, position: p, quit: quit };\n    }\n\n    fn process(\n        ref self: State, message: Message,\n    ) { // TODO: create a match expression to process the different message variants\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_match_message_call() {\n    let mut state = State { quit: false, position: Point { x: 0, y: 0 }, color: (0, 0, 0) };\n    state.process(Message::ChangeColor((255, 0, 255)));\n    state.process(Message::Echo('hello world'));\n    state.process(Message::Move(Point { x: 10, y: 15 }));\n    state.process(Message::Quit);\n\n    assert(state.color == (255, 0, 255), 'wrong color');\n    assert(state.position.x == 10, 'wrong x position');\n    assert(state.position.y == 15, 'wrong y position');\n    assert(state.quit == true, 'quit should be true');\n}\n\n```\n\nHint: As a first step, you can define enums to compile this code without errors.\nand then create a match expression in `process()`.\nNote that you need to deconstruct some message variants\nin the match expression to get value in the variant.\nhttps://book.cairo-lang.org/ch06-01-enums.html\n",
      "chat_history": "",
      "context": "In Cairo, an `enum` defines a type that can be one of several variants. Variants can be simple names or can hold associated data, which can be tuples or named types. For example:\n```cairo\n#[derive(Drop)]\nenum Color {\n    Red,\n    Blue,\n    Green,\n    RGB: (u32, u32, u32),\n    HSV: (u32, u32, u32),\n}\n```\nEnums can be destructured using a `match` expression. The `match` expression evaluates a value against a series of patterns. For variants with associated data, you can bind the data to variables within the `match` arm:\n```cairo\nmatch color {\n    Color::Red => println!(\"The color is Red!\"),\n    Color::RGB((r, g, b)) => println!(\"Red: {}, green: {}, and blue: {}!\", r, g, b),\n    // ... other variants\n}\n```\nThe `#[derive(Drop, Copy)]` attribute can be used on enums and structs to automatically implement the `Drop` and `Copy` traits, which are necessary for certain types to be implicitly copied or dropped.\n\nTraits define a set of methods that a type can implement. Methods can take `self` as a snapshot (`@self`) if they don't modify the instance, or as a mutable reference (`ref self`) if they do. For example:\n```cairo\ntrait StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8));\n    fn quit(ref self: State);\n    fn echo(ref self: State, s: felt252);\n    fn move_position(ref self: State, p: Point);\n    fn process(ref self: State, message: Message);\n}\n```\nWhen implementing a trait for an enum, the methods can use `match self` to perform different actions based on the enum variant:\n```cairo\nimpl ProcessingImpl of Processing {\n    fn process(self: Message) {\n        match self {\n            Message::Quit => { println!(\"quitting\") },\n            Message::Echo(value) => { println!(\"echoing {}\", value) },\n            Message::Move((x, y)) => { println!(\"moving from {} to {}\", x, y) },\n        }\n    }\n}\n```",
      "expected": {
        "answer": "```cairo\n// Address all the TODOs to make the tests pass!\n\n\n\n#[derive(Drop, Copy)]\nenum Message {\n    Quit,\n    Echo: felt252,\n    Move: Point,\n    ChangeColor: (u8, u8, u8),\n}\n\n#[derive(Drop, Copy)]\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\n#[derive(Drop, Copy)]\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\ntrait StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8));\n    fn quit(ref self: State);\n    fn echo(ref self: State, s: felt252);\n    fn move_position(ref self: State, p: Point);\n    fn process(ref self: State, message: Message);\n}\nimpl StateImpl of StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8)) {\n        let State { color: _, position, quit } = self;\n        self = State { color: new_color, position: position, quit: quit };\n    }\n    fn quit(ref self: State) {\n        let State { color, position, quit: _ } = self;\n        self = State { color: color, position: position, quit: true };\n    }\n\n    fn echo(ref self: State, s: felt252) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(ref self: State, p: Point) {\n        let State { color, position: _, quit } = self;\n        self = State { color: color, position: p, quit: quit };\n    }\n\n    fn process(\n        ref self: State, message: Message,\n    ) {\n        match message {\n            Message::Quit => self.quit(),\n            Message::Echo(s) => self.echo(s),\n            Message::Move(p) => self.move_position(p),\n            Message::ChangeColor(c) => self.change_color(c),\n        }\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_match_message_call() {\n    let mut state = State { quit: false, position: Point { x: 0, y: 0 }, color: (0, 0, 0) };\n    state.process(Message::ChangeColor((255, 0, 255)));\n    state.process(Message::Echo('hello world'));\n    state.process(Message::Move(Point { x: 10, y: 15 }));\n    state.process(Message::Quit);\n\n    assert(state.color == (255, 0, 255), 'wrong color');\n    assert(state.position.x == 10, 'wrong x position');\n    assert(state.position.y == 15, 'wrong y position');\n    assert(state.quit, 'quit should be true');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n\n```\n\nHint: This main function is calling a function that it expects to exist, but the\nfunction doesn't exist. It expects this function to have the name `call_me`.\nIt expects this function to not take any arguments and not return a value.\nSounds a lot like `main`, doesn't it?",
      "chat_history": "",
      "context": "No relevant documentation context was found.",
      "expected": {
        "answer": "```cairo\n\n\nfn main() {\n    call_me();\n}\n\nfn call_me() {\n    println!(\"Hello, world!\");\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num:) {\n    println!(\"num is {}\", num);\n}\n\n```\n\nHint: Cairo requires that all parts of a function's signature have type annotations,\nbut `call_me` is missing the type annotation of `num`. What is the basic type in Cairo?",
      "chat_history": "",
      "context": "No relevant information found.",
      "expected": {
        "answer": "```cairo\n\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num: u32) {\n    println!(\"num is {}\", num);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n\nfn call_me(num: u64) {\n    println!(\"num is {}\", num);\n}\n\n```\n\nHint: This time, the function *declaration* is okay, but there's something wrong\nwith the place where we're calling the function.\nAs a reminder, you can freely play around with different solutions in Starklings!\nWatch mode will only jump to the next exercise if you remove the I AM NOT DONE comment.",
      "chat_history": "",
      "context": "When a function is declared with parameters, it must be called with arguments that match the number and types of those parameters. For example, if a function `call_me` is defined to accept a `u64` parameter, like `fn call_me(num: u64)`, then any call to `call_me` must provide a `u64` value as an argument, such as `call_me(123u64);`. Calling `call_me()` without any arguments would result in a compilation error because the expected `u64` argument is missing.",
      "expected": {
        "answer": "```cairo\n\n\nfn main() {\n    call_me(5);\n}\n\nfn call_me(num: u64) {\n    println!(\"num is {}\", num);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// This store is having a sale where if the price is an even number, you get\n// 10 Cairobucks off, but if it's an odd number, it's 3 Cairobucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\n// I AM NOT DONE\n\nfn main() {\n    let original_price = 51;\n    println!(\"sale_price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: u32) -> {\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: u32) -> bool {\n    num % 2 == 0\n}\n\n```\n\nHint: The error message points to line 18 and says it expects a type after the\n`->`. This is where the function's return type should be -- take a look at\nthe `is_even` function for an example!\n",
      "chat_history": "",
      "context": "The provided context details the `egcd` function from `core::math`, which calculates the extended Euclidean algorithm. Its signature is `pub fn egcd<T, +Copy<T>, +Drop<T>, +Add<T>, +Mul<T>, +DivRem<T>, +core::num::traits::Zero<T>, +core::num::traits::One<T>, +TryInto<T, NonZero<T>>>(a: NonZero<T>, b: NonZero<T>) -> (T, T, T, bool)`. An example usage is `let (g, s, t, dir) = egcd::<u32>(12, 8); assert!(g == 4);`.",
      "expected": {
        "answer": "```cairo\n// This store is having a sale where if the price is an even number, you get\n// 10 Cairobucks off, but if it's an odd number, it's 3 Cairobucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\n\n\nfn main() {\n    let original_price = 51;\n    println!(\"sale_price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: u32) -> u32 {\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: u32) -> bool {\n    num % 2 == 0\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make the tests pass.\n\n// I AM NOT DONE\n\nfn bigger(a: usize, b: usize) -> usize { // Complete this function to return the bigger number!\n// Do not use:\n// - another function call\n// - additional variables\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::bigger;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert(10 == bigger(10, 8), '10 bigger than 8');\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert(42 == bigger(32, 42), '42 bigger than 32');\n    }\n}\n\n```\n\nHint: Remember in Cairo that:\n- the `if` condition does not need to be surrounded by parentheses\n- `if`/`else` conditionals are expressions\n- Each condition is followed by a `{}` block.",
      "chat_history": "",
      "context": "Cairo is a statically typed language. The `usize` type is an unsigned integer type, currently an alias for `u32`, primarily used for indexing collections.\n\nConditional expressions in Cairo, such as `if`/`else`, do not require parentheses around the condition and are followed by a `{}` block. `if`/`else` constructs are expressions, meaning they can return a value.\n\nExample of `if`/`else` structure:\n```cairo\nif let Some(i) = number {\n    // code block if condition is true\n} else {\n    // code block if condition is false\n}\n```",
      "expected": {
        "answer": "```cairo\n// Make the tests pass.\n\nfn bigger(a: usize, b: usize) -> usize {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::bigger;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert(10 == bigger(10, 8), '10 bigger than 8');\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert(42 == bigger(32, 42), '42 bigger than 32');\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n\n// I AM NOT DONE\n\nfn foo_if_fizz(fizzish: felt252) -> felt252 {\n    // Complete this function using if, else if and/or else blocks.\n    // If fizzish is,\n    // 'fizz', return 'foo'\n    // 'fuzz', return 'bar'\n    // anything else, return 'baz'\n    if fizzish == 'fizz' {\n        'foo'\n    } else {\n        1_u32\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::foo_if_fizz;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert(foo_if_fizz('fizz') == 'foo', 'fizz returns foo')\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert(foo_if_fizz('fuzz') == 'bar', 'fuzz returns bar');\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert(foo_if_fizz('literally anything') == 'baz', 'anything else returns baz');\n    }\n}\n\n```\n\nHint: For that first compiler error, it's important in Cairo that each conditional\nblock returns the same type! To get the tests passing, you will need a couple\nconditions checking different input values.",
      "chat_history": "",
      "context": "Functions in Cairo are declared using the `fn` keyword. Conditional logic can be implemented using `if`, `else if`, and `else` blocks. It is crucial that all branches of a conditional statement return the same type to ensure compilation.\n\nFor example, to handle different string inputs and return corresponding string outputs (represented as `felt252` literals):\n\n```cairo\nfn foo_if_fizz(fizzish: felt252) -> felt252 {\n    if fizzish == 'fizz' {\n        'foo'\n    } else if fizzish == 'fuzz' {\n        'bar'\n    } else {\n        'baz'\n    }\n}\n```\n\nCairo supports unit and integration testing. Tests are typically placed in the same module as the code they test or in a `tests/` directory for integration tests. Test functions are marked with the `#[test]` attribute and use `assert` to verify conditions.\n\nExample of a test function:\n```cairo\n#[cfg(test)]\nmod tests {\n    use super::foo_if_fizz;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert(foo_if_fizz('fizz') == 'foo', 'fizz returns foo')\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert(foo_if_fizz('fuzz') == 'bar', 'fuzz returns bar');\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert(foo_if_fizz('literally anything') == 'baz', 'anything else returns baz');\n    }\n}\n```\n\nThe `#[cfg(test)]` attribute enables conditional compilation, meaning the `mod tests` block will only be compiled when running tests. `felt252` is the basic field element type in Cairo, commonly used for string literals and general-purpose integers.",
      "expected": {
        "answer": "```cairo\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n\n\n\nfn foo_if_fizz(fizzish: felt252) -> felt252 {\n    // Complete this function using if, else if and/or else blocks.\n    // If fizzish is,\n    // 'fizz', return 'foo'\n    // 'fuzz', return 'bar'\n    // anything else, return 'baz'\n    if fizzish == 'fizz' {\n        'foo'\n    } else if fizzish == 'fuzz' {\n        'bar'\n    } else {\n        'baz'\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::foo_if_fizz;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert(foo_if_fizz('fizz') == 'foo', 'fizz returns foo')\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert(foo_if_fizz('fuzz') == 'bar', 'fuzz returns bar');\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert(foo_if_fizz('literally anything') == 'baz', 'anything else returns baz');\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n    //TODO make the test pass without changing any existing line\n    loop {\n        break ();\n        counter += 1;\n    };\n    assert(counter == 10, 'counter should be 10')\n}\n\n```\n\nHint: The `break` condition is reached too early. Can you introduce a condition so that the loop runs a little more?",
      "chat_history": "",
      "context": "Cairo contract testing is facilitated by `snforge_std`, providing utilities for contract interaction and environment manipulation. Key imports include `declare` for contract declaration and deployment, `DeclareResultTrait`, `ContractClassTrait`, `EventSpyAssertionsTrait`, and `spy_events` for event monitoring. Cheatcodes such as `start_cheat_block_number`, `start_cheat_block_timestamp`, `start_cheat_caller_address`, and `stop_cheat_caller_address` allow for modifying test environment values.\n\nTo interact with a deployed contract, traits like `IRegistryDispatcher` and `IRegistryDispatcherTrait` are used, which are derived from the contract's interface.\n\nThe typical contract deployment process in tests involves:\n1. Declaring the contract class using `declare(\"ContractName\")`.\n2. Serializing constructor arguments into an array (e.g., `Serde::serialize(@1_u8, ref constructor_args)`).\n3. Deploying the contract class: `contract.unwrap().contract_class().deploy(@constructor_args).unwrap()`.\n4. Creating a dispatcher instance to interact with the contract: `IRegistryDispatcher { contract_address }`.\n\nTest patterns demonstrated include:\n- Setting a caller address for transactions using `start_cheat_caller_address(dispatcher.contract_address, caller)` and clearing it with `stop_cheat_caller_address`.\n- Verifying contract state with `assert(stored_data == 42, 'Wrong stored data')`.\n- Spying on and asserting emitted events:\n    - Initialize `let mut spy = spy_events();`.\n    - Define expected event structs (e.g., `Registry::Event::DataRegistered(DataRegistered { user: caller, data: 42 })`).\n    - Create an array of expected events: `let expected_events = array![(dispatcher.contract_address, expected_event)];`.\n    - Assert event emission using `spy.assert_emitted(@expected_events)`.\n- Testing for expected panics using the `#[should_panic(expected: \"Error message\")]` attribute.\n\nImportant rules for writing tests include:\n- Always use full paths for core library imports.\n- The contract interface (e.g., `IRegistryDispatcher`) is typically defined in the parent of the contract module (e.g., `use registry::{IRegistryDispatcher, IRegistryDispatcherTrait};` for a contract in `use registry::Registry;`).\n- The Dispatcher should be imported from the path where its interface is defined.",
      "expected": {
        "answer": "```cairo\n\n\n\n#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n    //TODO make the test pass without changing any existing line\n    loop {\n        counter += 1;\n        if counter == 10 {\n            break ();\n        }\n    };\n    assert(counter == 10, 'counter should be 10')\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n\n#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n\n    let result = loop {\n        if counter == 5 {\n    //TODO return a value from the loop\n        }\n        counter += 1;\n    };\n\n    assert(result == 5, 'result should be 5');\n}\n\n```\n\nHint: You can return values from loops by adding the value you want returned after the `break` expression you use to stop the loop. Don't forget that assigning a variable to the value returned from a `loop` is an expression, and thus must end with a semicolomn.\n",
      "chat_history": "",
      "context": "In Cairo, a `loop` expression can return a value. This is achieved by using the `break` keyword followed by the value to be returned. For example, `break expression;` will exit the loop and return `expression`. The value returned from a `loop` expression can be assigned to a variable.",
      "expected": {
        "answer": "```cairo\n\n\n\n\n#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n\n    let result = loop {\n        if counter == 5 {\n            break counter;\n        }\n        counter += 1;\n    };\n\n    assert(result == 5, 'result should be 5');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// We are writing an app for a restaurant,\n// but take_order functions are not being called correctly.\n// Can you fix this?\n\n// I AM NOT DONE\n\npub mod restaurant {\n    pub fn take_order() -> felt252 {\n        'order_taken'\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_mod_fn() {\n    // Fix this line to call take_order function from module\n    let order_result = take_order();\n\n    assert(order_result == 'order_taken', 'Order not taken');\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_super_fn() {\n        // Fix this line to call take_order function\n        let order_result = take_order();\n\n        assert(order_result == 'order_taken', 'Order not taken');\n    }\n}\n\n```\n\nHint: You can bring a parent's modules items in the current module with super::item_name\n",
      "chat_history": "",
      "context": "No relevant information found in the provided context.",
      "expected": {
        "answer": "```cairo\n// We are writing an app for a restaurant,\n// but take_order functions are not being called correctly.\n// Can you fix this?\n\npub mod restaurant {\n    pub fn take_order() -> felt252 {\n        'order_taken'\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_mod_fn() {\n    // Fix this line to call take_order function from module\n    let order_result = restaurant::take_order();\n\n    assert(order_result == 'order_taken', 'Order not taken');\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_super_fn() {\n        // Fix this line to call take_order function\n        let order_result = super::restaurant::take_order();\n\n        assert(order_result == 'order_taken', 'Order not taken');\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n// These modules have some issues, can you fix them?\n\nconst YEAR: u16 = 2050;\n\npub mod order {\n    #[derive(Copy, Drop)]\n    pub struct Order {\n        pub name: felt252,\n        pub year: u16,\n        pub made_by_phone: bool,\n        pub made_by_email: bool,\n        pub item: felt252,\n    }\n\n    pub fn new_order(name: felt252, made_by_phone: bool, item: felt252) -> Order {\n        Order { name, year: YEAR, made_by_phone, made_by_email: !made_by_phone, item,  }\n    }\n}\n\npub mod order_utils {\n    pub fn dummy_phoned_order(name: felt252) -> Order {\n        new_order(name, true, 'item_a')\n    }\n\n    pub fn dummy_emailed_order(name: felt252) -> Order {\n        new_order(name, false, 'item_a')\n    }\n\n    pub fn order_fees(order: Order) -> felt252 {\n        if order.made_by_phone {\n            return 500;\n        }\n\n        200\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_array() {\n    let order1 = order_utils::dummy_phoned_order('John Doe');\n    let fees1 = order_utils::order_fees(order1);\n    assert(fees1 == 500, 'Order fee should be 500');\n\n    let order2 = order_utils::dummy_emailed_order('Jane Doe');\n    let fees2 = order_utils::order_fees(order2);\n    assert(fees2 == 200, 'Order fee should be 200');\n}\n\n```\n\nHint: While using functions/structs and other items from outside the module,\nyou can refer to them with their full path or import them in the current context with the use keyword.\n",
      "chat_history": "",
      "context": "In Cairo, items such as constants, structs, and functions defined in one module are not automatically in scope in other modules. To use an item from an external module, you must either refer to it with its full path or import it into the current context using the `use` keyword.\n\nFor example:\n*   To access a constant defined at the crate root (e.g., `const YEAR: u16`) from within a submodule, you can use `use super::YEAR;` or `use crate::YEAR;`.\n*   To access a struct (e.g., `Order`) and a function (e.g., `new_order`) defined in a sibling module (e.g., `order`) from another module (e.g., `order_utils`), you can import them using `use super::order::{Order, new_order};`.\n\nThe `#[derive(Copy, Drop)]` attribute is used for structs to enable them to be copied and dropped, which is often required for passing them by value or storing them.",
      "expected": {
        "answer": "```cairo\n\n// These modules have some issues, can you fix them?\n\nconst YEAR: u16 = 2050;\n\npub mod order {\n    #[derive(Copy, Drop)]\n    pub struct Order {\n        pub name: felt252,\n        pub year: u16,\n        pub made_by_phone: bool,\n        pub made_by_email: bool,\n        pub item: felt252,\n    }\n\n    pub fn new_order(name: felt252, made_by_phone: bool, item: felt252) -> Order {\n        Order { name, year: super::YEAR, made_by_phone, made_by_email: !made_by_phone, item,  }\n    }\n}\n\npub mod order_utils {\n    use super::order::{new_order, Order};\n\n    pub fn dummy_phoned_order(name: felt252) -> Order {\n        new_order(name, true, 'item_a')\n    }\n\n    pub fn dummy_emailed_order(name: felt252) -> Order {\n        new_order(name, false, 'item_a')\n    }\n\n    pub fn order_fees(order: Order) -> felt252 {\n        if order.made_by_phone {\n            return 500;\n        }\n\n        200\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_array() {\n    let order1 = order_utils::dummy_phoned_order('John Doe');\n    let fees1 = order_utils::order_fees(order1);\n    assert(fees1 == 500, 'Order fee should be 500');\n\n    let order2 = order_utils::dummy_emailed_order('Jane Doe');\n    let fees2 = order_utils::order_fees(order2);\n    assert(fees2 == 200, 'Order fee should be 200');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    //TODO fix the error here without modifying this line.\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n\n```\n\nHint: So you've got the \"ref argument must be a mutable variable.\" error on line 17,\nright? The fix for this is going to be adding one keyword, and the addition is NOT on line 17\nwhere the error is.\n\nAlso: Try accessing `arr0` after having called `fill_arr()`. See what happens!\n\nRead more about move semantics and ownership here: https://book.cairo-lang.org/ch04-01-what-is-ownership.html\n",
      "chat_history": "",
      "context": "The provided context does not contain information directly relevant to Cairo's ownership model or the `ArrayTrait`'s mutability. However, based on the query's error message and hints, the issue is related to mutability and ownership of `Array` instances.\n\nIn Cairo, variables must be explicitly declared as mutable using the `mut` keyword if they are to be modified. When an `Array` is created using `ArrayTrait::new()`, it needs to be bound to a mutable variable if it's intended to be modified later, even if ownership is transferred.\n\nThe `append` method on an `Array` requires a mutable reference (`ref mut self`). If an `Array` is initially created as an immutable binding (e.g., `let arr0 = ArrayTrait::new();`), even if it's passed by value and rebound as mutable within a function (`let mut arr = arr;`), and then returned and assigned to another mutable binding (`let mut arr1 = ...`), the original immutability might prevent subsequent modifications. To ensure the array is mutable throughout its lifecycle, it should be declared mutable at its point of creation.\n\nTherefore, the `arr0` variable, which is the origin of the array, must be declared as mutable: `let mut arr0 = ArrayTrait::new();`. This ensures that the `Array` instance itself is considered mutable from its inception, allowing subsequent mutable operations like `append` on `arr1` after ownership transfer.",
      "expected": {
        "answer": "```cairo\nfn main() {\n    let mut arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    //TODO fix the error here without modifying this line.\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n\n}\n\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile without changing the indicated lines\n\n// I AM NOT DONE\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut _arr1 = fill_arr(arr0);\n\n    // Do not change the following line!\n    print_arr(arr0);\n}\n\nfn print_arr(arr: Array<felt252>) {\n    println!(\"arr: {:?}\", arr);\n}\n\n// Do not change the following line!\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n\n```\n\nHint: So, `arr0` is passed into the `fill_arr` function as an argument. In Cairo,\nwhen an argument is passed to a function and it's not explicitly returned,\nyou can't use the original variable anymore. We call this \"moving\" a variable.\nVariables that are moved into a function (or block scope) and aren't explicitly\nreturned get \"dropped\" at the end of that function. This is also what happens here.\nThere's a few ways to fix this, try them all if you want:\n1. Make another, separate version of the data that's in `arr0` and pass that\n   to `fill_arr` instead.\n2. Make `fill_arr` *mutably* borrow a reference to its argument (which will need to be\n   mutable) with the `ref` keyword , modify it directly, then not return anything. Then you can get rid\n   of `arr1` entirely -- note that this will change what gets printed by the\n   first `print`\n3. Make `fill_arr` borrow an immutable view of its argument instead of taking ownership by using the snapshot operator `@`,\n   and then copy the data within the function in order to return an owned\n   `Array<felt>`. This requires an explicit clone of the array and should generally be avoided in Cairo, as the memory is write-once and cloning can be expensive. To clone an object, you will need to import the trait `clone::Clone` and the implementation of the Clone trait for the array located in `array::ArrayTCloneImpl`",
      "chat_history": "",
      "context": "The `core::fmt` module provides `fmt` trait functions for `Display`, `LowerHex`, and `Debug` traits. These functions allow types to be formatted into a `Formatter`, with a signature like `fn fmt<T, T>(self: @T, ref f: Formatter) -> Result<(), Error>`. The `core::iter::traits::collect::IntoIterator` trait provides the `into_iter` function, which converts a type into an iterator. Its signature is `fn into_iter<T, T>(self: T) -> IntoIterator<T>IntoIter`. An example of using `into_iter` with an array is:\n\n```cairo\nlet mut iter = array![1, 2, 3].into_iter();\n\nassert_eq!(Some(1), iter.next());\nassert_eq!(Some(2), iter.next());\nassert_eq!(Some(3), iter.next());\nassert_eq!(None, iter.next());\n```",
      "expected": {
        "answer": "```cairo\n// Make me compile without changing the indicated lines\n\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    // Do not change the following line!\n    print_arr(arr0);\n}\n\nfn print_arr(arr: Array<felt252>) {\n    println!(\"arr: {:?}\", arr);\n}\n\n// Do not change the following line!\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n\n// I AM NOT DONE\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n\n```\n\nHint: The difference between this one and the previous ones is that the first line\nof `fn fill_arr` that had `let mut arr = arr;` is no longer there. You can,\ninstead of adding that line back, add `mut` in one place that will change\nan existing binding to be a mutable binding instead of an immutable one :)",
      "chat_history": "",
      "context": "The provided context describes `serialize` and `extend` trait functions. The `extend` function signature `fn extend<T, A, T, A, I, impl IntoIter: IntoIterator<I>, +TypeEqual<IntoIter::Iterator::Item, A>, +Destruct<IntoIter::IntoIter>, +Destruct<I>>(ref self: T, iter: I)` indicates that it takes `self` by mutable reference (`ref self: T`), implying that methods modifying a collection often require the collection instance to be mutable. In Cairo, to modify a variable or a function parameter within its scope, it must be declared as mutable using the `mut` keyword. For example, if a function modifies an `Array<felt252>` passed as a parameter using methods like `append`, that parameter must be declared `mut`.",
      "expected": {
        "answer": "```cairo\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(mut arr: Array<felt252>) -> Array<felt252> {\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Refactor this code so that instead of passing `arr0` into the `fill_arr` function,\n// the Array gets created in the function itself and passed back to the main\n// function.\n\n// I AM NOT DONE\n\nfn main() {\n    let arr0 = ArrayTrait::<felt252>::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\n// `fill_arr()` should no longer take `arr: Array<felt252>` as argument\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n\n```\n\nHint: Stop reading whenever you feel like you have enough direction :) Or try\ndoing one step and then fixing the compiler errors that result!\nSo the end goal is to:\n   - get rid of the first line in main that creates the new array\n   - so then `arr0` doesn't exist, so we can't pass it to `fill_arr`\n   - we don't want to pass anything to `fill_arr`, so its signature should\n     reflect that it does not take any arguments\n   - since we're not creating a new array in `main` anymore, we need to create\n     a new array in `fill_arr`, similarly to the way we did in `main`",
      "chat_history": "",
      "context": "No relevant information found. The task requires refactoring existing Cairo code based on the provided instructions and hints. The core changes involve modifying function signatures and moving array initialization.",
      "expected": {
        "answer": "```cairo\n// Refactor this code so that instead of passing `arr0` into the `fill_arr` function,\n// the Array gets created in the function itself and passed back to the main\n// function.\n\nfn main() {\n    let mut arr1 = fill_arr();\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\n// `fill_arr()` should no longer take `arr: Array<felt252>` as argument\nfn fill_arr() -> Array<felt252> {\n    let mut arr = ArrayTrait::<felt252>::new();\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n\n// I AM NOT DONE\n\n#[cfg(test)]\n#[test]\nfn main() {\n    let mut a = ArrayTrait::new();\n    let mut b = pass_by_value(a);\n    pass_by_ref(ref a);\n    pass_by_ref(ref b);\n    pass_by_snapshot(@a);\n}\n\nfn pass_by_value(mut arr: Array<felt252>) -> Array<felt252> {\n    arr\n}\n\nfn pass_by_ref(ref arr: Array<felt252>) {}\n\nfn pass_by_snapshot(x: @Array<felt252>) {}\n\n```\n\nHint: Carefully reason about how each function takes ownership of the variable passed.\nIt depends on the keyword used to pass the variable.\nWhat happens when a function takes ownership of a variable and then returns it?\nCan we still use it later on?\n",
      "chat_history": "",
      "context": "Cairo functions can take arguments in different ways, affecting ownership and usability of the variable after the call:\n- **By value (`T`)**: The variable is moved into the function, and the caller loses ownership. The variable cannot be used by the caller after the call unless it is returned by the function. An example signature is `fn destruct<T, T>(self: T)`.\n- **By mutable reference (`ref T`)**: The function borrows the variable mutably. The caller retains ownership, and the variable remains valid and usable after the call. Examples include `fn extend<T, A, ...>(ref self: T, iter: I)` and `fn sub_eq<T, T>(ref self: T, other: T)`.\n- **By snapshot (`@T`)**: The function takes an immutable snapshot of the variable. The caller retains ownership, and the variable remains valid and usable after the call. Examples include `fn fmt<T, T>(self: @T, ref f: Formatter)` and `fn read<T, T>(self: @T)`.",
      "expected": {
        "answer": "```cairo\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n\n\n\n#[cfg(test)]\n#[test]\nfn main() {\n    let mut a = ArrayTrait::new();\n    pass_by_ref(ref a);\n    pass_by_snapshot(@a);\n    let mut b = pass_by_value(a);\n    pass_by_ref(ref b);\n}\n\nfn pass_by_value(mut arr: Array<felt252>) -> Array<felt252> {\n    arr\n}\n\nfn pass_by_ref(ref arr: Array<felt252>) {}\n\nfn pass_by_snapshot(x: @Array<felt252>) {}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// You can't change anything except adding or removing references.\n\n// I AM NOT DONE\n\n#[derive(Drop)]\nstruct Number {\n    value: u32, \n}\n\nfn main() {\n    let mut number = Number { value: 1111111 };\n\n    get_value(number);\n\n    set_value(number);\n}\n\n// Should not take ownership and not modify the variable passed.\nfn get_value(number: Number) -> u32 {\n    number.value\n}\n\n// Should take ownership\nfn set_value(number: Number) {\n    let value = 2222222;\n    number = Number { value };\n    println!(\"Number is: {}\", number.value);\n}\n\n```\n\nHint: The first problem is that `get_value` is taking ownership of the Number struct.\nSo `Number` is moved and can't be used for `set_value`\n`number` is moved to `get_value` first, meaning that `set_value` cannot manipulate the data.\nWhat can we use to pass an immutable reference to `get_value`? What special operator do we use for that?\nWhat other operator do we use to \"desnap\" a snapshot?\nHint: It involves the `@` and `*` operators.\n\nOnce you've fixed that, `set_value`'s function signature will also need to be adjusted.\nCan you figure out how?\n",
      "chat_history": "",
      "context": "In Cairo, functions can take ownership of variables passed to them. When a variable is passed by value, it is moved into the function's scope and becomes unavailable to the caller after the function returns.\n\nTo avoid taking ownership and allow the caller to retain control of the variable, functions can accept references:\n*   **Immutable References**: An immutable reference is denoted by `@T`, where `T` is the type. A function receiving an `@T` reference can read the value but cannot modify it. To access fields of a referenced struct, the reference must be dereferenced using the `*` operator (e.g., `(*reference).field`). At the call site, an immutable reference is passed using `@variable` (e.g., `get_value(@my_var)`).\n*   **Mutable References**: A mutable reference is denoted by `ref T`. A function receiving a `ref T` reference can directly modify the original variable. This includes reassigning the entire variable (e.g., `ref_param = new_value;`) or modifying its fields (e.g., `ref_param.field = new_field_value;`). For a variable to be passed as a mutable reference, it must be declared as `mut` in the calling scope (e.g., `let mut my_var = ...;`), and at the call site, it is passed using `ref variable` (e.g., `set_value(ref my_var)`).\n\nThe `#[derive(Drop)]` attribute automatically implements the `Drop` trait for a struct, ensuring proper resource deallocation when the variable goes out of scope.",
      "expected": {
        "answer": "```cairo\n// You can't change anything except adding or removing references.\n\n#[derive(Drop)]\nstruct Number {\n    value: u32,\n}\n\nfn main() {\n    let mut number = Number { value: 1111111 };\n\n    get_value(@number);\n\n    set_value(number);\n}\n\n// Should not take ownership and not modify the variable passed.\nfn get_value(number: @Number) -> u32 {\n    *number.value\n}\n\n// Should take ownership\nfn set_value(mut number: Number) {\n    let value = 2222222;\n    number = Number { value };\n    println!(\"Number is: {}\", number.value);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Integer types implement basic comparison and arithmetic operators.\n// Felt252 operations should be avoided where possible, as they could have unwanted behavior.\n\n// I AM NOT DONE\n\n\nfn poly(x: usize, y: usize) -> usize {\n    // Return the solution of x^3 + y - 2\n    // FILL ME\n    res // Do not change\n}\n\n\n// Do not change the test function\n#[cfg(test)]\n#[test]\nfn test_poly() {\n    let res = poly(5, 3);\n    assert(res == 126, 'Error message');\n    assert(res < 300, 'res < 300');\n    assert(res <= 300, 'res <= 300');\n    assert(res > 20, 'res > 20');\n    assert(res >= 2, 'res >= 2');\n    assert(res != 27, 'res != 27');\n    assert(res % 2 == 0, 'res %2 != 0');\n}\n\n```\n\nHint: You can check the list of available operators here:\nhttps://book.cairo-lang.org/appendix-02-operators-and-symbols.html\n",
      "chat_history": "",
      "context": "In Cairo, the `usize` type is an alias for `u32`. Integer types, such as `u32`, implement basic comparison and arithmetic operators. The `core::integer` module provides built-in integer types and their associated operations, while the `core::ops` module defines overloadable operators. Standard arithmetic operations like multiplication (`*`), addition (`+`), and subtraction (`-`) are available for integer types.",
      "expected": {
        "answer": "```cairo\n// Integer types implement basic comparison and arithmetic operators.\n// Felt252 operations should be avoided where possible, as they could have unwanted behavior.\n\n\n\n\nfn poly(x: usize, y: usize) -> usize {\n    // Return the solution of x^3 + y - 2\n    let res = x * x * x + y - 2;\n    res // Do not change\n}\n\n\n// Do not change the test function\n#[cfg(test)]\n#[test]\nfn test_poly() {\n    let res = poly(5, 3);\n    assert(res == 126, 'Error message');\n    assert(res < 300, 'res < 300');\n    assert(res <= 300, 'res <= 300');\n    assert(res > 20, 'res > 20');\n    assert(res >= 2, 'res >= 2');\n    assert(res != 27, 'res != 27');\n    assert(res % 2 == 0, 'res %2 != 0');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Remember last time you calculated division in Cairo0?\n// Now Cairo1 has native integer types e.g. u8, u32, ...u256, usize which support more operators than felts\n// And always watch out for overflows e.g in the last test\n// Let try to use them\n\n// I AM NOT DONE\n\nfn modulus(x: u8, y: u8) -> u8 {\n    // calculate the modulus of x and y\n    // FILL ME\n    res\n}\n\nfn floor_division(x: usize, y: usize) -> usize {\n    // calculate the floor_division of x and y\n    // FILL ME\n    res\n}\n\nfn multiplication(x: u64, y: u64) -> u64 {\n    // calculate the multiplication of x and y\n    // FILL ME\n    res\n}\n\n\n// Do not change the tests\n#[cfg(test)]\n#[test]\nfn test_modulus() {\n    let res = modulus(16, 2);\n    assert(res == 0, 'Error message');\n\n    let res = modulus(17, 3);\n    assert(res == 2, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\nfn test_floor_division() {\n    let res = floor_division(160, 2);\n    assert(res == 80, 'Error message');\n\n    let res = floor_division(21, 4);\n    assert(res == 5, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\nfn test_mul() {\n    let res = multiplication(16, 2);\n    assert(res == 32, 'Error message');\n\n    let res = multiplication(21, 4);\n    assert(res == 84, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn test_u64_mul_overflow_1() {\n    let _res = multiplication(0x100000000, 0x100000000);\n}\n\n```\n\nHint: Use % for modulus, / for division, and * for multiplication.",
      "chat_history": "",
      "context": "Cairo 1 introduces native integer types such as `u8`, `u32`, `u64`, `u128`, `u256`, and `usize`, which support standard arithmetic operators. These types allow for direct use of operators like modulus (`%`), division (`/`), and multiplication (`*`). When performing multiplication with these native integer types, it is important to be aware of potential overflows, which can cause a panic if the result exceeds the type's maximum capacity. For example, `u64` multiplication can panic on overflow. The `core::math` module provides more advanced mathematical operations like `egcd`, `inv_mod`, and modular arithmetic functions for `u256` (e.g., `u256_mul_mod_n`, `u256_div_mod_n`), but basic arithmetic operations are directly supported by the native types.",
      "expected": {
        "answer": "```cairo\n// Remember last time you calculated division in Cairo0?\n// Now Cairo1 has native integer types e.g. u8, u32, ...u256, usize which support more operators than felts\n// And always watch out for overflows e.g in the last test\n// Let try to use them\n\nfn modulus(x: u8, y: u8) -> u8 {\n    // calculate the modulus of x and y\n    x % y\n}\n\nfn floor_division(x: usize, y: usize) -> usize {\n    // calculate the floor_division of x and y\n    x / y\n}\n\nfn multiplication(x: u64, y: u64) -> u64 {\n    // calculate the multiplication of x and y\n    x * y\n}\n\n\n// Do not change the tests\n#[cfg(test)]\n#[test]\nfn test_modulus() {\n    let res = modulus(16, 2);\n    assert(res == 0, 'Error message');\n\n    let res = modulus(17, 3);\n    assert(res == 2, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\nfn test_floor_division() {\n    let res = floor_division(160, 2);\n    assert(res == 80, 'Error message');\n\n    let res = floor_division(21, 4);\n    assert(res == 5, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\nfn test_mul() {\n    let res = multiplication(16, 2);\n    assert(res == 32, 'Error message');\n\n    let res = multiplication(21, 4);\n    assert(res == 84, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn test_u64_mul_overflow_1() {\n    let _res = multiplication(0x100000000, 0x100000000);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n\n// This function returns how much icecream there is left in the fridge.\n// If it's before 10PM, there's 5 pieces left. At 10PM, someone eats them\n// all, so there'll be no more left :(\nfn maybe_icecream(\n    time_of_day: usize\n) -> Option<usize> { // We use the 24-hour system here, so 10PM is a value of 22 and 12AM is a value of 0\n// The Option output should gracefully handle cases where time_of_day > 23.\n// TODO: Complete the function body - remember to return an Option!\n}\n\n\n#[cfg(test)]\n#[test]\nfn check_icecream() {\n    assert(maybe_icecream(9).unwrap() == 5, 'err_1');\n    assert(maybe_icecream(10).unwrap() == 5, 'err_2');\n    assert(maybe_icecream(23).unwrap() == 0, 'err_3');\n    assert(maybe_icecream(22).unwrap() == 0, 'err_4');\n    assert(maybe_icecream(25).is_none(), 'err_5');\n}\n\n#[cfg(test)]\n#[test]\nfn raw_value() {\n    // TODO: Fix this test. How do you get at the value contained in the Option?\n    let icecreams = maybe_icecream(12);\n    assert(icecreams == 5, 'err_6');\n}\n\n```\n\nHint: Options can have a Some value, with an inner value, or a None value, without an inner value.\nThere's multiple ways to get at the inner value, you can use unwrap, or pattern match. Unwrapping\nis the easiest, but how do you do it safely so that it doesn't panic in your face later?\nhttps://book.cairo-lang.org/ch06-01-enums.html#the-option-enum-and-its-advantages\n",
      "chat_history": "",
      "context": "Functions in Cairo are declared using the `fn` keyword, followed by the function name, parameters in parentheses, and the return type after an arrow `->`. The `Option<T>` enum is used to represent the presence (`Some(T)`) or absence (`None`) of a value. To access the value inside a `Some` variant of an `Option`, you can use methods like `unwrap()`, which will panic if the `Option` is `None`. Alternatively, pattern matching can be used for safer handling of `Option` values. Control flow statements like `if`, `else if`, and `else` are used to execute different blocks of code based on conditions.",
      "expected": {
        "answer": "```cairo\n\n\n\n\n// This function returns how much icecream there is left in the fridge.\n// If it's before 10PM, there's 5 pieces left. At 10PM, someone eats them\n// all, so there'll be no more left :(\nfn maybe_icecream(\n    time_of_day: usize\n) -> Option<usize> {\n    if time_of_day > 23 {\n        None\n    } else if time_of_day < 22 {\n        Some(5)\n    } else {\n        Some(0)\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn check_icecream() {\n    assert(maybe_icecream(9).unwrap() == 5, 'err_1');\n    assert(maybe_icecream(10).unwrap() == 5, 'err_2');\n    assert(maybe_icecream(23).unwrap() == 0, 'err_3');\n    assert(maybe_icecream(22).unwrap() == 0, 'err_4');\n    assert(maybe_icecream(25).is_none(), 'err_5');\n}\n\n#[cfg(test)]\n#[test]\nfn raw_value() {\n    // TODO: Fix this test. How do you get at the value contained in the Option?\n    let icecreams = maybe_icecream(12);\n    assert(icecreams.unwrap() == 5, 'err_6');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n\n#[cfg(test)]\n#[test]\nfn test_options() {\n    let target = 'starklings';\n    let optional_some = Option::Some(target);\n    let optional_none: Option<felt252> = Option::None;\n    simple_option(optional_some);\n    simple_option(optional_none);\n}\n\nfn simple_option(optional_target: Option<felt252>) {\n    // TODO: use the `is_some` and `is_none` methods to check if `optional_target` contains a value.\n    // Place the assertion and the print statement below in the correct blocks.\n    assert(optional_target.unwrap() == 'starklings', 'err1');\n    println!(\" option is empty ! \");\n}\n\n```\n\nHint: check out: https://github.com/starkware-libs/cairo/blob/main/corelib/src/option.cairo\nto see the implementation of the Option type and its methods.\n",
      "chat_history": "",
      "context": "The `Option<T>` enum in Cairo represents either `Some(value)` or `None`. It is defined as:\n\n```cairo\npub enum Option {\n    Some: T,\n    None,\n}\n```\n\nThe `OptionTrait` provides methods for `Option<T>` operations. One such method is `is_some`, which returns `true` if the `Option` is `Some`, and `false` otherwise. Conversely, `is_none` returns `true` if the `Option` is `None`. The `unwrap()` method is used to extract the value from a `Some` variant; it will panic if called on a `None` variant.",
      "expected": {
        "answer": "```cairo\n\n\n\n\n#[cfg(test)]\n#[test]\nfn test_options() {\n    let target = 'starklings';\n    let optional_some = Option::Some(target);\n    let optional_none: Option<felt252> = Option::None;\n    simple_option(optional_some);\n    simple_option(optional_none);\n}\n\nfn simple_option(optional_target: Option<felt252>) {\n    // TODO: use the `is_some` and `is_none` methods to check if `optional_target` contains a value.\n    // Place the assertion and the print statement below in the correct blocks.\n    if optional_target.is_some() {\n        assert!(optional_target.unwrap() == 'starklings');\n        println!(\" option is empty ! \");\n    } else {\n        assert!(optional_target.is_none());\n        println!(\" option is empty ! \");\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n\n#[derive(Drop)]\nstruct Student {\n    name: felt252,\n    courses: Array<Option<felt252>>,\n}\n\n\nfn display_grades(student: @Student) {\n    let mut msg = ArrayTrait::new();\n    msg.append(*student.name);\n    msg.append('\\'s grades:');\n    println!(\"{:?}\", msg);\n\n    for course in student.courses.span() {\n        // TODO: Modify the following lines so that if there is a grade for the course, it is printed.\n        //       Otherwise, print \"No grade\".\n        //\n        println!(\"grade is {}\", course.unwrap());\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_all_defined() {\n    let courses = array![\n        Option::Some('A'),\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::Some('A'),\n    ];\n    let mut student = Student { name: 'Alice', courses: courses };\n    display_grades(@student);\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_some_empty() {\n    let courses = array![\n        Option::Some('A'),\n        Option::None,\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::None,\n    ];\n    let mut student = Student { name: 'Bob', courses: courses };\n    display_grades(@student);\n}\n\n```\n\nHint: Reminder: You can use a match statement with an Option to handle both the Some and None cases.\nThis syntax is more flexible than using unwrap, which only handles the Some case, and contributes to more robust code.\n",
      "chat_history": "",
      "context": "The `core::option` module includes the `Option<T>` type, for which a `destruct` function is available: `fn destruct(self: Option<T>)`.",
      "expected": {
        "answer": "```cairo\n\n\n#[derive(Drop)]\nstruct Student {\n    name: felt252,\n    courses: Array<Option<felt252>>,\n}\n\n\nfn display_grades(student: @Student) {\n    let mut msg = ArrayTrait::new();\n    msg.append(*student.name);\n    msg.append('\\'s grades:');\n    println!(\"{:?}\", msg);\n\n    for course in student.courses.span() {\n        if course.is_some() {\n            println!(\"grade is {}\", course.unwrap());\n        } else {\n            println!(\"No grade\");\n        }\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_all_defined() {\n    let courses = array![\n        Option::Some('A'),\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::Some('A'),\n    ];\n    let mut student = Student { name: 'Alice', courses: courses };\n    display_grades(@student);\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_some_empty() {\n    let courses = array![\n        Option::Some('A'),\n        Option::None,\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::None,\n    ];\n    let mut student = Student { name: 'Bob', courses: courses };\n    display_grades(@student);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let // Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n\n```\n\nHint: No hints this time ;)",
      "chat_history": "",
      "context": "Functions in Cairo are declared using the `fn` keyword. Arguments are type-annotated, and the return type is specified after an arrow `->`. The final expression in a function is used as the return value, or the `return` statement can be used for early returns.\n\nCairo programs are primarily composed of statements, such as variable bindings (`let x = 5;`) and expressions ending with a semicolon. Blocks are also expressions; the last expression in a block is assigned as its value, unless it ends with a semicolon, in which case the block returns the unit type `()`.\n\nCairo is a statically typed language. Scalar types include felts, integers, and booleans.\nThe `felt252` type is the default if no type is specified.\nInteger types (e.g., `u8`, `u16`, `u32`, `u64`, `u128`, `u256`, `usize`) are recommended for security due to built-in overflow/underflow checks. `usize` is an alias for `u32` and used for indexing. Signed integers are prefixed with `i` (e.g., `i8`). Integer literals can be decimal, hex (`0xff`), octal (`0o04321`), or binary (`0b01`), and can have type suffixes (e.g., `57_u8`).\nStandard mathematical operations (addition, subtraction, multiplication, division, remainder) are supported for integer types.\n\nThe Boolean type (`bool`) has two values: `true` and `false`. It occupies one `felt252`. When declaring a `bool` variable, `true` or `false` literals must be used. Booleans are primarily used in conditional expressions.\n\n```cairo\nfn main() {\n    let t = true;\n    let f: bool = false; // with explicit type annotation\n}\n```",
      "expected": {
        "answer": "```cairo\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening = false;\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // A short string is a string whose length is at most 31 characters, and therefore can fit into a single field element.\n    // Short strings are actually felts, they are not a real string.\n    // Note the _single_ quotes that are used with short strings.\n\n    let mut my_first_initial = 'C';\n    if is_alphabetic(\n        ref my_first_initial\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref my_first_initial\n    ) {\n        println!(\" Numerical !\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n\n    let  // Finish this line like the example! What's your favorite short string?\n    // Try a letter, try a number, try a special character, try a short string!\n    if is_alphabetic(\n        ref your_character\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref your_character\n    ) {\n        println!(\" Numerical!\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n}\n\nfn is_alphabetic(ref char: felt252) -> bool {\n    if char >= 'a' {\n        if char <= 'z' {\n            return true;\n        }\n    }\n    if char >= 'A' {\n        if char <= 'Z' {\n            return true;\n        }\n    }\n    false\n}\n\nfn is_numeric(ref char: felt252) -> bool {\n    if char >= '0' {\n        if char <= '9' {\n            return true;\n        }\n    }\n    false\n}\n\n// Note: the following code is not part of the challenge, it's just here to make the code above work.\n// Direct felt252 comparisons have been removed from the core library, so we need to implement them ourselves.\n// There will probably be a string / short string type in the future\nimpl PartialOrdFelt of PartialOrd<felt252> {\n    #[inline(always)]\n    fn le(lhs: felt252, rhs: felt252) -> bool {\n        !(rhs < lhs)\n    }\n    #[inline(always)]\n    fn ge(lhs: felt252, rhs: felt252) -> bool {\n        !(lhs < rhs)\n    }\n    #[inline(always)]\n    fn lt(lhs: felt252, rhs: felt252) -> bool {\n        let lhs_u256: u256 = lhs.into();\n        let rhs_u256: u256 = rhs.into();\n        lhs_u256 < rhs_u256\n    }\n    #[inline(always)]\n    fn gt(lhs: felt252, rhs: felt252) -> bool {\n        rhs < lhs\n    }\n}\n\n```\n\nHint: No hints this time ;)",
      "chat_history": "",
      "context": "`felt252` is the basic field element in Cairo, representing an integer in the range 0 ≤ x < P. Short strings, which are 31 characters or less, are represented as `felt252` values and are denoted using single quotes, e.g., `'...'`.\n\nThe `PartialOrd` trait allows for ordering comparisons (`<`, `<=`, `>`, `>=`). The provided code implements `PartialOrd<felt252>` manually, defining `le`, `ge`, `lt`, and `gt` functions for `felt252` comparisons, which are no longer directly available in the core library.\n\nThe code snippet requires completing a line to declare and initialize a `felt252` variable with a short string literal, similar to the example `let mut my_first_initial = 'C';`.",
      "expected": {
        "answer": "```cairo\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\nfn main() {\n    // A short string is a string whose length is at most 31 characters, and therefore can fit into a single field element.\n    // Short strings are actually felts, they are not a real string.\n    // Note the _single_ quotes that are used with short strings.\n\n    let mut my_first_initial = 'C';\n    if is_alphabetic(\n        ref my_first_initial\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref my_first_initial\n    ) {\n        println!(\" Numerical !\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n\n    let mut your_character = 'A'; // Finish this line like the example! What's your favorite short string?\n    // Try a letter, try a number, try a special character, try a short string!\n    if is_alphabetic(\n        ref your_character\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref your_character\n    ) {\n        println!(\" Numerical!\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n}\n\nfn is_alphabetic(ref char: felt252) -> bool {\n    if char >= 'a' {\n        if char <= 'z' {\n            return true;\n        }\n    }\n    if char >= 'A' {\n        if char <= 'Z' {\n            return true;\n        }\n    }\n    false\n}\n\nfn is_numeric(ref char: felt252) -> bool {\n    if char >= '0' {\n        if char <= '9' {\n            return true;\n        }\n    }\n    false\n}\n\n// Note: the following code is not part of the challenge, it's just here to make the code above work.\n// Direct felt252 comparisons have been removed from the core library, so we need to implement them ourselves.\n// There will probably be a string / short string type in the future\nimpl PartialOrdFelt of PartialOrd<felt252> {\n    #[inline(always)]\n    fn le(lhs: felt252, rhs: felt252) -> bool {\n        !(rhs < lhs)\n    }\n    #[inline(always)]\n    fn ge(lhs: felt252, rhs: felt252) -> bool {\n        !(lhs < rhs)\n    }\n    #[inline(always)]\n    fn lt(lhs: felt252, rhs: felt252) -> bool {\n        let lhs_u256: u256 = lhs.into();\n        let rhs_u256: u256 = rhs.into();\n        lhs_u256 < rhs_u256\n    }\n    #[inline(always)]\n    fn gt(lhs: felt252, rhs: felt252) -> bool {\n        rhs < lhs\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Destructure the `cat` tuple to call print on each member.\n\n// I AM NOT DONE\n\nfn main() {\n    let cat = ('Furry McFurson', 3);\n    let // your pattern here = cat;\n    println!(\"name is {}\", name);\n    println!(\"age is {}\", age);\n}\n\n```\n\nHint: You'll need to make a pattern to bind `name` and `age` to the appropriate parts\nof the tuple.\nIf you're familiar with Rust, you should know that Cairo has a similar syntax to \ndestructure tuples into multiple variables.\nhttps://book.cairo-lang.org/ch02-02-data-types.html?highlight=destructu#the-tuple-type\nYou can do it!!\n",
      "chat_history": "",
      "context": "In Cairo, `enum` variants can be destructured using a `match` expression. For example, an `enum` variant holding a tuple can be destructured with a pattern like `Color::RGB((r, g, b))`, where `(r, g, b)` extracts the tuple's elements into new variables.\n\n```cairo\n#[derive(Drop)]\nenum Color {\n    RGB: (u32, u32, u32),\n}\n\nfn main() {\n    let color = Color::RGB((122, 17, 40));\n    match color {\n        Color::RGB((r, g, b)) => println!(\"Red: {}, green: {}, and blue: {}!\", r, g, b),\n    }\n}\n```\n\nFunctions are declared using the `fn` keyword. Arguments are type-annotated, and the return type is specified after an arrow `->`. The final expression in a function is used as the return value, or the `return` statement can be used for early returns. Functions that do not explicitly return a value implicitly return the unit type `()`, and their return type can be omitted from the signature.",
      "expected": {
        "answer": "```cairo\n// Destructure the `cat` tuple to call print on each member.\n\n\n\nfn main() {\n    let cat = ('Furry McFurson', 3);\n    let (name, age) = cat;\n    println!(\"name is {}\", name);\n    println!(\"age is {}\", age);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Modify the integer types to make the tests pass.\n// Learn how to convert between integer types, and felts.\n\n// I AM NOT DONE\n\nfn sum_u8s(x: u8, y: u8) -> u8 {\n    x + y\n}\n\n//TODO modify the types of this function to prevent an overflow when summing big values\nfn sum_big_numbers(x: u8, y: u8) -> u8 {\n    x + y\n}\n\nfn convert_to_felt(x: u8) -> felt252 { //TODO return x as a felt252.\n}\n\nfn convert_felt_to_u8(x: felt252) -> u8 { //TODO return x as a u8.\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_u8s() {\n    assert(sum_u8s(1, 2_u8) == 3_u8, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_big_numbers() {\n    //TODO modify this test to use the correct integer types.\n    // Don't modify the values, just the types.\n    // See how using the _u8 suffix on the numbers lets us specify the type?\n    // Try to do the same thing with other integer types.\n    assert(sum_big_numbers(255_u8, 255_u8) == 510_u8, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_felt() {\n    assert(convert_to_felt(1_u8) == 1, 'Type conversion went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_u8() {\n    assert(convert_felt_to_u8(1) == 1_u8, 'Type conversion went wrong');\n}\n\n```\n\nHint: There are multiple integer types in Cairo. You can read about them here:\nhttps://book.cairo-lang.org/ch02-02-data-types.html#integer-types\nIf you try to sum two integers and the result is bigger than the biggest integer of this type, you'll get a compilation error.\nYou can convert integers to felts using the `.into()` method. Make sure that you imported the `Into` trait.\nYou can convert felts to integers using the `.try_into()` method. Make sure that you imported the `TryInto` trait.\nThis method will return an `Option` type, so you'll need to unwrap it. To use the `unwrap()` method, you'll need to import the `OptionTrait` trait.\nTake a look at the top of the file to see how these traits are imported.\n",
      "chat_history": "",
      "context": "Cairo provides various integer types, including `u8`, `u16`, `u32`, `u64`, `u128`, `u256`, and `felt252`. `felt252` is the basic field element, representing an integer in the range `0 ≤ x < P` (where P is a large prime).\n\nNumeric literals can be type-annotated using a suffix (e.g., `1_u8`, `2_u32`, `3_i32`). Unsuffixed numeric literals default to `felt252` if no other type constraint is present.\n\nWhen performing arithmetic operations, if the result exceeds the maximum value for the integer type, it will lead to a compilation error (overflow). To prevent this, use a larger integer type (e.g., `u16`, `u32`, `u64`, `u128`, `u256`) that can accommodate the expected sum.\n\nType conversions between integers and `felt252` are handled using specific traits:\n*   **Integer to `felt252`**: Use the `.into()` method. This requires importing the `Into` trait: `use core::traits::Into;`.\n*   **`felt252` to Integer**: Use the `.try_into()` method. This conversion might fail (e.g., if the `felt252` value is out of the target integer type's range), so it returns an `Option<T>`. This requires importing the `TryInto` trait: `use core::traits::TryInto;`.\n\nThe `Option<T>` enum represents an optional value, being either `Some(T)` (containing a value) or `None` (no value). To extract the value from an `Option::Some` variant, you can use the `.unwrap()` method. If `.unwrap()` is called on an `Option::None` variant, it will panic. Using `.unwrap()` requires importing the `OptionTrait`: `use core::option::OptionTrait;`.\n\nExample of `felt252` to `u8` conversion using `try_into()`:\n```cairo\nfn parse_u8(s: felt252) -> Result<u8, felt252> {\n    match s.try_into() {\n        Some(value) => Ok(value),\n        None => Err('Invalid integer'),\n    }\n}\n```",
      "expected": {
        "answer": "```cairo\n// Modify the integer types to make the tests pass.\n// Learn how to convert between integer types, and felts.\n\n\nfn sum_u8s(x: u8, y: u8) -> u8 {\n    x + y\n}\n\n//TODO modify the types of this function to prevent an overflow when summing big values\nfn sum_big_numbers(x: u16, y: u16) -> u16 {\n    x + y\n}\n\nfn convert_to_felt(x: u8) -> felt252 {\n    x.into()\n}\n\nfn convert_felt_to_u8(x: felt252) -> u8 {\n    x.try_into().unwrap()\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_u8s() {\n    assert(sum_u8s(1, 2_u8) == 3_u8, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_big_numbers() {\n    //TODO modify this test to use the correct integer types.\n    // Don't modify the values, just the types.\n    // See how using the _u8 suffix on the numbers lets us specify the type?\n    // Try to do the same thing with other integer types.\n    assert(sum_big_numbers(255_u16, 255_u16) == 510_u16, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_felt() {\n    assert(convert_to_felt(1_u8) == 1, 'Type conversion went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_u8() {\n    assert(convert_felt_to_u8(1) == 1_u8, 'Type conversion went wrong');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 3 cairobucks.\n// - If Mary buys more than 40 apples, each apple only costs 2 cairobuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\nfn calculate_price_of_apples{\n\n}\n\n// Do not change the tests!\n#[cfg(test)]\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert(105 == price1, 'Incorrect price');\n    assert(120 == price2, 'Incorrect price');\n    assert(82 == price3, 'Incorrect price');\n    assert(130 == price4, 'Incorrect price');\n}\n\n```\n\nHint: No hints this time ;)",
      "chat_history": "",
      "context": "The task is to implement a Cairo function `calculate_price_of_apples` that calculates the total price of apples based on the quantity purchased. The pricing rules are:\n- If the quantity of apples is 40 or less, each apple costs 3 cairobucks.\n- If the quantity of apples is more than 40, each apple costs 2 cairobucks.\n\nThe function should take one argument, the `quantity` of apples, and return the total `price`.\n\nExample test cases provided:\n- `calculate_price_of_apples(35)` should return `105` (35 * 3).\n- `calculate_price_of_apples(40)` should return `120` (40 * 3).\n- `calculate_price_of_apples(41)` should return `82` (41 * 2).\n- `calculate_price_of_apples(65)` should return `130` (65 * 2).\n\nThe function signature should be `fn calculate_price_of_apples(quantity: u32) -> u32`. The implementation will involve a conditional statement to apply the correct price per apple based on the `quantity`.",
      "expected": {
        "answer": "```cairo\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 3 cairobucks.\n// - If Mary buys more than 40 apples, each apple only costs 2 cairobuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\nfn calculate_price_of_apples(quantity: u32) -> u32 {\n    if quantity > 40 {\n        quantity * 2\n    } else {\n        quantity * 3\n    }\n}\n\n// Do not change the tests!\n#[cfg(test)]\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert(105 == price1, 'Incorrect price');\n    assert(120 == price2, 'Incorrect price');\n    assert(82 == price3, 'Incorrect price');\n    assert(130 == price4, 'Incorrect price');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Starkling, Joe, is writing a really simple contract.\n// The contract shows that he is the owner of the contract.\n// However, his contract is not working. What's he missing?\n\n// I AM NOT DONE\n\n#[starknet::interface]\ntrait IJoesContract<TContractState> {\n    fn get_owner(self: @TContractState) -> felt252;\n}\n\n#[starknet::contract]\nmod JoesContract {\n    #[storage]\n    struct Storage {}\n\n    impl IJoesContractImpl of super::IJoesContract<ContractState> {\n        fn get_owner(self: @ContractState) -> felt252 {\n            'Joe'\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{ContractClassTrait, DeclareResultTrait, declare};\n    use super::{IJoesContractDispatcher, IJoesContractDispatcherTrait, JoesContract};\n\n    #[test]\n    fn test_contract_view() {\n        let dispatcher = deploy_contract();\n        assert('Joe' == dispatcher.get_owner(), 'Joe should be the owner.');\n    }\n\n    fn deploy_contract() -> IJoesContractDispatcher {\n        let contract = declare(\"JoesContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IJoesContractDispatcher { contract_address }\n    }\n}\n\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "Cairo contracts are defined using the `#[starknet::contract]` attribute for the main module and `#[starknet::interface]` for the contract's public interface. Both the interface trait and the contract module must be declared as `pub`.\n\nA contract module must include the `#[storage]` attribute to define its state variables within a `struct Storage`. It is crucial to import all storage-related items using a wildcard import: `use starknet::storage::*;`. Additionally, any other required types from the Starknet core library should be imported with their full paths (e.g., `use starknet::ContractAddress;`).\n\nThe contract's implementation of its interface is typically defined within an `impl` block, for example: `impl IJoesContractImpl of super::IJoesContract<ContractState>`.\n\nExample structure for a contract:\n\n```cairo\nuse starknet::ContractAddress; // Example of a full path import\n\n#[starknet::interface]\npub trait IRegistry<TContractState> {\n    fn register_data(ref self: TContractState, data: felt252);\n    // ... other interface functions\n}\n\n#[starknet::contract]\npub mod Registry {\n    use starknet::ContractAddress;\n    use starknet::storage::*; // Required import for storage\n    use starknet::get_caller_address; // Example of another required library function\n\n    #[storage]\n    pub struct Storage {\n        data_vector: Vec<felt252>,\n        user_data_map: Map<ContractAddress, felt252>,\n        foo: usize,\n    }\n\n    // Events (if any)\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    pub enum Event {\n        DataRegistered: DataRegistered,\n        DataUpdated: DataUpdated,\n    }\n\n    #[derive(Drop, starknet::Event)]\n    pub struct DataRegistered {\n        user: ContractAddress,\n        data: felt252,\n    }\n\n    #[abi(embed_v0)]\n    pub impl RegistryImpl of super::IRegistry<ContractState> {\n        fn register_data(ref self: ContractState, data: felt252) {\n            let caller = get_caller_address();\n            self.data_vector.append().write(data);\n            self.user_data_map.entry(caller).write(data);\n            self.emit(Event::DataRegistered(DataRegistered { user: caller, data }));\n        }\n        // ... other function implementations\n    }\n}\n```\n\nFor testing contracts with `snforge_std`, you typically need to import the contract module itself (e.g., `use registry::Registry;`), the dispatcher traits for interacting with the deployed contract (e.g., `use registry::{IRegistryDispatcher, IRegistryDispatcherTrait};`), and utilities like `declare`, `DeclareResultTrait`, `ContractClassTrait` for deployment.",
      "expected": {
        "answer": "```cairo\n// Starkling, Joe, is writing a really simple contract.\n// The contract shows that he is the owner of the contract.\n// However, his contract is not working. What's he missing?\n\n#[starknet::interface]\ntrait IJoesContract<TContractState> {\n    fn get_owner(self: @TContractState) -> felt252;\n}\n\n#[starknet::contract]\nmod JoesContract {\n    #[storage]\n    struct Storage {}\n\n    #[abi(embed_v0)]\n    impl IJoesContractImpl of super::IJoesContract<ContractState> {\n        fn get_owner(self: @ContractState) -> felt252 {\n            'Joe'\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::JoesContract;\n    use super::IJoesContractDispatcher;\n    use super::IJoesContractDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n\n    #[test]\n    fn test_contract_view() {\n        let dispatcher = deploy_contract();\n        assert('Joe' == dispatcher.get_owner(), 'Joe should be the owner.');\n    }\n\n    fn deploy_contract() -> IJoesContractDispatcher {\n        let contract = declare(\"JoesContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IJoesContractDispatcher { contract_address }\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Joe's contract in the last exercise showed that Joe is the owner of the contract.\n// He thanks you for helping him out!\n// Jill says that contract should allow setting the owner when contract is deployed.\n// Help Jill rewrite the contract with a Storage and a constructor.\n// There is a `ContractAddress` type which should be used for Wallet addresses.\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::contract]\nmod JillsContract {\n    // This is required to use ContractAddress type\n    use starknet::ContractAddress;\n\n    #[storage]\n    struct Storage { // TODO: Add `contract_owner` storage, with ContractAddress type\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, owner: ContractAddress,\n    ) { // TODO: Write `owner` to contract_owner storage\n    }\n\n    #[abi(embed_v0)]\n    impl IJillsContractImpl of super::IJillsContract<ContractState> {\n        fn get_owner(self: @ContractState) -> ContractAddress { // TODO: Read contract_owner storage\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IJillsContract<TContractState> {\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{ContractClassTrait, DeclareResultTrait, declare};\n    use super::{IJillsContractDispatcher, IJillsContractDispatcherTrait, JillsContract};\n\n    #[test]\n    fn test_owner_setting() {\n        let mut calldata = ArrayTrait::new();\n        calldata.append('Jill');\n\n        let contract = declare(\"JillsContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        let dispatcher = IJillsContractDispatcher { contract_address };\n        let owner = dispatcher.get_owner();\n        assert(owner == 'Jill'.try_into().unwrap(), 'Owner should be Jill');\n    }\n}\n\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "Cairo contracts are defined using the `#[starknet::contract]` attribute. Inside a contract module, storage variables are declared within a `#[storage]` struct. For example, a simple storage variable `contract_owner` of type `ContractAddress` would be declared as `contract_owner: ContractAddress,`.\n\nConstructors are defined using the `#[constructor]` attribute. A constructor function takes `ref self: ContractState` and any initial parameters. To initialize a storage variable, you use `self.variable_name.write(value);`. For instance, to set the `contract_owner` during deployment, the constructor would look like:\n\n```cairo\n#[constructor]\nfn constructor(ref self: ContractState, owner: ContractAddress) {\n    self.contract_owner.write(owner);\n}\n```\n\nFunctions that read from storage, like `get_owner`, take `self: @ContractState` (for view functions). To read a simple storage variable, you use `self.variable_name.read()`. For example:\n\n```cairo\nfn get_owner(self: @ContractState) -> ContractAddress {\n    self.contract_owner.read()\n}\n```\n\nThe `ContractAddress` type is used for wallet addresses and requires `use starknet::ContractAddress;` to be imported.\n\nTesting contracts involves using `snforge_std` for declaring and deploying contracts. The `declare` function is used to get a `ContractClass`, which can then be deployed using `contract_class().deploy(@calldata)`. `calldata` is an `Array` of `felt252` values representing constructor arguments. A `Dispatcher` is then created to interact with the deployed contract. For example, to pass an owner address to the constructor and verify it:\n\n```cairo\nuse snforge_std::{ContractClassTrait, DeclareResultTrait, declare};\nuse super::{IJillsContractDispatcher, IJillsContractDispatcherTrait, JillsContract};\nuse starknet::ContractAddress; // Required for ContractAddress type in test\n\n#[test]\nfn test_owner_setting() {\n    let owner_address: ContractAddress = 'Jill'.try_into().unwrap(); // Example of converting a string to ContractAddress\n    let mut calldata = ArrayTrait::new();\n    calldata.append(owner_address.into()); // Append the owner address to calldata\n\n    let contract = declare(\"JillsContract\").unwrap().contract_class();\n    let (contract_address, _) = contract.deploy(@calldata).unwrap();\n    let dispatcher = IJillsContractDispatcher { contract_address };\n    let owner = dispatcher.get_owner();\n    assert(owner == owner_address, 'Owner should be Jill');\n}\n```",
      "expected": {
        "answer": "```cairo\n// Joe's contract in the last exercise showed that Joe is the owner of the contract.\n// He thanks you for helping him out!\n// Jill says that contract should allow setting the owner when contract is deployed.\n// Help Jill rewrite the contract with a Storage and a constructor.\n// There is a `ContractAddress` type which should be used for Wallet addresses.\n\nuse starknet::ContractAddress;\n\n#[starknet::contract]\nmod JillsContract {\n    // This is required to use ContractAddress type\n    use starknet::ContractAddress;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, owner: ContractAddress\n    ) {\n        self.contract_owner.write(owner);\n    }\n\n    #[abi(embed_v0)]\n    impl IJillsContractImpl of super::IJillsContract<ContractState> {\n        fn get_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IJillsContract<TContractState> {\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[cfg(test)]\nmod test {\n    use super::IJillsContractDispatcher;\n    use super::IJillsContractDispatcherTrait;\n    use super::JillsContract;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n\n    #[test]\n    fn test_owner_setting() {\n        let mut calldata = ArrayTrait::new();\n        calldata.append('Jill');\n\n        let contract = declare(\"JillsContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        let dispatcher = IJillsContractDispatcher { contract_address };\n        let owner = dispatcher.get_owner();\n        assert(owner == 'Jill'.try_into().unwrap(), 'Owner should be Jill');\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Joe liked Jill's work very much. He really likes how useful storage can be.\n// Now they decided to write a contract to track the number of exercises they\n// complete successfully. Jill says they can use the owner code and allow\n// only the owner to update the contract, they agree.\n// Can you help them write this contract?\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IProgressTracker<TContractState> {\n    fn set_progress(ref self: TContractState, user: ContractAddress, new_progress: u16);\n    fn get_progress(self: @TContractState, user: ContractAddress) -> u16;\n    fn get_contract_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod ProgressTracker {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address; // Required to use get_caller_address function\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        // TODO: Set types for Map\n        progress: Map<>\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl ProgressTrackerImpl of super::IProgressTracker<ContractState> {\n        fn set_progress(\n            ref self: ContractState, user: ContractAddress, new_progress: u16\n        ) { // TODO: assert owner is calling\n        // TODO: set new_progress for user,\n        }\n\n        fn get_progress(self: @ContractState, user: ContractAddress) -> u16 { // Get user progress\n        }\n\n        fn get_contract_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::IProgressTrackerDispatcher;\n    use super::IProgressTrackerDispatcherTrait;\n    use super::ProgressTracker;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Sensei'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n        assert(owner == dispatcher.get_contract_owner(), 'Mr. Sensei should be the owner');\n    }\n\n    #[test]\n    fn test_set_progress() {\n        let owner = util_felt_addr('Sensei');\n        let dispatcher = deploy_contract();\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Set progress\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n        dispatcher.set_progress('Jill'.try_into().unwrap(), 25);\n\n        let joe_score = dispatcher.get_progress('Joe'.try_into().unwrap());\n        assert(joe_score == 20, 'Joe\\'s progress should be 20');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_progress_fail() {\n        let dispatcher = deploy_contract();\n\n        let jon_doe = util_felt_addr('JonDoe');\n        // Caller not owner\n        start_cheat_caller_address(dispatcher.contract_address, jon_doe);\n\n        // Try to set progress, should panic to pass test!\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> IProgressTrackerDispatcher {\n        let owner: felt252 = 'Sensei';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"ProgressTracker\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        IProgressTrackerDispatcher { contract_address }\n    }\n}\n\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "Cairo contracts can integrate components like `openzeppelin_access::ownable::OwnableComponent` and `openzeppelin_finance::vesting::VestingComponent`. Component integration uses the `component!` macro, defines substorage with `#[substorage(v0)]`, and initializes in the constructor using `initializer` functions.\n\nExample `LinearVestingWallet` demonstrating `OwnableComponent` and `VestingComponent` integration:\n```cairo\n#[starknet::contract]\nmod LinearVestingWallet {\n    use openzeppelin_access::ownable::OwnableComponent;\n    use openzeppelin_finance::vesting::{VestingComponent, LinearVestingSchedule};\n    use starknet::ContractAddress;\n\n    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);\n    component!(path: VestingComponent, storage: vesting, event: VestingEvent);\n\n    #[abi(embed_v0)]\n    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;\n    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;\n\n    #[abi(embed_v0)]\n    impl VestingImpl = VestingComponent::VestingImpl<ContractState>;\n    impl VestingInternalImpl = VestingComponent::InternalImpl<ContractState>;\n\n    #[storage]\n    struct Storage {\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n        #[substorage(v0)]\n        vesting: VestingComponent::Storage\n    }\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        #[flat]\n        OwnableEvent: OwnableComponent::Event,\n        #[flat]\n        VestingEvent: VestingComponent::Event\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState,\n        beneficiary: ContractAddress,\n        start: u64,\n        duration: u64,\n        cliff_duration: u64\n    ) {\n        self.ownable.initializer(beneficiary);\n        self.vesting.initializer(start, duration, cliff_duration);\n    }\n}\n```\n\nFor custom vesting logic, implement the `VestingScheduleTrait` and its `calculate_vested_amount` function. Additional parameters stored in the contract's storage can be accessed using `self.get_contract()`.\n\nExample `StepsVestingWallet` with a custom `VestingSchedule` implementation:\n```cairo\n#[starknet::contract]\nmod StepsVestingWallet {\n    use openzeppelin_access::ownable::OwnableComponent;\n    use openzeppelin_finance::vesting::VestingComponent::VestingScheduleTrait;\n    use openzeppelin_finance::vesting::VestingComponent;\n    use starknet::ContractAddress;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};\n\n    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);\n    component!(path: VestingComponent, storage: vesting, event: VestingEvent);\n\n    #[abi(embed_v0)]\n    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;\n    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;\n\n    #[abi(embed_v0)]\n    impl VestingImpl = VestingComponent::VestingImpl<ContractState>;\n    impl VestingInternalImpl = VestingComponent::InternalImpl<ContractState>;\n\n    #[storage]\n    struct Storage {\n        total_steps: u64,\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n        #[substorage(v0)]\n        vesting: VestingComponent::Storage\n    }\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        #[flat]\n        OwnableEvent: OwnableComponent::Event,\n        #[flat]\n        VestingEvent: VestingComponent::Event\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState,\n        total_steps: u64,\n        beneficiary: ContractAddress,\n        start: u64,\n        duration: u64,\n        cliff: u64,\n    ) {\n        self.total_steps.write(total_steps);\n        self.ownable.initializer(beneficiary);\n        self.vesting.initializer(start, duration, cliff);\n    }\n\n    impl VestingSchedule of VestingScheduleTrait<ContractState> {\n        fn calculate_vested_amount(\n            self: @VestingComponent::ComponentState<ContractState>,\n            token: ContractAddress,\n            total_allocation: u256,\n            timestamp: u64,\n            start: u64,\n            duration: u64,\n            cliff: u64,\n        ) -> u256 {\n            if timestamp < cliff {\n                0\n            } else if timestamp >= start + duration {\n                total_allocation\n            } else {\n                let total_steps = self.get_contract().total_steps.read();\n                let vested_per_step = total_allocation / total_steps.into();\n                let step_duration = duration / total_steps;\n                let current_step = (timestamp - start) / step_duration;\n                let vested_amount = vested_per_step * current_step.into();\n                vested_amount\n            }\n        }\n    }\n}\n```\n\nCairo contracts are defined using `#[starknet::contract]` modules and implement interfaces defined with `#[starknet::interface]`. Imports should use full paths for core library items (e.g., `starknet::ContractAddress`, `starknet::get_caller_address`) and wildcard for storage (`starknet::storage::*`). Storage variables are defined in a `#[storage]` struct, supporting types like `Vec<T>`, `Map<K, V>`, and primitive types. Events are defined within an `enum Event` with `#[event]` and `#[derive(Drop, starknet::Event)]` attributes, and individual event structs also derive `Drop, starknet::Event`. Public functions are implemented within an `#[abi(embed_v0)]` `impl` block.\n\nExample `Registry` contract structure:\n```cairo\nuse starknet::ContractAddress;\n\n#[starknet::interface]\npub trait IRegistry<TContractState> {\n    fn register_data(ref self: TContractState, data: felt252);\n    fn update_data(ref self: TContractState, index: u64, new_data: felt252);\n    fn get_data(self: @TContractState, index: u64) -> felt252;\n    fn get_all_data(self: @TContractState) -> Array<felt252>;\n    fn get_user_data(self: @TContractState, user: ContractAddress) -> felt252;\n}\n\n#[starknet::contract]\npub mod Registry {\n    use starknet::ContractAddress;\n    use starknet::storage::*;\n    use starknet::get_caller_address;\n\n    #[storage]\n    pub struct Storage {\n        data_vector: Vec<felt252>,\n        user_data_map: Map<ContractAddress, felt252>,\n        foo: usize,\n    }\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    pub enum Event {\n        DataRegistered: DataRegistered,\n        DataUpdated: DataUpdated,\n    }\n\n    #[derive(Drop, starknet::Event)]\n    pub struct DataRegistered {\n        user: ContractAddress,\n        data: felt252,\n    }\n\n    #[derive(Drop, starknet::Event)]\n    pub struct DataUpdated {\n        user: ContractAddress,\n        index: u64,\n        new_data: felt252,\n    }\n\n    #[abi(embed_v0)]\n    pub impl RegistryImpl of super::IRegistry<ContractState> {\n        fn register_data(ref self: ContractState, data: felt252) {\n            let caller = get_caller_address();\n            self.data_vector.append().write(data);\n            self.user_data_map.entry(caller).write(data);\n            self.emit(Event::DataRegistered(DataRegistered { user: caller, data }));\n        }\n\n        fn update_data(ref self: ContractState, index: u64, new_data: felt252) {\n            let caller = get_caller_address();\n            self.data_vector.at(index).write(new_data);\n            self.user_data_map.entry(caller).write(new_data);\n            self.emit(Event::DataUpdated(DataUpdated { user: caller, index, new_data }));\n        }\n\n        fn get_data(self: @ContractState, index: u64) -> felt252 {\n            self.data_vector.at(index).read()\n        }\n\n        fn get_all_data(self: @ContractState) -> Array<felt252> {\n            let mut all_data = array![];\n            for i in 0..self.data_vector.len() {\n                all_data.append(self.data_vector.at(i).read());\n            };\n            all_data\n        }\n\n        fn get_user_data(self: @ContractState, user: ContractAddress) -> felt252 {\n            self.user_data_map.entry(user).read()\n        }\n    }\n\n    fn foo(self: @ContractState)->usize{\n        self.foo.read()\n    }\n}\n```\n\nContracts interact using the dispatcher pattern. Define the target contract's interface with `#[starknet::interface]`, then import `IContractDispatcher` and `IContractDispatcherTrait` to create a dispatcher instance with the target contract's address. This provides type safety and handles serialization/deserialization.\n\nTesting in Cairo uses `#[test]` for test functions and `#[should_panic]` for expected failures. The `snforge_std` library provides utilities for declaring and deploying contracts, and cheatcodes for environment manipulation and event spying. Key imports for testing include the contract module, its inner structs, and dispatcher traits (e.g., `IRegistryDispatcher`, `IRegistryDispatcherTrait`). `spy_events()` is used to capture events, and `assert_emitted(@expected_events)` verifies them. `start_cheat_caller_address(contract_address, caller_address)` can set the caller for a transaction, and `stop_cheat_caller_address` resets it.\n\nExample `Registry` test suite:\n```cairo\n// Import the contract module itself\nuse registry::Registry;\n// Make the required inner structs available in scope\nuse registry::Registry::{DataRegistered, DataUpdated};\n\n// Traits derived from the interface, allowing to interact with a deployed contract\nuse registry::{IRegistryDispatcher, IRegistryDispatcherTrait};\n\n// Required for declaring and deploying a contract\nuse snforge_std::{declare, DeclareResultTrait, ContractClassTrait};\n// Cheatcodes to spy on events and assert their emissions\nuse snforge_std::{EventSpyAssertionsTrait, spy_events};\n// Cheatcodes to cheat environment values - more cheatcodes exist\nuse snforge_std::{\n    start_cheat_block_number, start_cheat_block_timestamp, start_cheat_caller_address,\n    stop_cheat_caller_address,\n};\nuse starknet::ContractAddress;\n\n// Helper function to deploy the contract\nfn deploy_contract() -> IRegistryDispatcher {\n    // Deploy the contract -\n    // 1. Declare the contract class\n    // 2. Create constructor arguments - serialize each one in a felt252 array\n    // 3. Deploy the contract\n    // 4. Create a dispatcher to interact with the contract\n    let contract = declare(\"Registry\");\n    let mut constructor_args = array![];\n    Serde::serialize(@1_u8, ref constructor_args);\n    let (contract_address, _err) = contract\n        .unwrap()\n        .contract_class()\n        .deploy(@constructor_args)\n        .unwrap();\n    // Create a dispatcher to interact with the contract\n    IRegistryDispatcher { contract_address }\n}\n\n#[test]\nfn test_register_data() {\n    // Deploy the contract\n    let dispatcher = deploy_contract();\n\n    // Setup event spy\n    let mut spy = spy_events();\n\n    // Set caller address for the transaction\n    let caller: ContractAddress = 123.try_into().unwrap();\n    start_cheat_caller_address(dispatcher.contract_address, caller);\n\n    // Register data\n    dispatcher.register_data(42);\n\n    // Verify the data was stored correctly\n    let stored_data = dispatcher.get_data(0);\n    assert(stored_data == 42, 'Wrong stored data');\n\n    // Verify user-specific data\n    let user_data = dispatcher.get_user_data(caller);\n    assert(user_data == 42, 'Wrong user data');\n\n    // Verify event emission:\n    // 1. Create the expected event\n    let expected_registered_event = Registry::Event::DataRegistered(\n        // Don't forgot to import the event struct!\n        DataRegistered { user: caller, data: 42 },\n    );\n    // 2. Create the expected events array of tuple (address, event)\n    let expected_events = array![(dispatcher.contract_address, expected_registered_event)];\n    // 3. Assert the events were emitted\n    spy.assert_emitted(@expected_events);\n\n    stop_cheat_caller_address(dispatcher.contract_address);\n}\n\n#[test]\nfn test_update_data() {\n    let dispatcher = deploy_contract();\n    let mut spy = spy_events();\n\n    // Set caller address\n    let caller: ContractAddress = 456.try_into().unwrap();\n    start_cheat_caller_address(dispatcher.contract_address, caller);\n\n    // First register some data\n    dispatcher.register_data(42);\n\n    // Update the data\n    dispatcher.update_data(0, 100);\n\n    // Verify the update\n    let updated_data = dispatcher.get_data(0);\n    assert(updated_data == 100, 'Wrong updated data');\n\n    // Verify user data was updated\n    let user_data = dispatcher.get_user_data(caller);\n    assert(user_data == 100, 'Wrong updated user data');\n\n    // Verify update event\n    let expected_updated_event = Registry::Event::DataUpdated(\n        Registry::DataUpdated { user: caller, index: 0, new_data: 100 },\n    );\n    let expected_events = array![(dispatcher.contract_address, expected_updated_event)];\n    spy.assert_emitted(@expected_events);\n\n    stop_cheat_caller_address(dispatcher.contract_address);\n}\n\n#[test]\nfn test_get_all_data() {\n    let dispatcher = deploy_contract();\n\n    // Set caller address\n    let caller: ContractAddress = 789.try_into().unwrap();\n    start_cheat_caller_address(dispatcher.contract_address, caller);\n\n    // Register multiple data entries\n    dispatcher.register_data(10);\n    dispatcher.register_data(20);\n    dispatcher.register_data(30);\n\n    // Get all data\n    let all_data = dispatcher.get_all_data();\n\n    // Verify array contents\n    assert(*all_data.at(0) == 10, 'Wrong data at index 0');\n    assert(*all_data.at(1) == 20, 'Wrong data at index 1');\n    assert(*all_data.at(2) == 30, 'Wrong data at index 2');\n    assert(all_data.len() == 3, 'Wrong array length');\n\n    stop_cheat_caller_address(dispatcher.contract_address);\n}\n\n#[test]\n#[should_panic(expected: \"Index out of bounds\")]\nfn test_get_data_out_of_bounds() {\n    let dispatcher = deploy_contract();\n\n    // Try to access non-existent index\n    dispatcher.get_data(999);\n}\n```",
      "expected": {
        "answer": "```cairo\n// Joe liked Jill's work very much. He really likes how useful storage can be.\n// Now they decided to write a contract to track the number of exercises they\n// complete successfully. Jill says they can use the owner code and allow\n// only the owner to update the contract, they agree.\n// Can you help them write this contract?\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IProgressTracker<TContractState> {\n    fn set_progress(ref self: TContractState, user: ContractAddress, new_progress: u16);\n    fn get_progress(self: @TContractState, user: ContractAddress) -> u16;\n    fn get_contract_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod ProgressTracker {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address; // Required to use get_caller_address function\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map, StorageMapReadAccess, StorageMapWriteAccess};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        progress: Map<ContractAddress, u16>\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl ProgressTrackerImpl of super::IProgressTracker<ContractState> {\n        fn set_progress(\n            ref self: ContractState, user: ContractAddress, new_progress: u16\n        ) {\n            // Assert owner is calling\n            let caller = get_caller_address();\n            let owner = self.contract_owner.read();\n            assert(caller == owner, 'Only owner can set progress');\n\n            // Set new_progress for user\n            self.progress.write(user, new_progress);\n        }\n\n        fn get_progress(self: @ContractState, user: ContractAddress) -> u16 {\n            // Get user progress\n            self.progress.read(user)\n        }\n\n        fn get_contract_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::IProgressTrackerDispatcher;\n    use super::IProgressTrackerDispatcherTrait;\n    use super::ProgressTracker;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Sensei'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n        assert(owner == dispatcher.get_contract_owner(), 'Mr. Sensei should be the owner');\n    }\n\n    #[test]\n    fn test_set_progress() {\n        let owner = util_felt_addr('Sensei');\n        let dispatcher = deploy_contract();\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Set progress\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n        dispatcher.set_progress('Jill'.try_into().unwrap(), 25);\n\n        let joe_score = dispatcher.get_progress('Joe'.try_into().unwrap());\n        assert(joe_score == 20, 'Joe\\'s progress should be 20');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_progress_fail() {\n        let dispatcher = deploy_contract();\n\n        let jon_doe = util_felt_addr('JonDoe');\n        // Caller not owner\n        start_cheat_caller_address(dispatcher.contract_address, jon_doe);\n\n        // Try to set progress, should panic to pass test!\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> IProgressTrackerDispatcher {\n        let owner: felt252 = 'Sensei';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"ProgressTracker\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        IProgressTrackerDispatcher { contract_address }\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Liz, a friend of Jill, wants to manage inventory for her store on-chain.\n// This is a bit challenging for Joe and Jill, Liz prepared an outline\n// for how contract should work, can you help Jill and Joe write it?\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait ILizInventory<TContractState> {\n    fn add_stock(ref self: TContractState, product: felt252, new_stock: u32);\n    fn purchase(ref self: TContractState, product: felt252, quantity: u32);\n    fn get_stock(self: @TContractState, product: felt252) -> u32;\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod LizInventory {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        // TODO: add storage inventory, that maps product (felt252) to stock quantity (u32)\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl LizInventoryImpl of super::ILizInventory<ContractState> {\n        fn add_stock(ref self: ContractState, ) {\n            // TODO:\n            // * takes product and new_stock\n            // * adds new_stock to stock in inventory\n            // * only owner can call this\n        }\n\n        fn purchase(ref self: ContractState, ) {\n            // TODO:\n            // * takes product and quantity\n            // * subtracts quantity from stock in inventory\n            // * anybody can call this\n        }\n\n        fn get_stock(self: @ContractState, ) -> u32 {\n            // TODO:\n            // * takes product\n            // * returns product stock in inventory\n        }\n\n        fn get_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::LizInventory;\n    use super::ILizInventoryDispatcher;\n    use super::ILizInventoryDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Elizabeth'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n\n        // Check that contract owner is set\n        let contract_owner = dispatcher.get_owner();\n        assert(contract_owner == owner, 'Elizabeth should be the owner');\n    }\n\n    #[test]\n    fn test_stock() {\n        let dispatcher = deploy_contract();\n        let owner = util_felt_addr('Elizabeth');\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 10, 'stock should be 10');\n\n        dispatcher.add_stock('Nano', 15);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 25, 'stock should be 25');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    fn test_stock_purchase() {\n        let owner = util_felt_addr('Elizabeth');\n        let dispatcher = deploy_contract();\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 10, 'stock should be 10');\n\n        // Call contract as different address\n        stop_cheat_caller_address(dispatcher.contract_address);\n        start_cheat_caller_address(dispatcher.contract_address, 0.try_into().unwrap());\n\n        dispatcher.purchase('Nano', 2);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 8, 'stock should be 8');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_stock_fail() {\n        let dispatcher = deploy_contract();\n        // Try to add stock, should panic to pass test!\n        dispatcher.add_stock('Nano', 20);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_purchase_out_of_stock() {\n        let dispatcher = deploy_contract();\n        // Purchase out of stock\n        dispatcher.purchase('Nano', 2);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> ILizInventoryDispatcher {\n        let owner: felt252 = 'Elizabeth';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"LizInventory\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        ILizInventoryDispatcher { contract_address }\n    }\n}\n\n```\n\nHint:  \nYou can use Map<felt252, u32> for inventory.\n",
      "chat_history": "",
      "context": "Cairo contracts are defined using `#[starknet::contract]` and implement interfaces defined with `#[starknet::interface]`. Storage variables are declared within a `#[storage]` struct. Mappings can be used for storage, for example, `Map<KeyType, ValueType>`.\n\nTo interact with a `Map` storage variable, you can use `self.map_name.entry(key).read()` to retrieve a value and `self.map_name.entry(key).write(value)` to set a value.\n\nTo get the address of the account that called the current function, use `starknet::get_caller_address()`.\n\nAssertions can be used for checks and error handling. If an `assert` condition is false, the program will panic with the provided message. For example: `assert(condition, 'Error message');`.\n\n**Example of Storage and Map usage:**\n```cairo\nuse starknet::ContractAddress;\nuse starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map};\nuse starknet::get_caller_address;\n\n#[starknet::interface]\npub trait IRegistry<TContractState> {\n    fn register_data(ref self: TContractState, data: felt252);\n    fn get_user_data(self: @TContractState, user: ContractAddress) -> felt252;\n}\n\n#[starknet::contract]\npub mod Registry {\n    use starknet::ContractAddress;\n    use starknet::storage::*; // Wildcard import for storage\n    use starknet::get_caller_address;\n\n    #[storage]\n    pub struct Storage {\n        user_data_map: Map<ContractAddress, felt252>, // A mapping to store user-specific data\n    }\n\n    #[abi(embed_v0)]\n    pub impl RegistryImpl of super::IRegistry<ContractState> {\n        fn register_data(ref self: ContractState, data: felt252) {\n            let caller = get_caller_address();\n            self.user_data_map.entry(caller).write(data);\n        }\n\n        fn get_user_data(self: @ContractState, user: ContractAddress) -> felt252 {\n            self.user_data_map.entry(user).read()\n        }\n    }\n}\n```",
      "expected": {
        "answer": "```cairo\n// Liz, a friend of Jill, wants to manage inventory for her store on-chain.\n// This is a bit challenging for Joe and Jill, Liz prepared an outline\n// for how contract should work, can you help Jill and Joe write it?\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait ILizInventory<TContractState> {\n    fn add_stock(ref self: TContractState, product: felt252, new_stock: u32);\n    fn purchase(ref self: TContractState, product: felt252, quantity: u32);\n    fn get_stock(self: @TContractState, product: felt252) -> u32;\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod LizInventory {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map, StorageMapReadAccess, StorageMapWriteAccess};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        inventory: Map<felt252, u32>,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl LizInventoryImpl of super::ILizInventory<ContractState> {\n        fn add_stock(ref self: ContractState, product: felt252, new_stock: u32) {\n            // Only owner can call this\n            let caller = get_caller_address();\n            let owner = self.contract_owner.read();\n            assert(caller == owner, 'Only owner can add stock');\n\n            // Add new_stock to existing stock in inventory\n            let current_stock = self.inventory.entry(product).read();\n            let updated_stock = current_stock + new_stock;\n            self.inventory.entry(product).write(updated_stock);\n        }\n\n        fn purchase(ref self: ContractState, product: felt252, quantity: u32) {\n            // Anybody can call this\n            // Subtract quantity from stock in inventory\n            let current_stock = self.inventory.entry(product).read();\n            assert(current_stock >= quantity, 'Insufficient stock');\n\n            let updated_stock = current_stock - quantity;\n            self.inventory.entry(product).write(updated_stock);\n        }\n\n        fn get_stock(self: @ContractState, product: felt252) -> u32 {\n            // Returns product stock in inventory\n            self.inventory.entry(product).read()\n        }\n\n        fn get_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::LizInventory;\n    use super::ILizInventoryDispatcher;\n    use super::ILizInventoryDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Elizabeth'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n\n        // Check that contract owner is set\n        let contract_owner = dispatcher.get_owner();\n        assert(contract_owner == owner, 'Elizabeth should be the owner');\n    }\n\n    #[test]\n    fn test_stock() {\n        let dispatcher = deploy_contract();\n        let owner = util_felt_addr('Elizabeth');\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 10, 'stock should be 10');\n\n        dispatcher.add_stock('Nano', 15);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 25, 'stock should be 25');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    fn test_stock_purchase() {\n        let owner = util_felt_addr('Elizabeth');\n        let dispatcher = deploy_contract();\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 10, 'stock should be 10');\n\n        // Call contract as different address\n        stop_cheat_caller_address(dispatcher.contract_address);\n        start_cheat_caller_address(dispatcher.contract_address, 0.try_into().unwrap());\n\n        dispatcher.purchase('Nano', 2);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 8, 'stock should be 8');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_stock_fail() {\n        let dispatcher = deploy_contract();\n        // Try to add stock, should panic to pass test!\n        dispatcher.add_stock('Nano', 20);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_purchase_out_of_stock() {\n        let dispatcher = deploy_contract();\n        // Purchase out of stock\n        dispatcher.purchase('Nano', 2);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> ILizInventoryDispatcher {\n        let owner: felt252 = 'Elizabeth';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"LizInventory\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        ILizInventoryDispatcher { contract_address }\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n\n#[starknet::interface]\ntrait IContractA<TContractState> {\n    fn set_value(ref self: TContractState, value: u128) -> bool;\n    fn get_value(self: @TContractState) -> u128;\n}\n\n\n#[starknet::contract]\nmod ContractA {\n    use starknet::ContractAddress;\n    use super::IContractBDispatcher;\n    use super::IContractBDispatcherTrait;\n\n    #[storage]\n    struct Storage {\n        contract_b: ContractAddress,\n        value: u128,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, contract_b: ContractAddress) {\n        self.contract_b.write(contract_b)\n    }\n\n    #[abi(embed_v0)]\n    impl ContractAImpl of super::IContractA<ContractState> {\n        fn set_value(ref self: ContractState, value: u128) -> bool {\n            // TODO: check if contract_b is enabled.\n            // If it is, set the value and return true. Otherwise, return false.\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IContractB<TContractState> {\n    fn enable(ref self: TContractState);\n    fn disable(ref self: TContractState);\n    fn is_enabled(self: @TContractState) -> bool;\n}\n\n#[starknet::contract]\nmod ContractB {\n    #[storage]\n    struct Storage {\n        enabled: bool\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {}\n\n    #[abi(embed_v0)]\n    impl ContractBImpl of super::IContractB<ContractState> {\n        fn enable(ref self: ContractState) {\n            self.enabled.write(true);\n        }\n\n        fn disable(ref self: ContractState) {\n            self.enabled.write(false);\n        }\n\n        fn is_enabled(self: @ContractState) -> bool {\n            self.enabled.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::ContractAddress;\n    use super::{IContractBDispatcher, IContractADispatcher, IContractADispatcherTrait, IContractBDispatcherTrait};\n\n\n    fn deploy_contract_b() -> IContractBDispatcher {\n        let contract = declare(\"ContractB\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IContractBDispatcher { contract_address }\n    }\n\n    fn deploy_contract_a(contract_b_address: ContractAddress) -> IContractADispatcher {\n        let contract = declare(\"ContractA\").unwrap().contract_class();\n        let constructor_calldata = array![contract_b_address.into()];\n        let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();\n        IContractADispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_interoperability() {\n        // Deploy ContractB\n        let contract_b = deploy_contract_b();\n\n        // Deploy ContractA\n        let contract_a = deploy_contract_a(contract_b.contract_address);\n\n        //TODO interact with contract_b to make the test pass.\n\n        // Tests\n        assert(contract_a.set_value(300) == true, 'Could not set value');\n        assert(contract_a.get_value() == 300, 'Value was not set');\n        assert(contract_b.is_enabled() == true, 'Contract b is not enabled');\n    }\n}\n\n```\n\nHint:  \nYou can call other contracts from inside a contract. To do this, you will need to create a Dispatcher object\nof the type of the called contract. Dispatchers have associated methods available under the `DispatcherTrait`, corresponding to the external functions of the contract that you want to call.\n",
      "chat_history": "",
      "context": "To call another contract from within a Cairo contract, you need to create a Dispatcher object for the target contract's interface. These Dispatchers have methods corresponding to the external functions of the called contract, accessible via their associated `DispatcherTrait`.\n\nFor example, if you have an interface `IContractB` and its corresponding dispatcher `IContractBDispatcher`, you can call its functions like `is_enabled()` after instantiating the dispatcher with the target contract's address.\n\n```cairo\n#[starknet::interface]\ntrait IContractA<TContractState> {\n    fn set_value(ref self: TContractState, value: u128) -> bool;\n    fn get_value(self: @TContractState) -> u128;\n}\n\n#[starknet::contract]\nmod ContractA {\n    use starknet::ContractAddress;\n    use super::IContractBDispatcher;\n    use super::IContractBDispatcherTrait;\n\n    #[storage]\n    struct Storage {\n        contract_b: ContractAddress,\n        value: u128,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, contract_b: ContractAddress) {\n        self.contract_b.write(contract_b)\n    }\n\n    #[abi(embed_v0)]\n    impl ContractAImpl of super::IContractA<ContractState> {\n        fn set_value(ref self: ContractState, value: u128) -> bool {\n            let contract_b_address = self.contract_b.read();\n            let contract_b_dispatcher = IContractBDispatcher { contract_address: contract_b_address };\n            if contract_b_dispatcher.is_enabled() {\n                self.value.write(value);\n                true\n            } else {\n                false\n            }\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IContractB<TContractState> {\n    fn enable(ref self: TContractState);\n    fn disable(ref self: TContractState);\n    fn is_enabled(self: @TContractState) -> bool;\n}\n\n#[starknet::contract]\nmod ContractB {\n    #[storage]\n    struct Storage {\n        enabled: bool\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {}\n\n    #[abi(embed_v0)]\n    impl ContractBImpl of super::IContractB<ContractState> {\n        fn enable(ref self: ContractState) {\n            self.enabled.write(true);\n        }\n\n        fn disable(ref self: ContractState) {\n            self.enabled.write(false);\n        }\n\n        fn is_enabled(self: @ContractState) -> bool {\n            self.enabled.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::ContractAddress;\n    use super::{IContractBDispatcher, IContractADispatcher, IContractADispatcherTrait, IContractBDispatcherTrait};\n\n\n    fn deploy_contract_b() -> IContractBDispatcher {\n        let contract = declare(\"ContractB\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IContractBDispatcher { contract_address }\n    }\n\n    fn deploy_contract_a(contract_b_address: ContractAddress) -> IContractADispatcher {\n        let contract = declare(\"ContractA\").unwrap().contract_class();\n        let constructor_calldata = array![contract_b_address.into()];\n        let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();\n        IContractADispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_interoperability() {\n        // Deploy ContractB\n        let contract_b = deploy_contract_b();\n\n        // Deploy ContractA\n        let contract_a = deploy_contract_a(contract_b.contract_address);\n\n        // Interact with contract_b to make the test pass.\n        contract_b.enable();\n\n        // Tests\n        assert(contract_a.set_value(300) == true, 'Could not set value');\n        assert(contract_a.get_value() == 300, 'Value was not set');\n        assert(contract_b.is_enabled() == true, 'Contract b is not enabled');\n    }\n}\n```",
      "expected": {
        "answer": "```cairo\n// Address all the TODOs to make the tests pass!\n\n\n\n#[starknet::interface]\ntrait IContractA<TContractState> {\n    fn set_value(ref self: TContractState, value: u128) -> bool;\n    fn get_value(self: @TContractState) -> u128;\n}\n\n\n#[starknet::contract]\nmod ContractA {\n    use starknet::ContractAddress;\n    use super::IContractBDispatcher;\n    use super::IContractBDispatcherTrait;\n    use starknet::storage::*;\n\n    #[storage]\n    struct Storage {\n        contract_b: ContractAddress,\n        value: u128,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, contract_b: ContractAddress) {\n        self.contract_b.write(contract_b)\n    }\n\n    #[abi(embed_v0)]\n    impl ContractAImpl of super::IContractA<ContractState> {\n        fn set_value(ref self: ContractState, value: u128) -> bool {\n            // TODO: check if contract_b is enabled.\n            // If it is, set the value and return true. Otherwise, return false.\n            let contract_b = self.contract_b.read();\n            let contract_b_dispatcher = IContractBDispatcher { contract_address: contract_b };\n            if contract_b_dispatcher.is_enabled() {\n                self.value.write(value);\n                return true;\n            }\n            return false;\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IContractB<TContractState> {\n    fn enable(ref self: TContractState);\n    fn disable(ref self: TContractState);\n    fn is_enabled(self: @TContractState) -> bool;\n}\n\n#[starknet::contract]\nmod ContractB {\n    use starknet::storage::*;\n\n    #[storage]\n    struct Storage {\n        enabled: bool\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {}\n\n    #[abi(embed_v0)]\n    impl ContractBImpl of super::IContractB<ContractState> {\n        fn enable(ref self: ContractState) {\n            self.enabled.write(true);\n        }\n\n        fn disable(ref self: ContractState) {\n            self.enabled.write(false);\n        }\n\n        fn is_enabled(self: @ContractState) -> bool {\n            self.enabled.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::ContractAddress;\n    use super::{IContractBDispatcher, IContractADispatcher, IContractADispatcherTrait, IContractBDispatcherTrait};\n\n\n    fn deploy_contract_b() -> IContractBDispatcher {\n        let contract = declare(\"ContractB\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IContractBDispatcher { contract_address }\n    }\n\n    fn deploy_contract_a(contract_b_address: ContractAddress) -> IContractADispatcher {\n        let contract = declare(\"ContractA\").unwrap().contract_class();\n        let constructor_calldata = array![contract_b_address.into()];\n        let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();\n        IContractADispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_interoperability() {\n        // Deploy ContractB\n        let contract_b = deploy_contract_b();\n\n        // Deploy ContractA\n        let contract_a = deploy_contract_a(contract_b.contract_address);\n\n        // Enable contract_b to make the test pass\n        contract_b.enable();\n\n        // Tests\n        assert(contract_a.set_value(300) == true, 'Could not set value');\n        assert(contract_a.get_value() == 300, 'Value was not set');\n        assert(contract_b.is_enabled() == true, 'Contract b is not enabled');\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// This code is using Starknet components to make a reusable owner feature.\n// This should add OwnableComponent containing functionality which any contracts can include.\n// But something is fishy here as this component is not working, can you find the error and make the tests pass?\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IOwnable<TContractState> {\n    fn owner(self: @TContractState) -> ContractAddress;\n    fn set_owner(ref self: TContractState, new_owner: ContractAddress);\n}\n\npub mod OwnableComponent {\n    use starknet::ContractAddress;\n    use super::IOwnable;\n\n    #[storage]\n    pub struct Storage {\n        owner: ContractAddress,\n    }\n\n    #[embeddable_as(Ownable)]\n    impl OwnableImpl<\n        TContractState, +HasComponent<TContractState>\n    > of IOwnable<ComponentState<TContractState>> {\n        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n            self.owner.read()\n        }\n        fn set_owner(ref self: ComponentState<TContractState>, new_owner: ContractAddress) {\n            self.owner.write(new_owner);\n        }\n    }\n}\n\n#[starknet::contract]\npub mod OwnableCounter {\n    use starknet::ContractAddress;\n    use super::OwnableComponent;\n\n    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);\n\n    #[abi(embed_v0)]\n    impl OwnableImpl = OwnableComponent::Ownable<ContractState>;\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        #[flat]\n        OwnableEvent: OwnableComponent::Event,\n    }\n    #[storage]\n    pub struct Storage {\n        counter: u128,\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::IOwnableDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::{contract_address_const, ContractAddress};\n    use super::IOwnableDispatcher;\n\n    fn deploy_ownable_counter() -> IOwnableDispatcher {\n        let contract = declare(\"OwnableCounter\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IOwnableDispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_contract_read() {\n        let dispatcher = deploy_ownable_counter();\n        dispatcher.set_owner(contract_address_const::<0>());\n        assert(contract_address_const::<0>() == dispatcher.owner(), 'Some fuck up happened');\n    }\n}\n\n```\n\nHint: Is there maybe a decorator that annotates that a module is a component? 🤔🤔🤔\n",
      "chat_history": "",
      "context": "To correctly define a Starknet component, the module containing the component's logic and storage must be annotated with the `#[starknet::component]` attribute. This attribute signals to the Starknet compiler that the module is a reusable component, enabling its proper integration into other contracts via the `component!` macro and its storage to be managed as a substorage.\n\nIn the provided code, the `OwnableComponent` module is intended to be a component but lacks this essential attribute. Without `#[starknet::component]`, the contract will not properly recognize or integrate the component's functionality, leading to issues such as the `set_owner` and `owner` functions not behaving as expected, causing tests to fail.\n\nThe fix is to add `#[starknet::component]` directly above the `pub mod OwnableComponent` declaration:\n\n```cairo\n#[starknet::component]\npub mod OwnableComponent {\n    use starknet::ContractAddress;\n    use super::IOwnable;\n\n    #[storage]\n    pub struct Storage {\n        owner: ContractAddress,\n    }\n\n    #[embeddable_as(Ownable)]\n    impl OwnableImpl<\n        TContractState, +HasComponent<TContractState>\n    > of IOwnable<ComponentState<TContractState>> {\n        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n            self.owner.read()\n        }\n        fn set_owner(ref self: ComponentState<TContractState>, new_owner: ContractAddress) {\n            self.owner.write(new_owner);\n        }\n    }\n}\n```\n\nThis ensures that the `OwnableComponent` is correctly registered and its `IOwnable` trait implementation is properly linked when embedded into `OwnableCounter`, allowing the `set_owner` and `owner` functions to operate as intended and the tests to pass.",
      "expected": {
        "answer": "```cairo\n// This code is using Starknet components to make a reusable owner feature.\n// This should add OwnableComponent containing functionality which any contracts can include.\n// But something is fishy here as this component is not working, can you find the error and make the tests pass?\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IOwnable<TContractState> {\n    fn owner(self: @TContractState) -> ContractAddress;\n    fn set_owner(ref self: TContractState, new_owner: ContractAddress);\n}\n\n#[starknet::component]\npub mod OwnableComponent {\n    use starknet::ContractAddress;\n    use starknet::storage::*;\n    use super::IOwnable;\n\n    #[storage]\n    pub struct Storage {\n        owner: ContractAddress,\n    }\n\n    #[embeddable_as(Ownable)]\n    impl OwnableImpl<\n        TContractState, +HasComponent<TContractState>\n    > of IOwnable<ComponentState<TContractState>> {\n        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n            self.owner.read()\n        }\n        fn set_owner(ref self: ComponentState<TContractState>, new_owner: ContractAddress) {\n            self.owner.write(new_owner);\n        }\n    }\n}\n\n#[starknet::contract]\npub mod OwnableCounter {\n    use starknet::ContractAddress;\n    use super::OwnableComponent;\n\n    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);\n\n    #[abi(embed_v0)]\n    impl OwnableImpl = OwnableComponent::Ownable<ContractState>;\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        #[flat]\n        OwnableEvent: OwnableComponent::Event,\n    }\n    #[storage]\n    pub struct Storage {\n        counter: u128,\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::IOwnableDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::{contract_address_const, ContractAddress};\n    use super::IOwnableDispatcher;\n\n    fn deploy_ownable_counter() -> IOwnableDispatcher {\n        let contract = declare(\"OwnableCounter\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IOwnableDispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_contract_read() {\n        let dispatcher = deploy_ownable_counter();\n        dispatcher.set_owner(contract_address_const::<0>());\n        assert(contract_address_const::<0>() == dispatcher.owner(), 'Some fuck up happened');\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n#[derive(Copy, Drop)]\nstruct ColorStruct { // TODO: Something goes here\n// TODO: Your struct needs to have red, green, blue felts\n}\n\n\n#[cfg(test)]\n#[test]\nfn classic_c_structs() {\n    // TODO: Instantiate a classic color struct!\n    // Green color neeeds to have green set to 255 and, red and blue, set to 0\n    // let green =\n\n    assert(green.red == 0, 0);\n    assert(green.green == 255, 0);\n    assert(green.blue == 0, 0);\n}\n\n```\n\nHint: Cairo has a single type of struct that are named collections of related data stored in fields.\nIn this exercise you need to complete and implement a struct.\nHere is how we describe a person struct that stores a name and an age,\n\n#[derive(Copy, Drop)]\nstruct Person {\n    name: felt252,\n    age: felt252,\n}\n\nYou'd use the struct like so,\n\nlet john = Person { name: 'John', age: 29 };\n\n\nRead more about structs in the Structs section of this article: https://book.cairo-lang.org/ch05-01-defining-and-instantiating-structs.html ",
      "chat_history": "",
      "context": "Cairo structs are named collections of related data stored in fields, declared using the `struct` keyword. Fields within a struct are defined with a name and a type (e.g., `field_name: Type`). Structs commonly use `#[derive(Copy, Drop)]` for functionalities like copying and dropping.\n\nExample struct definition:\n```cairo\n#[derive(Copy, Drop)]\nstruct Person {\n    name: felt252,\n    age: felt252,\n}\n```\n\nStructs are instantiated by providing values for each field using the `StructName { field1: value1, field2: value2, ... }` syntax.\n\nExample struct instantiation:\n```cairo\nlet john = Person { name: 'John', age: 29 };\n```\n\n`felt252` is a common type used for struct fields.",
      "expected": {
        "answer": "```cairo\n// Address all the TODOs to make the tests pass!\n\n#[derive(Copy, Drop)]\nstruct ColorStruct {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\n\n#[cfg(test)]\n#[test]\nfn classic_c_structs() {\n    // TODO: Instantiate a classic color struct!\n    // Green color neeeds to have green set to 255 and, red and blue, set to 0\n    let green = ColorStruct { red: 0, green: 255, blue: 0 };\n\n    assert(green.red == 0, 0);\n    assert(green.green == 255, 0);\n    assert(green.blue == 0, 0);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Order {\n    name: felt252,\n    year: felt252,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: felt252,\n    count: felt252,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: 'Bob',\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0\n    }\n}\n#[cfg(test)]\n#[test]\nfn test_your_order() {\n    let order_template = create_order_template();\n    // TODO: Destructure your order into multiple variables to make the assertions pass!\n    // let ...\n\n    assert(name == 'Bob', 'Wrong name');\n    assert(year == order_template.year, 'Wrong year');\n    assert(made_by_phone == order_template.made_by_phone, 'Wrong phone');\n    assert(made_by_mobile == order_template.made_by_mobile, 'Wrong mobile');\n    assert(made_by_email == order_template.made_by_email, 'Wrong email');\n    assert(item_number == order_template.item_number, 'Wrong item number');\n    assert(count == 0, 'Wrong count');\n}\n\n```\n\nHint: Cairo requires you to initialize all fields when creating a struct and there is no update syntax available at the moment.\nYou can have multiple data types in a struct, and even other structs.\n\nThere are some shortcuts that can be taken when destructuring structs,\n```\nlet Foo {x, y} = foo; // Creates variables x and y with values foo.x and foo.y\nlet Foo {x: a, y: b} = foo; // Creates variables a and b with values foo.x and foo.y\n```\nRead more about structs in the Structs section of this article: https://book.cairo-lang.org/ch05-01-defining-and-instantiating-structs.html ",
      "chat_history": "",
      "context": "Structs in Cairo are custom data types that allow you to group related values. They are declared using the `struct` keyword. Fields within a struct must be initialized when creating an instance, as there is no update syntax available. Structs can contain multiple data types, including other structs.\n\nExample of struct definition and instantiation:\n```cairo\n#[derive(Copy, Drop)]\nstruct Order {\n    name: felt252,\n    year: felt252,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: felt252,\n    count: felt252,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: 'Bob',\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0\n    }\n}\n```\n\nStructs can be destructured into multiple variables using a shortcut syntax. This allows you to extract the values of the struct's fields into local variables with the same names as the fields, or assign them to new variable names.\n\nDestructuring shortcuts:\n- `let Foo {x, y} = foo;` // Creates variables `x` and `y` with values `foo.x` and `foo.y`.\n- `let Foo {x: a, y: b} = foo;` // Creates variables `a` and `b` with values `foo.x` and `foo.y`.\n\nTesting in Cairo is done using the `#[test]` attribute. Test functions should not have parameters or return values. The `assert!` macro can be used within tests to verify conditions; if an assertion fails, the test will panic with the provided message.",
      "expected": {
        "answer": "```cairo\n// Address all the TODOs to make the tests pass!\n\n#[derive(Copy, Drop)]\nstruct Order {\n    name: felt252,\n    year: felt252,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: felt252,\n    count: felt252,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: 'Bob',\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0\n    }\n}\n#[cfg(test)]\n#[test]\nfn test_your_order() {\n    let order_template = create_order_template();\n    // TODO: Destructure your order into multiple variables to make the assertions pass!\n    let Order { name, year, made_by_phone, made_by_mobile, made_by_email, item_number, count } = order_template;\n\n    assert(name == 'Bob', 'Wrong name');\n    assert(year == order_template.year, 'Wrong year');\n    assert(made_by_phone == order_template.made_by_phone, 'Wrong phone');\n    assert(made_by_mobile == order_template.made_by_mobile, 'Wrong mobile');\n    assert(made_by_email == order_template.made_by_email, 'Wrong email');\n    assert(item_number == order_template.item_number, 'Wrong item number');\n    assert(count == 0, 'Wrong count');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Package {\n    sender_country: felt252,\n    recipient_country: felt252,\n    weight_in_grams: usize,\n}\n\ntrait PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package;\n    fn is_international(ref self: Package) -> //???;\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> //???;\n}\nimpl PackageImpl of PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package {\n        if weight_in_grams <= 0{\n            let mut data = ArrayTrait::new();\n            data.append('x');\n            panic(data);\n        }\n        Package { sender_country, recipient_country, weight_in_grams,  }\n    }\n\n    fn is_international(ref self: Package) -> //???\n    {\n    /// Something goes here...\n    }\n\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> //???\n    {\n    /// Something goes here...\n    }\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn fail_creating_weightless_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Austria';\n    PackageTrait::new(sender_country, recipient_country, 0);\n}\n\n#[cfg(test)]\n#[test]\nfn create_international_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Russia';\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == true, 'Not international');\n}\n\n#[cfg(test)]\n#[test]\nfn create_local_package() {\n    let sender_country = 'Canada';\n    let recipient_country = sender_country;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == false, 'International');\n}\n\n#[cfg(test)]\n#[test]\nfn calculate_transport_fees() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Spain';\n\n    let cents_per_gram = 3;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1500);\n\n    assert(package.get_fees(cents_per_gram) == 4500, 'Wrong fees');\n}\n\n```\n\nHint: For is_international: What makes a package international? Seems related to the places it goes through right?\n\nFor get_fees: This method takes an additional argument, is there a field in the Package struct that this relates to?\n\nLooking at the test functions will also help you understand more about the syntax.\nThis section will help you understanding more about methods https://book.cairo-lang.org/ch05-03-method-syntax.html\n",
      "chat_history": "",
      "context": "The `Package` struct is defined with fields `sender_country: felt252`, `recipient_country: felt252`, and `weight_in_grams: usize`. It derives `Copy` and `Drop`.\n\nThe `PackageTrait` defines three functions:\n- `new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package`: A constructor.\n- `is_international(ref self: Package) -> bool`: Checks if the package is international.\n- `get_fees(ref self: Package, cents_per_gram: usize) -> usize`: Calculates the transport fees.\n\nThe `PackageImpl` implements `PackageTrait`:\n- `new`: Initializes a `Package` struct. It panics if `weight_in_grams` is less than or equal to 0.\n- `is_international`: Returns `true` if `sender_country` is not equal to `recipient_country`, indicating an international package. Otherwise, it returns `false`.\n- `get_fees`: Calculates fees by multiplying `self.weight_in_grams` by `cents_per_gram`.\n\nExample tests demonstrate the expected behavior:\n- `fail_creating_weightless_package`: Tests that `new` panics when `weight_in_grams` is 0.\n- `create_international_package`: Asserts `is_international()` returns `true` for different sender/recipient countries.\n- `create_local_package`: Asserts `is_international()` returns `false` for the same sender/recipient countries.\n- `calculate_transport_fees`: Asserts `get_fees()` returns the correct calculated value (e.g., `1500 * 3 = 4500`).",
      "expected": {
        "answer": "```cairo\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n\n#[derive(Copy, Drop)]\nstruct Package {\n    sender_country: felt252,\n    recipient_country: felt252,\n    weight_in_grams: usize,\n}\n\ntrait PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package;\n    fn is_international(ref self: Package) -> bool;\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> usize;\n}\nimpl PackageImpl of PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package {\n        if weight_in_grams <= 0{\n            let mut data = ArrayTrait::new();\n            data.append('x');\n            panic(data);\n        }\n        Package { sender_country, recipient_country, weight_in_grams,  }\n    }\n\n    fn is_international(ref self: Package) -> bool {\n        self.sender_country != self.recipient_country\n    }\n\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> usize {\n        self.weight_in_grams * cents_per_gram\n    }\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn fail_creating_weightless_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Austria';\n    PackageTrait::new(sender_country, recipient_country, 0);\n}\n\n#[cfg(test)]\n#[test]\nfn create_international_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Russia';\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == true, 'Not international');\n}\n\n#[cfg(test)]\n#[test]\nfn create_local_package() {\n    let sender_country = 'Canada';\n    let recipient_country = sender_country;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == false, 'International');\n}\n\n#[cfg(test)]\n#[test]\nfn calculate_transport_fees() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Spain';\n\n    let cents_per_gram = 3;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1500);\n\n    assert(package.get_fees(cents_per_gram) == 4500, 'Wrong fees');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Time to implement some traits!\n\n// Your task is to implement the trait\n// `AnimalTrait` for the type `Animal`\n//\n\n// Fill in the impl block to make the code work.\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Animal {\n    noise: felt252\n}\n\ntrait AnimalTrait {\n    fn new(noise: felt252) -> Animal;\n    fn make_noise(self: Animal) -> felt252;\n}\n\nimpl AnimalImpl of AnimalTrait { // TODO: implement the trait AnimalTrait for Animal\n}\n\n#[cfg(test)]\n#[test]\nfn test_traits1() {\n    // TODO make the test pass by creating two instances of Animal\n    // and calling make_noise on them\n\n    assert(cat.make_noise() == 'meow', 'Wrong noise');\n    assert(cow.make_noise() == 'moo', 'Wrong noise');\n}\n\n```\n\nHint:  \nIf you want to implement a trait for a type, you have to implement all the methods in the trait.\nBased on the signature of the method, you can easily implement it.\n\nIn the test, you need to instantiate two objects of type `Animal`.\nYou can call the method of a trait by using the MyTrait::foo() syntax.\nHow would you instantiate the two objects with AnimalTrait?\nMaybe you need to specify the type of the object?\nhttps://book.cairo-lang.org/ch08-02-traits-in-cairo.html\n",
      "chat_history": "",
      "context": "In Cairo, a trait defines a set of methods that a type can implement, allowing for shared behavior. You declare a trait using the `trait` keyword, followed by its name, and list method signatures within curly brackets, ending with a semicolon.\n\nTo implement a trait for a type, use the `impl` keyword, followed by a name for the implementation (e.g., `AnimalImpl`), then the `of` keyword, and the trait name (e.g., `AnimalTrait`). Within the `impl` block, you must provide the method bodies for all signatures defined in the trait.\n\n**Example of Trait Implementation:**\n```cairo\nmod aggregator {\n    pub trait Summary<T> {\n        fn summarize(self: @T) -> ByteArray;\n    }\n\n    #[derive(Drop)]\n    pub struct NewsArticle {\n        pub headline: ByteArray,\n        pub location: ByteArray,\n        pub author: ByteArray,\n        pub content: ByteArray,\n    }\n\n    impl NewsArticleSummary of Summary<NewsArticle> {\n        fn summarize(self: @NewsArticle) -> ByteArray {\n            format!(\"{} by {} ({})\", self.headline, self.author, self.location)\n        }\n    }\n}\n```\n\nMethods within an `impl` block can be associated functions (like static methods, not taking `self`) or instance methods (taking `self` by value, snapshot `@self`, or mutable reference `ref self`).\n\nTo instantiate a struct, you can use its name followed by curly braces containing field initializers (e.g., `Animal { noise: value }`).\n\nTrait methods can be called directly on an instance (e.g., `instance.method()`) if the trait is implemented for the type. Associated functions defined in a trait can be called using the `TraitName::function_name()` syntax (e.g., `AnimalTrait::new('meow')`).\n\nThe `felt252` type represents a field element, commonly used for string literals (e.g., `'meow'`).\n\nThe `#[derive(Copy, Drop)]` attribute automatically generates implementations for the `Copy` and `Drop` traits for a struct, allowing values of that struct to be duplicated (copied) and handled when they go out of scope. `Copy` allows for duplication of values, while `Drop` handles their destruction.",
      "expected": {
        "answer": "```cairo\n// Time to implement some traits!\n\n// Your task is to implement the trait\n// `AnimalTrait` for the type `Animal`\n//\n\n// Fill in the impl block to make the code work.\n\n\n\n#[derive(Copy, Drop)]\nstruct Animal {\n    noise: felt252\n}\n\ntrait AnimalTrait {\n    fn new(noise: felt252) -> Animal;\n    fn make_noise(self: Animal) -> felt252;\n}\n\nimpl AnimalImpl of AnimalTrait { // TODO: implement the trait AnimalTrait for Animal\n    fn new(noise: felt252) -> Animal {\n        Animal { noise }\n    }\n\n    fn make_noise(self: Animal) -> felt252 {\n        self.noise\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_traits1() {\n    // TODO make the test pass by creating two instances of Animal\n    // and calling make_noise on them\n    let cat = AnimalTrait::new('meow');\n    let cow = AnimalTrait::new('moo');\n\n    assert(cat.make_noise() == 'meow', 'Wrong noise');\n    assert(cow.make_noise() == 'moo', 'Wrong noise');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n// The previous exercise did not make the distinction\n// between different types of animals, but this one does.\n// The trait `AnimalTrait` has two functions:\n// `new` and `make_noise`.\n// `new` should return a new instance of the type\n// implementing the trait.\n// `make_noise` should return the noise the animal makes.\n// The types `Cat` and `Cow` are already defined for you.\n// You need to implement the trait `AnimalTrait` for them.\n\n// No hints for this one!\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Cat {\n    noise: felt252,\n}\n\n#[derive(Copy, Drop)]\nstruct Cow {\n    noise: felt252,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n}\n\nimpl CatImpl of AnimalTrait<Cat> { // TODO: implement the trait Animal for the type Cat\n}\n\n// TODO: implement the trait Animal for the type Cow\n\n#[cfg(test)]\n#[test]\nfn test_traits2() {\n    let kitty: Cat = AnimalTrait::new();\n    assert(kitty.make_noise() == 'meow', 'Wrong noise');\n\n    let cow: Cow = AnimalTrait::new();\n    assert(cow.make_noise() == 'moo', 'Wrong noise');\n}\n\n```\n\nHint:  No hints for this one! It is very similar to the previous exercise.",
      "chat_history": "",
      "context": "The provided context does not contain specific information or examples for implementing custom traits for user-defined structs in Cairo. It primarily details various core library traits (e.g., `Destruct`, `AddEq`, `Extend`, `fmt`) and provides extensive test code for a `Registry` contract, which is not relevant to the task of implementing the `AnimalTrait` for `Cat` and `Cow` structs. Therefore, the implementation will rely on general Cairo syntax for trait implementation.",
      "expected": {
        "answer": "```cairo\n\n// The previous exercise did not make the distinction\n// between different types of animals, but this one does.\n// The trait `AnimalTrait` has two functions:\n// `new` and `make_noise`.\n// `new` should return a new instance of the type\n// implementing the trait.\n// `make_noise` should return the noise the animal makes.\n// The types `Cat` and `Cow` are already defined for you.\n// You need to implement the trait `AnimalTrait` for them.\n\n// No hints for this one!\n\n\n\n#[derive(Copy, Drop)]\nstruct Cat {\n    noise: felt252,\n}\n\n#[derive(Copy, Drop)]\nstruct Cow {\n    noise: felt252,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n}\n\nimpl CatImpl of AnimalTrait<Cat> {\n    fn new() -> Cat {\n        Cat { noise: 'meow' }\n    }\n\n    fn make_noise(self: Cat) -> felt252 {\n        self.noise\n    }\n}\n\nimpl CowImpl of AnimalTrait<Cow> {\n    fn new() -> Cow {\n        Cow { noise: 'moo' }\n    }\n\n    fn make_noise(self: Cow) -> felt252 {\n        self.noise\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_traits2() {\n    let kitty: Cat = AnimalTrait::new();\n    assert(kitty.make_noise() == 'meow', 'Wrong noise');\n\n    let cow: Cow = AnimalTrait::new();\n    assert(cow.make_noise() == 'moo', 'Wrong noise');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n//\n// The previous exercise showed how to implement a trait for multiple types.\n// This exercise shows how you can implement multiple traits for a single type.\n// This is useful when you have types that share some common functionality, but\n// also have some unique functionality.\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Fish {\n    noise: felt252,\n    distance: u32,\n}\n\n#[derive(Copy, Drop)]\nstruct Dog {\n    noise: felt252,\n    distance: u32,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n    fn get_distance(self: T) -> u32;\n}\n\ntrait FishTrait {\n    fn swim(ref self: Fish) -> ();\n}\n\ntrait DogTrait {\n    fn walk(ref self: Dog) -> ();\n}\n\nimpl AnimalFishImpl of AnimalTrait<Fish> {\n    fn new() -> Fish {\n        Fish { noise: 'blub', distance: 0 }\n    }\n    fn make_noise(self: Fish) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Fish) -> u32 {\n        self.distance\n    }\n}\n\nimpl AnimalDogImpl of AnimalTrait<Dog> {\n    fn new() -> Dog {\n        Dog { noise: 'woof', distance: 0 }\n    }\n    fn make_noise(self: Dog) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Dog) -> u32 {\n        self.distance\n    }\n}\n\n// TODO: implement FishTrait for the type Fish\n\n// TODO: implement DogTrait for the type Dog\n\n#[cfg(test)]\n#[test]\nfn test_traits3() {\n    // Don't modify this test!\n    let mut salmon: Fish = AnimalTrait::new();\n    salmon.swim();\n    assert(salmon.make_noise() == 'blub', 'Wrong noise');\n    assert(salmon.get_distance() == 1, 'Wrong distance');\n\n    let mut dog: Dog = AnimalTrait::new();\n    dog.walk();\n    assert(dog.make_noise() == 'woof', 'Wrong noise');\n    assert(dog.get_distance() == 1, 'Wrong distance');\n}\n\n```\n\nHint:  \nYou can implement multiple traits for a type.\nWhen a trait is destined to be implemented by a single type, you don't need to use generics.\nIf you're having trouble updating the distance value in the `Fish` and `Dog` impls, remember that you need to first\n1. Destructure the object into mutable variables\n2. Update the distance variable\n3. Reconstruct `self` with the updated variables (`self = MyStruct { ... }`) \n",
      "chat_history": "",
      "context": "In Cairo, traits define shared behavior that types can implement. A trait is implemented for a specific type using the `impl TraitNameImpl of TraitName for Type { ... }` syntax.\n\nWhen a function takes `self` by mutable reference (`ref self: Type`), you can modify the instance. The common pattern for updating fields of a struct passed by `ref self` is:\n1.  **Destructure** the object into mutable variables: `let MyStruct { field1, field2 } = self;`\n2.  **Update** the desired variable(s): `let new_field1_value = field1 + 1;`\n3.  **Reconstruct** `self` with the updated variables: `self = MyStruct { field1: new_field1_value, field2 };`\n\nExample of trait implementation:\n```cairo\nstruct Potion {\n    health: u64,\n    mana: u64,\n}\n\n// The `Add` trait is used to specify the functionality of `+`.\nimpl PotionAdd of Add<Potion> {\n    fn add(lhs: Potion, rhs: Potion) -> Potion {\n        Potion { health: lhs.health + rhs.health, mana: lhs.mana + rhs.mana }\n    }\n}\n```",
      "expected": {
        "answer": "```cairo\n//\n// The previous exercise showed how to implement a trait for multiple types.\n// This exercise shows how you can implement multiple traits for a single type.\n// This is useful when you have types that share some common functionality, but\n// also have some unique functionality.\n\n\n\n#[derive(Copy, Drop)]\nstruct Fish {\n    noise: felt252,\n    distance: u32,\n}\n\n#[derive(Copy, Drop)]\nstruct Dog {\n    noise: felt252,\n    distance: u32,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n    fn get_distance(self: T) -> u32;\n}\n\ntrait FishTrait {\n    fn swim(ref self: Fish) -> ();\n}\n\ntrait DogTrait {\n    fn walk(ref self: Dog) -> ();\n}\n\nimpl AnimalFishImpl of AnimalTrait<Fish> {\n    fn new() -> Fish {\n        Fish { noise: 'blub', distance: 0 }\n    }\n    fn make_noise(self: Fish) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Fish) -> u32 {\n        self.distance\n    }\n}\n\nimpl AnimalDogImpl of AnimalTrait<Dog> {\n    fn new() -> Dog {\n        Dog { noise: 'woof', distance: 0 }\n    }\n    fn make_noise(self: Dog) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Dog) -> u32 {\n        self.distance\n    }\n}\n\nimpl FishTraitImpl of FishTrait {\n    fn swim(ref self: Fish) {\n        self.distance += 1;\n    }\n}\n\nimpl DogTraitImpl of DogTrait {\n    fn walk(ref self: Dog) {\n        self.distance += 1;\n    }\n}\n\n#[test]\nfn test_traits3() {\n    // Don't modify this test!\n    let mut salmon: Fish = AnimalTrait::new();\n    salmon.swim();\n    assert(salmon.make_noise() == 'blub', 'Wrong noise');\n    assert(salmon.get_distance() == 1, 'Wrong distance');\n\n    let mut dog: Dog = AnimalTrait::new();\n    dog.walk();\n    assert(dog.make_noise() == 'woof', 'Wrong noise');\n    assert(dog.get_distance() == 1, 'Wrong distance');\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile!\n\n// I AM NOT DONE\n\nfn main() {\n    x = 5 ;\n    println!(\" x is {}\", x)\n}\n\n```\n\nHint: The declaration on line 8 is missing a keyword that is needed in Cairo\nto create a new variable binding.",
      "chat_history": "",
      "context": "No relevant information found in the provided context.",
      "expected": {
        "answer": "```cairo\n// Make me compile!\n\n\n\nfn main() {\n    let x = 5;\n    println!(\" x is {}\", x)\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n\nfn main() {\n    let x;\n    if x == 10 {\n       println!(\"x is ten! \");\n    } else {\n        println!(\"x is not ten! \");\n    }\n}\n\n```\n\nHint: What happens if you annotate line 7 with a type annotation?\nWhat if you give x a value?\nWhat if you do both?\nWhat type should x be, anyway? (remember what the basic type in Cairo is?)\nWhat if x is the same type as 10? What if it's a different type? (e.g. a u8)",
      "chat_history": "",
      "context": "In Cairo, variables are declared using the `let` keyword. A variable must either be initialized at the time of declaration or explicitly annotated with a type. An uninitialized variable without a type annotation (e.g., `let x;`) will result in a compilation error. If a variable is initialized, Cairo can often infer its type. For example, `let x = 10;` will infer `x` to be of type `u32`.\n\nThe `u32` type is a common unsigned 32-bit integer type in Cairo. Integer literals like `10` are typically inferred as `u32` by default. When performing comparisons (e.g., using `==`), the operands must have compatible types.\n\nConditional logic is implemented using `if` and `else` statements. The syntax is `if condition { /* code */ } else { /* code */ }`.\n\nTo print values to the console using the `println!` macro, you must import the `PrintTrait` from the `debug` module: `use debug::PrintTrait;`. This trait provides the necessary functionality for types to be printed.\n\nExample of variable declaration and printing:\n```cairo\nuse debug::PrintTrait;\n\nfn main() {\n    // Valid declarations:\n    let a: u32 = 5; // Explicit type and initialization\n    let b = 10;     // Type inferred as u32\n    let c: u8 = 20; // Explicit type, different from default literal type\n\n    if a == 5 {\n        println!(\"a is five!\");\n    } else {\n        println!(\"a is not five!\");\n    }\n\n    println!(\"Value of b: {}\", b);\n}\n```",
      "expected": {
        "answer": "```cairo\n\n\n\nfn main() {\n    let x = 10;\n    if x == 10 {\n       println!(\"x is ten! \");\n    } else {\n        println!(\"x is not ten! \");\n    }\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n\nfn main() {\n    let x: felt252;\n    println!(\"x is {}\", x);\n}\n\n```\n\nHint: Oops! In this exercise, we have a variable binding that we've created on\nline 7, and we're trying to use it on line 8, but we haven't given it a\nvalue. We can't print out something that isn't there; try giving x a value!\nThis is an error that can cause bugs that's very easy to make in any\nprogramming language -- thankfully the Cairo compiler has caught this for us!",
      "chat_history": "",
      "context": "No relevant information found.",
      "expected": {
        "answer": "```cairo\n\n\n\nfn main() {\n    let x: felt252 = 0;\n    println!(\"x is {}\", x);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n\nfn main() {\n    let x = 3;\n    println!(\"x is {}\", x);\n    x = 5; // don't change this line\n    println!(\"x is now {}\", x);\n}\n\n```\n\nHint: In Cairo, variable bindings are immutable by default. But here we're trying\nto reassign a different value to x! There's a keyword we can use to make\na variable binding mutable instead.",
      "chat_history": "",
      "context": "In Cairo, variable bindings are immutable by default. This means that once a value is bound to a variable, it cannot be changed. To allow a variable's value to be reassigned, you must declare it as mutable using the `mut` keyword after `let` in the variable declaration.\n\nExample of declaring a mutable variable:\n```cairo\nfn main() {\n    let mut x = 5;\n    x = 6; // This is allowed because x is mutable\n}\n```",
      "expected": {
        "answer": "```cairo\n\n\nfn main() {\n    let mut x = 3;\n    println!(\"x is {}\", x);\n    x = 5; // don't change this line\n    println!(\"x is now {}\", x);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n\nfn main() {\n    let number = 1_u8; // don't change this line\n    println!(\"number is {}\", number);\n    number = 3; // don't rename this variable\n    println!(\"number is {}\", number);\n}\n\n```\n\nHint: In variables4 we already learned how to make an immutable variable mutable\nusing a special keyword. Unfortunately this doesn't help us much in this exercise\nbecause we want to assign a different typed value to an existing variable. Sometimes\nyou may also like to reuse existing variable names because you are just converting\nvalues to different types like in this exercise.\nFortunately Cairo has a powerful solution to this problem: 'Shadowing'!\nYou can see an example of variables and 'shadowing' here: https://book.cairo-lang.org/ch02-01-variables-and-mutability.html?highlight=shadow#shadowing\nYou can read about the different integer types here: https://book.cairo-lang.org/ch02-02-data-types.html#integer-types\nTry to solve this exercise afterwards using this technique.",
      "chat_history": "",
      "context": "Enums define a custom data type with a fixed set of named values called variants. Variants can be instantiated using `Enum::Variant` syntax and can have associated values.\n\n```cairo\n#[derive(Drop)]\nenum Direction {\n    North,\n    East,\n    South,\n    West,\n}\n\n#[derive(Drop)]\nenum Direction {\n    North: u128,\n    East: u128,\n    South: u128,\n    West: u128,\n}\n\n#[derive(Drop)]\nenum Message {\n    Quit,\n    Echo: felt252,\n    Move: (u128, u128),\n}\n```\n\nThe `Option` enum is a standard Cairo enum with two variants: `Some: T` (value present) and `None` (absence of value).\n\n```cairo\nenum Option<T> {\n    Some: T,\n    None,\n}\n\nfn find_value_recursive(mut arr: Span<felt252>, value: felt252, index: usize) -> Option<usize> {\n    match arr.pop_front() {\n        Some(index_value) => { if (*index_value == value) {\n            return Some(index);\n        } },\n        None => { return None; },\n    };\n\n    find_value_recursive(arr, value, index + 1)\n}\n\nfn find_value_iterative(mut arr: Span<felt252>, value: felt252) -> Option<usize> {\n    let mut result = None;\n    let mut index = 0;\n\n    while let Some(array_value) = arr.pop_front() {\n        if (*array_value == value) {\n            result = Some(index);\n            break;\n        };\n\n        index += 1;\n    };\n\n    result\n}\n```\n\nTo store elements of different types in an array, an enum can be used to define a custom data type.\n\n```cairo\n#[derive(Copy, Drop)]\nenum Data {\n    Integer: u128,\n    Felt: felt252,\n    Tuple: (u32, u32),\n}\n\nfn main() {\n    let mut messages: Array<Data> = array![];\n    messages.append(Data::Integer(100));\n    messages.append(Data::Felt('hello world'));\n    messages.append(Data::Tuple((10, 30)));\n}\n```\n\n`Span` is a struct representing a read-only snapshot of an `Array`, created using `array.span()`. It provides safe access without modifying the original array.\n\nCairo facilitates type conversion using the `into` and `try_into` methods from the `Into` and `TryInto` traits.\n\nThe `Into` trait is for guaranteed conversions (e.g., smaller to larger types). Call `var.into()` on the source value, explicitly defining the new variable's type.\n\n```cairo\nfn main() {\n    let my_u8: u8 = 10;\n    let my_u16: u16 = my_u8.into();\n    let my_u32: u32 = my_u16.into();\n    let my_u64: u64 = my_u32.into();\n    let my_u128: u128 = my_u64.into();\n\n    let my_felt252 = 10;\n    let my_u256: u256 = my_felt252.into();\n    let my_other_felt252: felt252 = my_u8.into();\n    let my_third_felt252: felt252 = my_u16.into();\n}\n```\n\nThe `TryInto` trait is for fallible conversions (e.g., larger to smaller types), returning an `Option<T>`. Conversion is done by calling `var.try_into().unwrap()`, which can panic if the value does not fit.\n\n```cairo\nfn main() {\n    let my_u256: u256 = 10;\n\n    let my_felt252: felt252 = my_u256.try_into().unwrap();\n    let my_u128: u128 = my_felt252.try_into().unwrap();\n    let my_u64: u64 = my_u128.try_into().unwrap();\n    let my_u32: u32 = my_u64.try_into().unwrap();\n    let my_u16: u16 = my_u32.try_into().unwrap();\n    let my_u8: u8 = my_u16.try_into().unwrap();\n\n    let my_large_u16: u16 = 2048;\n    let my_large_u8: u8 = my_large_u16.try_into().unwrap(); // panics with 'Option::unwrap failed.'\n}\n```",
      "expected": {
        "answer": "```cairo\n\n\nfn main() {\n    let mut number = 1_u8;\n    println!(\"number is {}\", number);\n    number = 3; // don't rename this variable\n    println!(\"number is {}\", number);\n}\n\n```"
      }
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n\n\n// I AM NOT DONE\n\nconst NUMBER = 3;\nconst SMALL_NUMBER = 3_u8;\nfn main() {\n    println!(\"NUMBER is {}\", NUMBER);\n    println!(\"SMALL_NUMBER is {}\", SMALL_NUMBER);\n}\n\n```\n\nHint: We know about variables and mutability, but there is another important type of\nvariable available: constants.\nConstants are always immutable and they are declared with keyword 'const' rather\nthan keyword 'let'.\nConstants types must also always be annotated.\nYou can read about the constants here: https://book.cairo-lang.org/ch02-01-variables-and-mutability.html?highlight=const#constants\n",
      "chat_history": "",
      "context": "Constants in Cairo are always immutable and are declared using the `const` keyword instead of `let`. Their types must always be explicitly annotated. For example: `const NUMBER: u32 = 3;` or `const SMALL_NUMBER: u8 = 3_u8;`.\n\nThe `core::fmt` module provides functionality for formatting values, which is used by macros like `println!` for outputting information.",
      "expected": {
        "answer": "```cairo\n\n\nconst NUMBER: felt252 = 3;\nconst SMALL_NUMBER: u8 = 3_u8;\nfn main() {\n    println!(\"NUMBER is {}\", NUMBER);\n    println!(\"SMALL_NUMBER is {}\", SMALL_NUMBER);\n}\n\n```"
      }
    }
  ]
}
