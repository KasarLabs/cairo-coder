{
  "query_processor.retrieval_program.predict": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "query": "Refactor this contract to add access control on public functions",
        "search_queries": [
          "Access control library for Cairo smart contracts",
          "Asserting the caller of a contract entrypoint",
          "Component for access control",
          "Writing Starknet Smart Contracts"
        ],
        "resources": [
          "openzeppelin_docs",
          "cairo_book"
        ],
        "chat_history": ""
      },
      {
        "query": "Implement an ERC20 token with mint and burn mechanism",
        "search_queries": [
          "Creating ERC20 tokens with Openzeppelin",
          "Adding mint and burn entrypoints to ERC20",
          "Writing Starknet Smart Contracts",
          "Integrating Openzeppelin library in Cairo project"
        ],
        "resources": [
          "openzeppelin_docs",
          "cairo_book"
        ],
        "chat_history": ""
      }
    ],
    "signature": {
      "instructions": "You are an AI assistant specialized in Starknet smart contract development using the Cairo programming language. Your task is to meticulously analyze a given user query from a chat history, which will be a technical, task-oriented request for smart contract development, refactoring, or understanding. Based on this query, you must generate a detailed reasoning process, a list of highly relevant search queries, and identify authoritative documentation sources.\n\n**Input:** A `Chat History` containing a `Query` from a user.\n\n**Output Structure:**\nYour output must be structured with three distinct fields: `Reasoning`, `Search Queries`, and `Resources`.\n\n1.  **Reasoning**: Provide a comprehensive, step-by-step thought process explaining how you arrived at the chosen search queries and resources. This section should always begin with the exact phrase \"Let's think step by step in order to\". Clearly articulate the user's core intent, identify key technical concepts and libraries (e.g., OpenZeppelin Cairo Contracts), and justify why specific search terms or documentation sources are most appropriate for addressing the query.\n2.  **Search Queries**: Generate a list of precise and targeted search queries that an AI development assistant could use to find solutions, code examples, or relevant information for the user's request. These queries should be optimized for finding information related to Cairo, Starknet, and standard smart contract libraries like OpenZeppelin, focusing on practical implementation details.\n3.  **Resources**: Identify the most authoritative and relevant documentation sources from the following predefined list. You must use only these exact keywords:\n    *   `cairo_book`: For fundamental Cairo language syntax, features, core concepts, and general Starknet smart contract development principles.\n    *   `starknet_docs`: For Starknet protocol, architecture, APIs, syscalls, network interaction, deployment, ecosystem tools (Starkli, indexers), general Starknet knowledge. This should not be included for Coding and Programming questions, but rather, only for questions about Starknet itself.\n    *   `starknet_foundry`: For using the Foundry toolchain: writing, compiling, testing (unit tests, integration tests), and debugging Starknet contracts.\n    *   `cairo_by_example`: For practical Cairo code snippets for specific language features or common patterns. Useful for how-to syntax questions. This should not be included for Smart Contract questions, but for all other Cairo programming questions.\n    *   `openzeppelin_docs`: For standard smart contract implementations, patterns, and best practices (e.g., ERC20, Ownable, AccessControl) within the Cairo ecosystem.\n    *   `corelib_docs`: For using the Cairo core library: basic types, stdlib functions, stdlib structs, macros, and other core concepts. Essential for Cairo programming questions.\n    *   `scarb_docs`: For using the Scarb package manager: building, compiling, generating compilation artifacts, managing dependencies, configuration of Scarb.toml.\n\n**Constraints & Guidelines:**\n*   Your analysis should be geared towards providing information that directly assists with code generation, refactoring, or in-depth understanding of specific smart contract functionalities on Starknet.\n*   Ensure the generated search queries are highly specific and actionable within the context of the Starknet and Cairo development environment.\n*   The `Resources` list should only contain the exact keywords provided above, based on their direct relevance and authoritative nature to the query.\n*   **Crucially, your output must not contain any code snippets; only the analysis and the specified lists.**",
      "fields": [
        {
          "prefix": "Chat History:",
          "description": "Previous conversation context for better understanding of the query. May be empty."
        },
        {
          "prefix": "Query:",
          "description": "User's Cairo\/Starknet programming question or request that needs to be processed"
        },
        {
          "prefix": "Reasoning: Let's think step by step in order to",
          "description": "${reasoning}"
        },
        {
          "prefix": "Search Queries:",
          "description": "A list of __3__ specific semantic search queries to make to a vector store to find relevant documentation."
        },
        {
          "prefix": "Resources:",
          "description": "List of documentation sources. Available sources: cairo_book: The Cairo Programming Language Book. Essential for core language syntax, semantics, types (felt252, structs, enums, Vec), traits, generics, control flow, memory management, writing tests, organizing a project, standard library usage, starknet interactions. Crucial for smart contract structure, storage, events, ABI, syscalls, contract deployment, interaction, L1<>L2 messaging, Starknet-specific attributes., starknet_docs: The Starknet Documentation. For Starknet protocol, architecture, APIs, syscalls, network interaction, deployment, ecosystem tools (Starkli, indexers), general Starknet knowledge. This should not be included for Coding and Programming questions, but rather, only for questions about Starknet itself., starknet_foundry: The Starknet Foundry Documentation. For using the Foundry toolchain: writing, compiling, testing (unit tests, integration tests), and debugging Starknet contracts., cairo_by_example: Cairo by Example Documentation. Provides practical Cairo code snippets for specific language features or common patterns. Useful for how-to syntax questions. This should not be included for Smart Contract questions, but for all other Cairo programming questions., openzeppelin_docs: OpenZeppelin Cairo Contracts Documentation. For using the OZ library: standard implementations (ERC20, ERC721), access control, security patterns, contract upgradeability. Crucial for building standard-compliant contracts., corelib_docs: Cairo Core Library Documentation. For using the Cairo core library: basic types, stdlib functions, stdlib structs, macros, and other core concepts. Essential for Cairo programming questions., scarb_docs: Scarb Documentation. For using the Scarb package manager: building, compiling, generating compilation artifacts, managing dependencies, configuration of Scarb.toml."
        }
      ]
    },
    "lm": null
  },
  "document_retriever.vector_db": {
    "k": 5
  },
  "retrieval_judge.rater": {
    "traces": [],
    "train": [],
    "demos": [],
    "signature": {
      "instructions": "Compare a system's retrieval response to the query and rate how much it can be leveraged to answer the query. When asked to reason, enumerate key ideas in each response, and whether they are present in the expected output. A document is considered useful if it is directly relevant to the query, or if it is informative and can be useful for context. For example, if the query is about creating or fixing a smart contract, then, an example of a smart contract, even if not _directly_ related, is considered useful. If the query is about a specific Cairo language feature, then a document about that feature is considered useful. Contract and test templates are always considered useful.",
      "fields": [
        {
          "prefix": "Query:",
          "description": "User's specific Cairo programming question or request for code generation"
        },
        {
          "prefix": "System Resource:",
          "description": "Single resource text (content + minimal metadata/title)"
        },
        {
          "prefix": "Reasoning:",
          "description": "A short sentence, on why a selected resource will be useful. If it's not selected, reason about why it's not going to be useful. Start by Resource <resource_title>..."
        },
        {
          "prefix": "Resource Note",
          "description": "A note between 0 and 1.0 on how useful the resource is to directly answer the query. 0 being completely unrelated, 1.0 being very relevant, 0.5 being 'not directly relatd but still informative and can be useful for context."
        }
      ]
    },
    "lm": null
  },
  "generation_program.generation_program.predict": {
    "traces": [],
    "train": [],
    "demos": [
      {
        "augmented": true,
        "query": "Complete the following Cairo code:\n\n```cairo\n\/\/ Make me compile without changing the indicated lines\n\n\/\/ I AM NOT DONE\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut _arr1 = fill_arr(arr0);\n\n    \/\/ Do not change the following line!\n    print_arr(arr0);\n}\n\nfn print_arr(arr: Array<felt252>) {\n    println!(\"arr: {:?}\", arr);\n}\n\n\/\/ Do not change the following line!\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\n\nHint: So, `arr0` is passed into the `fill_arr` function as an argument. In Cairo,\nwhen an argument is passed to a function and it's not explicitly returned,\nyou can't use the original variable anymore. We call this \"moving\" a variable.\nVariables that are moved into a function (or block scope) and aren't explicitly\nreturned get \"dropped\" at the end of that function. This is also what happens here.\nThere's a few ways to fix this, try them all if you want:\n1. Make another, separate version of the data that's in `arr0` and pass that\n   to `fill_arr` instead.\n2. Make `fill_arr` *mutably* borrow a reference to its argument (which will need to be\n   mutable) with the `ref` keyword , modify it directly, then not return anything. Then you can get rid\n   of `arr1` entirely -- note that this will change what gets printed by the\n   first `print`\n3. Make `fill_arr` borrow an immutable view of its argument instead of taking ownership by using the snapshot operator `@`,\n   and then copy the data within the function in order to return an owned\n   `Array<felt>`. This requires an explicit clone of the array and should generally be avoided in Cairo, as the memory is write-once and cloning can be expensive. To clone an object, you will need to import the trait `clone::Clone` and the implementation of the Clone trait for the array located in `array::ArrayTCloneImpl`",
        "context": "In Cairo, variables can be made mutable by prepending `mut`.",
        "chat_history": "",
        "reasoning": "The problem asks to modify the provided Cairo code to make it compile, specifically by changing an existing line to introduce mutability, rather than adding new lines.\n\nThe error in the original code arises in the `fill_arr` function:\n```cairo\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    arr.append(22); \/\/ Error: `arr` is immutable\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\nThe `append` method for `Array` (or similar collection types like `ByteArray` as shown in the context examples) typically requires a mutable reference to `self`. For instance, `ByteArrayTrait::append` is defined as `fn append(ref self: ByteArray, other: ByteArray)`.\n\nIn Cairo, function parameters are immutable by default. To allow modifications to a parameter within the function, it must be declared as `mut`. The hint explicitly guides towards adding `mut` to an existing binding.\n\nTherefore, the solution is to change the `arr` parameter in the `fill_arr` function signature from an immutable binding to a mutable one.\n\nOriginal: `fn fill_arr(arr: Array<felt252>) -> Array<felt252>`\nChange to: `fn fill_arr(mut arr: Array<felt252>) -> Array<felt252>`\n\nThis single change makes the `arr` variable mutable within the `fill_arr` function, allowing `arr.append()` calls to succeed.",
        "answer": "```cairo\n\/\/ Make me compile without adding new lines-- just changing existing lines!\n\/\/ (no lines with multiple semicolons necessary!)\n\n\/\/ I AM NOT DONE\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(mut arr: Array<felt252>) -> Array<felt252> {\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```"
      },
      {
        "augmented": true,
        "query": "Complete the following Cairo code:\n\n```cairo\n\/\/ I AM NOT DONE\n\n#[derive(Drop)]\nstruct Student {\n    name: felt252,\n    courses: Array<Option<felt252>>,\n}\n\n\nfn display_grades(student: @Student) {\n    let mut msg = ArrayTrait::new();\n    msg.append(*student.name);\n    msg.append('\\'s grades:');\n    println!(\"{:?}\", msg);\n\n    for course in student.courses.span() {\n        \/\/ TODO: Modify the following lines so that if there is a grade for the course, it is printed.\n        \/\/       Otherwise, print \"No grade\".\n        \/\/\n        println!(\"grade is {}\", course.unwrap());\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_all_defined() {\n    let courses = array![\n        Option::Some('A'),\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::Some('A'),\n    ];\n    let mut student = Student { name: 'Alice', courses: courses };\n    display_grades(@student);\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_some_empty() {\n    let courses = array![\n        Option::Some('A'),\n        Option::None,\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::None,\n    ];\n    let mut student = Student { name: 'Bob', courses: courses };\n    display_grades(@student);\n}\n```\n\nHint: Reminder: You can use a match statement with an Option to handle both the Some and None cases.\nThis syntax is more flexible than using unwrap, which only handles the Some case, and contributes to more robust code.\n",
        "context": "To iterate over an `Array<Option<felt252>>`, you can use the `span` method to get a `Span<Option<felt252>>`. Each element in the span is of type `@Option<felt252>` (a snapshot reference). To use a `match` statement on the `Option` itself, we need to dereference the `course` snapshot using `*course`. This will give us the `Option<felt252>` value.",
        "chat_history": "",
        "reasoning": "The user wants to complete a Cairo code snippet. The core task is to iterate through an `Array<Option<felt252>>` and print the grade if it exists (`Option::Some`) or \"No grade\" if it doesn't (`Option::None`).\n\nThe provided hint explicitly suggests using a `match` statement, which is the idiomatic way to handle `Option` types in Cairo (and Rust). The `unwrap()` method, which was in the `TODO` section, is unsafe as it would panic if the `Option` is `None`.\n\nHere's the step-by-step approach:\n1.  **Understand the `for` loop:** The loop `for course in student.courses.span()` iterates over a `Span<Option<felt252>>`. Each `course` inside the loop is of type `@Option<felt252>` (a snapshot reference).\n2.  **Dereference the `Option`:** To use a `match` statement on the `Option` itself, we need to dereference the `course` snapshot using `*course`. This will give us the `Option<felt252>` value.\n3.  **Implement the `match` statement:**\n    *   For the `Option::Some(grade)` case, we will print the `grade` using `println!(\"grade is {}\", grade);`.\n    *   For the `Option::None` case, we will print \"No grade\" using `println!(\"No grade\");`.\n4.  **Ensure necessary imports:** The existing code already uses `Array`, `Option`, `felt252`, `ArrayTrait`, `println!`, and `Drop`. These are standard Cairo types and macros, and typically do not require explicit `use core::...` imports unless specified by a linter or specific project setup. The provided context does not indicate any special imports are needed for these basic types.\n\nThe `Student` struct and the test cases are already well-defined and will help verify the correctness of the `display_grades` function.",
        "answer": "```cairo\n\/\/ I AM NOT DONE\n\n#[derive(Drop)]\nstruct Student {\n    name: felt252,\n    courses: Array<Option<felt252>>,\n}\n\n\nfn display_grades(student: @Student) {\n    let mut msg = ArrayTrait::new();\n    msg.append(*student.name);\n    msg.append('\\'s grades:');\n    println!(\"{:?}\", msg);\n\n    for course_option in student.courses.span() {\n        \/\/ TODO: Modify the following lines so that if there is a grade for the course, it is printed.\n        \/\/       Otherwise, print \"No grade\".\n        \/\/\n        match *course_option {\n            Option::Some(grade) => {\n                println!(\"grade is {}\", grade);\n            },\n            Option::None => {\n                println!(\"No grade\");\n            }\n        }\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_all_defined() {\n    let courses = array![\n        Option::Some('A'),\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::Some('A'),\n    ];\n    let mut student = Student { name: 'Alice', courses: courses };\n    display_grades(@student);\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_some_empty() {\n    let courses = array![\n        Option::Some('A'),\n        Option::None,\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::None,\n    ];\n    let mut student = Student { name: 'Bob', courses: courses };\n    display_grades(@student);\n}\n```"
      },
      {
        "query": "Complete the following Cairo code:\n\n```cairo\n\/\/ Address all the TODOs to make the tests pass!\n\n\/\/ I AM NOT DONE\n\n#[starknet::interface]\ntrait IContractA<TContractState> {\n    fn set_value(ref self: TContractState, value: u128) -> bool;\n    fn get_value(self: @TContractState) -> u128;\n}\n\n\n#[starknet::contract]\nmod ContractA {\n    use starknet::ContractAddress;\n    use super::IContractBDispatcher;\n    use super::IContractBDispatcherTrait;\n\n    #[storage]\n    struct Storage {\n        contract_b: ContractAddress,\n        value: u128,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, contract_b: ContractAddress) {\n        self.contract_b.write(contract_b)\n    }\n\n    #[abi(embed_v0)]\n    impl ContractAImpl of super::IContractA<ContractState> {\n        fn set_value(ref self: ContractState, value: u128) -> bool {\n            \/\/ TODO: check if contract_b is enabled.\n            \/\/ If it is, set the value and return true. Otherwise, return false.\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IContractB<TContractState> {\n    fn enable(ref self: TContractState);\n    fn disable(ref self: TContractState);\n    fn is_enabled(self: @TContractState) -> bool;\n}\n\n#[starknet::contract]\nmod ContractB {\n    #[storage]\n    struct Storage {\n        enabled: bool\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {}\n\n    #[abi(embed_v0)]\n    impl ContractBImpl of super::IContractB<ContractState> {\n        fn enable(ref self: ContractState) {\n            self.enabled.write(true);\n        }\n\n        fn disable(ref self: ContractState) {\n            self.enabled.write(false);\n        }\n\n        fn is_enabled(self: @ContractState) -> bool {\n            self.enabled.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::ContractAddress;\n    use super::{IContractBDispatcher, IContractADispatcher, IContractADispatcherTrait, IContractBDispatcherTrait};\n\n\n    fn deploy_contract_b() -> IContractBDispatcher {\n        let contract = declare(\"ContractB\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IContractBDispatcher { contract_address }\n    }\n\n    fn deploy_contract_a(contract_b_address: ContractAddress) -> IContractADispatcher {\n        let contract = declare(\"ContractA\").unwrap().contract_class();\n        let constructor_calldata = array![contract_b_address.into()];\n        let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();\n        IContractADispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_interoperability() {\n        \/\/ Deploy ContractB\n        let contract_b = deploy_contract_b();\n\n        \/\/ Deploy ContractA\n        let contract_a = deploy_contract_a(contract_b.contract_address);\n\n        \/\/TODO interact with contract_b to make the test pass.\n\n        \/\/ Tests\n        assert(contract_a.set_value(300) == true, 'Could not set value');\n        assert(contract_a.get_value() == 300, 'Value was not set');\n        assert(contract_b.is_enabled() == true, 'Contract b is not enabled');\n    }\n}\n```\n\nHint: \nYou can call other contracts from inside a contract. To do this, you will need to create a Dispatcher object\nof the type of the called contract. Dispatchers have associated methods available under the `DispatcherTrait`, corresponding to the external functions of the contract that you want to call.\n",
        "chat_history": "",
        "expected": "\/\/ Address all the TODOs to make the tests pass!\n\n\n\n#[starknet::interface]\ntrait IContractA<TContractState> {\n    fn set_value(ref self: TContractState, value: u128) -> bool;\n    fn get_value(self: @TContractState) -> u128;\n}\n\n\n#[starknet::contract]\nmod ContractA {\n    use starknet::ContractAddress;\n    use super::IContractBDispatcher;\n    use super::IContractBDispatcherTrait;\n    use starknet::storage::*;\n\n    #[storage]\n    struct Storage {\n        contract_b: ContractAddress,\n        value: u128,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, contract_b: ContractAddress) {\n        self.contract_b.write(contract_b)\n    }\n\n    #[abi(embed_v0)]\n    impl ContractAImpl of super::IContractA<ContractState> {\n        fn set_value(ref self: ContractState, value: u128) -> bool {\n            \/\/ TODO: check if contract_b is enabled.\n            \/\/ If it is, set the value and return true. Otherwise, return false.\n            let contract_b = self.contract_b.read();\n            let contract_b_dispatcher = IContractBDispatcher { contract_address: contract_b };\n            if contract_b_dispatcher.is_enabled() {\n                self.value.write(value);\n                return true;\n            }\n            return false;\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IContractB<TContractState> {\n    fn enable(ref self: TContractState);\n    fn disable(ref self: TContractState);\n    fn is_enabled(self: @TContractState) -> bool;\n}\n\n#[starknet::contract]\nmod ContractB {\n    use starknet::storage::*;\n\n    #[storage]\n    struct Storage {\n        enabled: bool\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {}\n\n    #[abi(embed_v0)]\n    impl ContractBImpl of super::IContractB<ContractState> {\n        fn enable(ref self: ContractState) {\n            self.enabled.write(true);\n        }\n\n        fn disable(ref self: ContractState) {\n            self.enabled.write(false);\n        }\n\n        fn is_enabled(self: @ContractState) -> bool {\n            self.enabled.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::ContractAddress;\n    use super::{IContractBDispatcher, IContractADispatcher, IContractADispatcherTrait, IContractBDispatcherTrait};\n\n\n    fn deploy_contract_b() -> IContractBDispatcher {\n        let contract = declare(\"ContractB\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IContractBDispatcher { contract_address }\n    }\n\n    fn deploy_contract_a(contract_b_address: ContractAddress) -> IContractADispatcher {\n        let contract = declare(\"ContractA\").unwrap().contract_class();\n        let constructor_calldata = array![contract_b_address.into()];\n        let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();\n        IContractADispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_interoperability() {\n        \/\/ Deploy ContractB\n        let contract_b = deploy_contract_b();\n\n        \/\/ Deploy ContractA\n        let contract_a = deploy_contract_a(contract_b.contract_address);\n\n        \/\/ Enable contract_b to make the test pass\n        contract_b.enable();\n\n        \/\/ Tests\n        assert(contract_a.set_value(300) == true, 'Could not set value');\n        assert(contract_a.get_value() == 300, 'Value was not set');\n        assert(contract_b.is_enabled() == true, 'Contract b is not enabled');\n    }\n}"
      }
    ],
    "signature": {
      "instructions": "You are an expert Cairo programmer and educator specializing in Starknet smart contract development. Your primary task is to complete provided Cairo code snippets, specifically addressing all `\/\/ TODO:` sections, ensuring the modified code passes all associated tests.\n\nFor each query, you will receive:\n- `Query`: The Cairo code containing `\/\/ TODO:` markers.\n- `Hint`: A suggestion or specific guidance for the problem.\n- `Context`: Relevant documentation snippets that may aid in solving the problem.\n\nYour response must include:\n1.  **Reasoning**: A detailed, step-by-step thought process explaining how you arrived at the solution.\n    *   Analyze the user's `Query` to understand the problem and identify all `\/\/ TODO:` sections.\n    *   Break down the problem into smaller, manageable parts.\n    *   Leverage the `Hint` and `Context` (relevant documentation) to inform your solution. Explicitly reference concepts, syntax, or examples found in the `Context` that are applicable.\n    *   Explain *why* specific Cairo language constructs, patterns, or best practices are chosen (e.g., struct definition, struct instantiation, tuple\/struct destructuring, specific import paths).\n    *   Describe how each part of your proposed code addresses a specific `\/\/ TODO:` or test requirement.\n    *   Ensure your reasoning demonstrates a deep understanding of Cairo's ownership, mutability, and core language constructs as highlighted in the dataset description.\n2.  **Answer**: The complete, corrected Cairo code.\n    *   The code must be clean, idiomatic, and follow Cairo\/Starknet best practices.\n    *   It must compile successfully and be production-ready.\n    *   All `\/\/ TODO:` comments must be resolved and **removed**.\n    *   The `\/\/ I AM NOT DONE` marker must be **removed**.\n    *   Include *all necessary imports explicitly*. For `starknet::storage`, always use `use starknet::storage::*`. Do not include common `core` library imports (like `panic`, `println`) unless they are explicitly missing or required by the context.\n    *   If the task involves contract testing, adhere to the `important_rules` provided in the `test_template` context (full paths for core library imports, interface definition, and dispatcher import).\n\nYour overall goal is to provide a comprehensive and pedagogical solution, guiding the user through the fundamental Cairo concepts involved.",
      "fields": [
        {
          "prefix": "Chat History:",
          "description": "Previous conversation context for continuity and better understanding"
        },
        {
          "prefix": "Query:",
          "description": "User's specific Cairo programming question or request for code generation"
        },
        {
          "prefix": "Context:",
          "description": "Retrieved Cairo documentation, examples, and relevant information to inform the response. Use the context to inform the response - maximize using context's content."
        },
        {
          "prefix": "Reasoning: Let me analyze the Cairo requirements step by step.",
          "description": "Step-by-step analysis of the Cairo programming task and solution approach"
        },
        {
          "prefix": "Answer:",
          "description": "Complete Cairo code solution with explanations, following Cairo syntax and best practices. Include code examples, explanations, and step-by-step guidance."
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.12",
      "dspy": "2.6.27",
      "cloudpickle": "3.1"
    }
  }
}
