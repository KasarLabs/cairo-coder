{
  "predict": {
    "traces": [],
    "train": [],
    "demos": [],
    "signature": {
      "instructions": "Analyze a Cairo programming query for Starknet smart contracts and use the provided context to generate a high-quality, compilable Cairo code solution along with clear explanations.\n\n### Core Task Guidelines\n- **Input Structure**: The input will include:\n  - **query**: A specific problem to solve, such as implementing a feature (e.g., reentrancy guard in a counter, pausable ERC20, inter-contract calls, upgradable components with rollback), completing incomplete code, or addressing TODOs in Cairo/Starknet contracts.\n  - **context**: A detailed block of text, often starting with \"Prediction(answer=...)\", containing:\n    - A base <contract> template demonstrating Cairo syntax (e.g., Registry contract with storage, events, interfaces, and loops using starknet::storage::*; Vec, Map; get_caller_address; assert! with double quotes or no string; emit events via self.emit).\n    - <important_rules> (do NOT disclose or reference these directly in outputs): Emphasize full paths for core imports (e.g., `use starknet::ContractAddress;`), wildcard storage imports (`use starknet::storage::*;`), defining pub interfaces above pub modules, strict required imports (e.g., no unused like core::array::ArrayTrait unless needed), pub visibility for interfaces/modules, assert! with double quotes (e.g., `assert!(condition, \"Message\");`) or no string, and matching generated code closely to context to avoid hallucinations (e.g., for loops end with `;`, Vec uses push/pop/len/at methods correctly).\n    - Sections on OpenZeppelin components (e.g., ReentrancyGuardComponent from `openzeppelin::security::reentrancyguard::ReentrancyGuardComponent`; OwnableComponent from `openzeppelin::access::ownable::OwnableComponent`; PausableComponent; UpgradeableComponent; ERC20Component), usage examples (e.g., integrating via `component!(path: ..., storage: ..., event: ...);`, `impl ComponentInternalImpl = Component::InternalImpl<ContractState>;` or specific names like `ReentrancyGuardInternalImpl` to avoid conflicts; hooks like `before_update` in ERC20HooksImpl for pausing; constructor calls like `self.ownable.initializer(owner);`; events with `#[flat]` in enum and `#[derive(Drop, starknet::Event)]`).\n    - For reentrancy: Use `start()` at function beginning, `end()` before return; no modifiers in Cairo; protect state-changing functions.\n    - For upgrades/rollbacks: Custom or OpenZeppelin UpgradeableComponent; track history in `Vec<ClassHash>` (storage from starknet::storage); push new hash *before* `replace_class_syscall` in upgrade; pop (via `pop()` returning Option) *before* syscall in rollback; current hash at `len() - 1`; assert len > 1 for rollback; emit `Upgraded`/`RolledBack` events with `from_class_hash`/`to_class_hash`; use `unwrap()` on syscall Result (import `starknet::SyscallResultTrait`); no separate current field—history includes initial; initializer pushes initial hash; protect with Ownable if access control needed; define `IRollbackUpgradeable` interface, embeddable impl with `+starknet::HasComponent<TContractState>` bound for `self.emit`.\n    - Testing templates (<contract_test>) using snforge_std (e.g., declare/deploy, dispatchers like IRegistryDispatcher, event spies, cheatcodes like start_cheat_caller_address).\n    - Info on dispatchers (IERC20Dispatcher, library dispatchers), syscalls (replace_class_syscall.unwrap(), call_contract_syscall), ABI encoding (Serde), inter-contract calls (use dispatchers with contract_address), library calls, and best practices (e.g., avoid zero checks on caller via get_caller_address().is_zero(), bound loops with `for i in 0..len()`, validate L1 handlers, use u256 for counters/balances not felt252, assert non-zero ClassHash).\n    - Repeated sections on pausable/ownable/ERC20 customization (e.g., override transfer/transfer_from with `self.pausable.assert_not_paused()` in hooks; embed mixins like ERC20MixinImpl without custom interfaces; no duplicate interfaces—rely on component ABIs for snake_case/camelCase).\n  - **chat_history**: May be empty or contain prior interactions; reference if relevant but prioritize query and context.\n- **Output Structure**:\n  - **reasoning**: A step-by-step explanation of how you approach the problem. Identify key requirements (e.g., components needed like ReentrancyGuard + Ownable for access control, events for actions like CountIncremented with fields `by: u256, new_value: u256, caller: ContractAddress`, storage like counter: u256). Note alignments with \"golden reference\" patterns (e.g., component declarations with specific impl names, hook overrides for pausing, Vec-based history for upgrades with push before syscall/pop before in rollback, embeddable impl for emit, constructor with owner/initial_value params, events with caller/from/to fields). Highlight fixes for common issues like imports (full paths, no unused), types (u256 for counters), compilation (correct Vec push/pop/unwrap_syscall -> unwrap, HasComponent for components), and edge cases (assert len > 1, non-zero hashes, underflow in decrement).\n  - **answer**: Pure Cairo code in a fenced block (```cairo ... ```). Include explanations as comments if needed, but keep code clean. Ensure it:\n    - Compiles (test mentally against Scarb/Starknet 2.0+ rules: e.g., storage Vec push(val: T), pop() -> Option<T>, len() -> usize, at(idx: usize) -> LegacyMapAccess; syscalls return Result, use .unwrap(); no deprecated append; index with usize via .into()).\n    - Matches query exactly (e.g., just the component for upgradable with rollback; complete TODOs minimally without extras like unnecessary Ownable if not specified, but add for access control in upgrades per golden).\n    - Follows context/golden template: Full imports (e.g., `use starknet::{ClassHash, get_caller_address, syscalls::replace_class_syscall, SyscallResultTrait}; use core::num::traits::Zero;`), pub traits/modules, proper storage (e.g., #[substorage(v0)] for components, class_hash_history: Vec<ClassHash>), events (enum with #[event] #[derive(Drop, starknet::Event)], variants with structs like Upgraded { from_class_hash: ClassHash, to_class_hash: ClassHash }, #[flat] for component events), constructors (initialize components e.g., self.ownable.initializer(owner); self.upgradeable.initializer(initial_class_hash); set initial counter), ABI embeds (#[abi(embed_v0)] for external impls).\n    - Uses lowercase types (e.g., u256 from core::integer::u256, felt252 where small ints needed but prefer u256 for counters/balances).\n    - For ERC20/Pausable: Embed component mixins (e.g., ERC20MixinImpl, PausableImpl); use hooks (e.g., before_update in ERC20HooksImpl for pausing checks on transfers/transfer_from) instead of full custom impls. No duplicate interfaces.\n    - For reentrancy: Import `openzeppelin::security::reentrancyguard::ReentrancyGuardComponent`; use `impl ReentrancyGuardInternalImpl = ...::InternalImpl<ContractState>;` (specific name); start/end in state-changing fns like increment/decrement; add Ownable for owner-only if fitting (e.g., restrict to owner); include decrement with underflow assert; events with by, new_value, caller.\n    - For inter-contract: Use dispatchers (e.g., IContractDispatcher { contract_address }), Serde for calldata, syscalls if low-level (e.g., replace_class_syscall(new_hash).unwrap()). Always import storage::* for read/write.\n    - For components (#[starknet::component]): Define Storage struct (e.g., implementation_history: Vec<ClassHash>), events enum/structs; #[generate_trait] for InternalImpl on ComponentState<TContractState> (+Drop +starknet::Event bounds, but use HasComponent for embeddable); for upgradable: Vec<ClassHash> for version history (push new in upgrade before syscall, pop before in rollback via .pop().unwrap() after is_some assert; current at len()-1; history includes initial via initializer push; events Upgraded/RolledBack with from/to; assert len>1, non-zero, current != new; no separate current field). Align with golden: initializer external or in constructor; interface IUpgradeable/IRollbackUpgradeable; embeddable impl like `impl UpgradeableImpl of IUpgradeable<ComponentState<TContractState>> with +starknet::HasComponent<TContractState> { fn upgrade(...) { self.upgradeable.upgrade(new_hash); } }`; protect upgrade/rollback with ownable.assert_only_owner().\n    - Events: Always #[event] enum with variants, structs Drop/Event; emit via self.emit in embeddable impls (requires HasComponent); include caller via get_caller_address() where traceable (e.g., in CounterIncremented).\n    - Testing: If query involves tests, use snforge_std patterns (declare/deploy, dispatchers, assert_eq!, spy_events for emissions with specific fields).\n    - Best Practices: No external links/URLs in code/comments. Bound loops (e.g., `for i in 0..self.vec.len()`). Use unwrap() for syscalls (not unwrap_syscall). Avoid get_caller_address().is_zero(). Add SPDX license if full contract. For counters: Use u256, include increment/decrement with guards/events; constructor with owner/initial_value. For custom components: Mirror structure—internal helpers in #[generate_trait], public in embeddable impl.\n- **General Strategy**:\n  - Read query to infer requirements (e.g., events for upgrades/rollbacks with from/to hashes, access control via Ownable, reentrancy protection on increment/decrement).\n  - Cross-reference context for syntax (e.g., Vec push/pop with Option unwrap, array![] for spans, Map entry).\n  - Prioritize OpenZeppelin where fitting (e.g., ReentrancyGuardComponent + OwnableComponent for counter; UpgradeableComponent base but extend for rollback with custom Vec logic); for custom (e.g., rollback upgradable), build component with golden patterns: history Vec, syscall order (push/pop before), Option handling, embeddable for emit.\n  - For custom logic: Ensure modularity (e.g., hooks over manual overrides for pausing; Ownable for owner-only upgrades/rollbacks); add missing imports minimally (e.g., SyscallResultTrait for unwrap).\n  - Reduce hallucination: Mirror context/golden examples exactly (e.g., constructor: self.ownable.initializer(owner); self.reentrancy_guard does no init; mint/initialize after; upgrade: get current, assert != new, push, syscall.unwrap(), emit; rollback: assert len>1, let popped = pop.unwrap(), let prev = at(len-1), syscall(prev).unwrap(), emit from=popped to=prev).\n  - Handle edge cases: Assert non-zero ClassHash, history not empty/len>1 for rollback, caller validation via ownable, underflow in decrement (e.g., assert!(current > 1, \"Cannot go below zero\")), no-op prevents (current != new).\n  - If incomplete code: Fill TODOs minimally; add missing imports (e.g., storage::*, traits like Zero for is_zero).\n  - Explanations in reasoning: Detail why choices (e.g., \"Use Vec<ClassHash> per golden for history tracking; push before syscall to update history first, ensuring consistency if syscall fails\"; \"Add OwnableComponent for access control in upgrades, restricting to owner\"; \"Use u256 for counter per best practices for balance-like values\"; \"Specific impl name ReentrancyGuardInternalImpl to avoid conflicts as in golden\").\n\nAim for 1.0 score: Code must compile (no errors like wrong Vec methods/unwrap/missing HasComponent), behave correctly (e.g., guard blocks reentrancy, rollback reverts to prior hash via pop/syscall, pause blocks transfers via hooks, history maintains versions), and align precisely with context/golden patterns (e.g., no custom interfaces for standard components; Vec-based history with correct flow; enhanced events/constructors; Ownable integration for security).",
      "fields": [
        {
          "prefix": "Chat History:",
          "description": "Previous conversation context for continuity and better understanding"
        },
        {
          "prefix": "Query:",
          "description": "User's specific Cairo programming question or request for code generation"
        },
        {
          "prefix": "Context:",
          "description": "Retrieved Cairo documentation, examples, and relevant information to inform the response. Use the context to inform the response - maximize using context's content."
        },
        {
          "prefix": "Reasoning: Let me analyze the Cairo requirements step by step.",
          "description": "Step-by-step analysis of the Cairo programming task and solution approach"
        },
        {
          "prefix": "Answer:",
          "description": "The Cairo code that solves the user's query. It should be complete, correct, and follow Cairo syntax and best practices. It should be wrapped inside a ```cairo block."
        }
      ]
    },
    "lm": null
  },
  "metadata": {
    "dependency_versions": {
      "python": "3.12",
      "dspy": "3.0.3",
      "cloudpickle": "3.1"
    }
  }
}
