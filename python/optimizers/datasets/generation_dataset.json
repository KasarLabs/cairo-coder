{
  "examples": [
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n//\n// The previous exercise showed how to implement a trait for multiple types.\n// This exercise shows how you can implement multiple traits for a single type.\n// This is useful when you have types that share some common functionality, but\n// also have some unique functionality.\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Fish {\n    noise: felt252,\n    distance: u32,\n}\n\n#[derive(Copy, Drop)]\nstruct Dog {\n    noise: felt252,\n    distance: u32,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n    fn get_distance(self: T) -> u32;\n}\n\ntrait FishTrait {\n    fn swim(ref self: Fish) -> ();\n}\n\ntrait DogTrait {\n    fn walk(ref self: Dog) -> ();\n}\n\nimpl AnimalFishImpl of AnimalTrait<Fish> {\n    fn new() -> Fish {\n        Fish { noise: 'blub', distance: 0 }\n    }\n    fn make_noise(self: Fish) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Fish) -> u32 {\n        self.distance\n    }\n}\n\nimpl AnimalDogImpl of AnimalTrait<Dog> {\n    fn new() -> Dog {\n        Dog { noise: 'woof', distance: 0 }\n    }\n    fn make_noise(self: Dog) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Dog) -> u32 {\n        self.distance\n    }\n}\n\n// TODO: implement FishTrait for the type Fish\n\n// TODO: implement DogTrait for the type Dog\n\n#[cfg(test)]\n#[test]\nfn test_traits3() {\n    // Don't modify this test!\n    let mut salmon: Fish = AnimalTrait::new();\n    salmon.swim();\n    assert(salmon.make_noise() == 'blub', 'Wrong noise');\n    assert(salmon.get_distance() == 1, 'Wrong distance');\n\n    let mut dog: Dog = AnimalTrait::new();\n    dog.walk();\n    assert(dog.make_noise() == 'woof', 'Wrong noise');\n    assert(dog.get_distance() == 1, 'Wrong distance');\n}\n```\n\nHint: \nYou can implement multiple traits for a type.\nWhen a trait is destined to be implemented by a single type, you don't need to use generics.\nIf you're having trouble updating the distance value in the `Fish` and `Dog` impls, remember that you need to first\n1. Destructure the object into mutable variables\n2. Update the distance variable\n3. Reconstruct `self` with the updated variables (`self = MyStruct { ... }`) \n",
      "chat_history": "",
      "context": "The provided `raw_context` contains documentation and examples for Cairo's `ByteArray` (e.g., `append`, `concat`), `Span` (e.g., `pop_front`, `pop_back`, `slice`, `get`, `multi_pop_front`), `Array` (e.g., `span`, `append_span`), `Option` (e.g., `filter`, `flatten`), and `starknet::testing` utilities (e.g., `pop_log`, `cheatcode`, `get_contract_address`). This information is not directly relevant to the task of implementing traits for custom structs and modifying their fields using `ref self` in Cairo.",
      "expected": "//\n// The previous exercise showed how to implement a trait for multiple types.\n// This exercise shows how you can implement multiple traits for a single type.\n// This is useful when you have types that share some common functionality, but\n// also have some unique functionality.\n\n\n\n#[derive(Copy, Drop)]\nstruct Fish {\n    noise: felt252,\n    distance: u32,\n}\n\n#[derive(Copy, Drop)]\nstruct Dog {\n    noise: felt252,\n    distance: u32,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n    fn get_distance(self: T) -> u32;\n}\n\ntrait FishTrait {\n    fn swim(ref self: Fish) -> ();\n}\n\ntrait DogTrait {\n    fn walk(ref self: Dog) -> ();\n}\n\nimpl AnimalFishImpl of AnimalTrait<Fish> {\n    fn new() -> Fish {\n        Fish { noise: 'blub', distance: 0 }\n    }\n    fn make_noise(self: Fish) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Fish) -> u32 {\n        self.distance\n    }\n}\n\nimpl AnimalDogImpl of AnimalTrait<Dog> {\n    fn new() -> Dog {\n        Dog { noise: 'woof', distance: 0 }\n    }\n    fn make_noise(self: Dog) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Dog) -> u32 {\n        self.distance\n    }\n}\n\nimpl FishTraitImpl of FishTrait {\n    fn swim(ref self: Fish) {\n        self.distance += 1;\n    }\n}\n\nimpl DogTraitImpl of DogTrait {\n    fn walk(ref self: Dog) {\n        self.distance += 1;\n    }\n}\n\n#[test]\nfn test_traits3() {\n    // Don't modify this test!\n    let mut salmon: Fish = AnimalTrait::new();\n    salmon.swim();\n    assert(salmon.make_noise() == 'blub', 'Wrong noise');\n    assert(salmon.get_distance() == 1, 'Wrong distance');\n\n    let mut dog: Dog = AnimalTrait::new();\n    dog.walk();\n    assert(dog.make_noise() == 'woof', 'Wrong noise');\n    assert(dog.get_distance() == 1, 'Wrong distance');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Order {\n    name: felt252,\n    year: felt252,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: felt252,\n    count: felt252,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: 'Bob',\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0\n    }\n}\n#[cfg(test)]\n#[test]\nfn test_your_order() {\n    let order_template = create_order_template();\n    // TODO: Destructure your order into multiple variables to make the assertions pass!\n    // let ...\n\n    assert(name == 'Bob', 'Wrong name');\n    assert(year == order_template.year, 'Wrong year');\n    assert(made_by_phone == order_template.made_by_phone, 'Wrong phone');\n    assert(made_by_mobile == order_template.made_by_mobile, 'Wrong mobile');\n    assert(made_by_email == order_template.made_by_email, 'Wrong email');\n    assert(item_number == order_template.item_number, 'Wrong item number');\n    assert(count == 0, 'Wrong count');\n}\n```\n\nHint: Cairo requires you to initialize all fields when creating a struct and there is no update syntax available at the moment.\nYou can have multiple data types in a struct, and even other structs.\n\nThere are some shortcuts that can be taken when destructuring structs,\n```\nlet Foo {x, y} = foo; // Creates variables x and y with values foo.x and foo.y\nlet Foo {x: a, y: b} = foo; // Creates variables a and b with values foo.x and foo.y\n```\nRead more about structs in the Structs section of this article: https://book.cairo-lang.org/ch05-01-defining-and-instantiating-structs.html ",
      "chat_history": "",
      "context": "## Structures\nStructures (\"structs\") can be created using the `struct` keyword with a classic C structs syntax. They can have fields of various types, including other structs.\n\n```cairo\n#[derive(Drop, Debug)]\nstruct Person {\n    name: ByteArray,\n    age: u8,\n}\n\n// An empty struct\n#[derive(Drop, Debug)]\nstruct Unit {}\n\n// A struct with two fields\n#[derive(Drop)]\nstruct Point {\n    x: u32,\n    y: u32,\n}\n\n// Structs can be reused as fields of another struct\n#[derive(Drop)]\nstruct Rectangle {\n    top_left: Point,\n    bottom_right: Point,\n}\n\nfn main() {\n    // Create struct with field init shorthand\n    let name: ByteArray = \"Peter\";\n    let age = 27;\n    let peter = Person { name, age };\n\n    // Print debug struct\n    println!(\"{:?}\", peter);\n\n    // Instantiate a `Point`\n    let point: Point = Point { x: 5, y: 0 };\n    let another_point: Point = Point { x: 10, y: 0 };\n\n    // Access the fields of the point\n    println!(\"point coordinates: ({}, {})\", point.x, point.y);\n\n    // Make a new point by using struct update syntax to use the fields of our\n    // other one (Note: Cairo currently does not have direct update syntax, this example shows a common pattern for creating a new struct based on an existing one)\n    let bottom_right = Point { x: 10, ..another_point };\n\n    // `bottom_right.y` will be the same as `another_point.y` because we used that field\n    // from `another_point`\n    println!(\"second point: ({}, {})\", bottom_right.x, bottom_right.y);\n\n    // Destructure the point using a `let` binding\n    let Point { x: left_edge, y: top_edge } = point;\n\n    let _rectangle = Rectangle {\n        // struct instantiation is an expression too\n        top_left: Point { x: left_edge, y: top_edge }, bottom_right: bottom_right,\n    };\n\n    // Instantiate a unit struct\n    let _unit = Unit {};\n}\n```\n\n### Destructuring\nA `match` block can destructure items in a variety of ways, including structures. Structs can be destructured using a `let` binding to extract their fields into new variables. There are shortcuts for destructuring:\n\n- `let Foo {x, y} = foo;` creates variables `x` and `y` with values `foo.x` and `foo.y` respectively.\n- `let Foo {x: a, y: b} = foo;` creates variables `a` and `b` with values `foo.x` and `foo.y` respectively.\n\nFor example, to destructure a `Point` struct:\n```cairo\nlet Point { x: left_edge, y: top_edge } = point;\n```\nThis creates new variables `left_edge` and `top_edge` corresponding to `point.x` and `point.y`.",
      "expected": "// Address all the TODOs to make the tests pass!\n\n#[derive(Copy, Drop)]\nstruct Order {\n    name: felt252,\n    year: felt252,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: felt252,\n    count: felt252,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: 'Bob',\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0\n    }\n}\n#[cfg(test)]\n#[test]\nfn test_your_order() {\n    let order_template = create_order_template();\n    // TODO: Destructure your order into multiple variables to make the assertions pass!\n    let Order { name, year, made_by_phone, made_by_mobile, made_by_email, item_number, count } = order_template;\n\n    assert(name == 'Bob', 'Wrong name');\n    assert(year == order_template.year, 'Wrong year');\n    assert(made_by_phone == order_template.made_by_phone, 'Wrong phone');\n    assert(made_by_mobile == order_template.made_by_mobile, 'Wrong mobile');\n    assert(made_by_email == order_template.made_by_email, 'Wrong email');\n    assert(item_number == order_template.item_number, 'Wrong item number');\n    assert(count == 0, 'Wrong count');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n\n#[derive(Drop, Copy)]\nenum Message { // TODO: implement the message variant types based on their usage below\n}\n\n#[derive(Drop, Copy)]\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\n#[derive(Drop, Copy)]\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\ntrait StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8));\n    fn quit(ref self: State);\n    fn echo(ref self: State, s: felt252);\n    fn move_position(ref self: State, p: Point);\n    fn process(ref self: State, message: Message);\n}\nimpl StateImpl of StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8)) {\n        let State { color: _, position, quit } = self;\n        self = State { color: new_color, position: position, quit: quit };\n    }\n    fn quit(ref self: State) {\n        let State { color, position, quit: _ } = self;\n        self = State { color: color, position: position, quit: true };\n    }\n\n    fn echo(ref self: State, s: felt252) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(ref self: State, p: Point) {\n        let State { color, position: _, quit } = self;\n        self = State { color: color, position: p, quit: quit };\n    }\n\n    fn process(\n        ref self: State, message: Message,\n    ) { // TODO: create a match expression to process the different message variants\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_match_message_call() {\n    let mut state = State { quit: false, position: Point { x: 0, y: 0 }, color: (0, 0, 0) };\n    state.process(Message::ChangeColor((255, 0, 255)));\n    state.process(Message::Echo('hello world'));\n    state.process(Message::Move(Point { x: 10, y: 15 }));\n    state.process(Message::Quit);\n\n    assert(state.color == (255, 0, 255), 'wrong color');\n    assert(state.position.x == 10, 'wrong x position');\n    assert(state.position.y == 15, 'wrong y position');\n    assert(state.quit == true, 'quit should be true');\n}\n```\n\nHint: As a first step, you can define enums to compile this code without errors.\nand then create a match expression in `process()`.\nNote that you need to deconstruct some message variants\nin the match expression to get value in the variant.\nhttps://book.cairo-lang.org/ch06-01-enums.html\n",
      "chat_history": "",
      "context": "The provided context is not relevant to the query, which focuses on Cairo enum definitions and `match` expressions. The context covers `starknet::storage`, `core::array` traits, `starknet::info` functions, `core::byte_array` traits, `core::ops::range` traits, and `starknet::testing` functions. None of these topics provide information on enum syntax or `match` control flow.",
      "expected": "// Address all the TODOs to make the tests pass!\n\n\n\n#[derive(Drop, Copy)]\nenum Message {\n    Quit,\n    Echo: felt252,\n    Move: Point,\n    ChangeColor: (u8, u8, u8),\n}\n\n#[derive(Drop, Copy)]\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\n#[derive(Drop, Copy)]\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\ntrait StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8));\n    fn quit(ref self: State);\n    fn echo(ref self: State, s: felt252);\n    fn move_position(ref self: State, p: Point);\n    fn process(ref self: State, message: Message);\n}\nimpl StateImpl of StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8)) {\n        let State { color: _, position, quit } = self;\n        self = State { color: new_color, position: position, quit: quit };\n    }\n    fn quit(ref self: State) {\n        let State { color, position, quit: _ } = self;\n        self = State { color: color, position: position, quit: true };\n    }\n\n    fn echo(ref self: State, s: felt252) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(ref self: State, p: Point) {\n        let State { color, position: _, quit } = self;\n        self = State { color: color, position: p, quit: quit };\n    }\n\n    fn process(\n        ref self: State, message: Message,\n    ) {\n        match message {\n            Message::Quit => self.quit(),\n            Message::Echo(s) => self.echo(s),\n            Message::Move(p) => self.move_position(p),\n            Message::ChangeColor(c) => self.change_color(c),\n        }\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_match_message_call() {\n    let mut state = State { quit: false, position: Point { x: 0, y: 0 }, color: (0, 0, 0) };\n    state.process(Message::ChangeColor((255, 0, 255)));\n    state.process(Message::Echo('hello world'));\n    state.process(Message::Move(Point { x: 10, y: 15 }));\n    state.process(Message::Quit);\n\n    assert(state.color == (255, 0, 255), 'wrong color');\n    assert(state.position.x == 10, 'wrong x position');\n    assert(state.position.y == 15, 'wrong y position');\n    assert(state.quit, 'quit should be true');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n\n#[starknet::interface]\ntrait IContractA<TContractState> {\n    fn set_value(ref self: TContractState, value: u128) -> bool;\n    fn get_value(self: @TContractState) -> u128;\n}\n\n\n#[starknet::contract]\nmod ContractA {\n    use starknet::ContractAddress;\n    use super::IContractBDispatcher;\n    use super::IContractBDispatcherTrait;\n\n    #[storage]\n    struct Storage {\n        contract_b: ContractAddress,\n        value: u128,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, contract_b: ContractAddress) {\n        self.contract_b.write(contract_b)\n    }\n\n    #[abi(embed_v0)]\n    impl ContractAImpl of super::IContractA<ContractState> {\n        fn set_value(ref self: ContractState, value: u128) -> bool {\n            // TODO: check if contract_b is enabled.\n            // If it is, set the value and return true. Otherwise, return false.\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IContractB<TContractState> {\n    fn enable(ref self: TContractState);\n    fn disable(ref self: TContractState);\n    fn is_enabled(self: @TContractState) -> bool;\n}\n\n#[starknet::contract]\nmod ContractB {\n    #[storage]\n    struct Storage {\n        enabled: bool\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {}\n\n    #[abi(embed_v0)]\n    impl ContractBImpl of super::IContractB<ContractState> {\n        fn enable(ref self: ContractState) {\n            self.enabled.write(true);\n        }\n\n        fn disable(ref self: ContractState) {\n            self.enabled.write(false);\n        }\n\n        fn is_enabled(self: @ContractState) -> bool {\n            self.enabled.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::ContractAddress;\n    use super::{IContractBDispatcher, IContractADispatcher, IContractADispatcherTrait, IContractBDispatcherTrait};\n\n\n    fn deploy_contract_b() -> IContractBDispatcher {\n        let contract = declare(\"ContractB\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IContractBDispatcher { contract_address }\n    }\n\n    fn deploy_contract_a(contract_b_address: ContractAddress) -> IContractADispatcher {\n        let contract = declare(\"ContractA\").unwrap().contract_class();\n        let constructor_calldata = array![contract_b_address.into()];\n        let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();\n        IContractADispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_interoperability() {\n        // Deploy ContractB\n        let contract_b = deploy_contract_b();\n\n        // Deploy ContractA\n        let contract_a = deploy_contract_a(contract_b.contract_address);\n\n        //TODO interact with contract_b to make the test pass.\n\n        // Tests\n        assert(contract_a.set_value(300) == true, 'Could not set value');\n        assert(contract_a.get_value() == 300, 'Value was not set');\n        assert(contract_b.is_enabled() == true, 'Contract b is not enabled');\n    }\n}\n```\n\nHint: \nYou can call other contracts from inside a contract. To do this, you will need to create a Dispatcher object\nof the type of the called contract. Dispatchers have associated methods available under the `DispatcherTrait`, corresponding to the external functions of the contract that you want to call.\n",
      "chat_history": "",
      "context": "To call other contracts from inside a Cairo contract or from a Starknet Foundry test, a `Dispatcher` object of the target contract's interface type is required. Dispatchers provide associated methods, available under their respective `DispatcherTrait`, which correspond to the external functions of the contract to be called.\n\n**Key Concepts:**\n*   **Dispatcher Object:** An instance of `IContractNameDispatcher` (e.g., `IContractBDispatcher`) is created by providing the `ContractAddress` of the target contract.\n*   **DispatcherTrait:** Dispatchers implement a trait (e.g., `IContractBDispatcherTrait`) that exposes methods for each external function defined in the target contract's interface.\n*   **Inter-contract Calls:**\n    *   **From within a contract:** Read the target contract's address from storage, create a dispatcher, and call its methods.\n    *   **From a test:** After deploying a contract, create a dispatcher using its deployed `ContractAddress` to interact with it.\n*   **Conditional Logic:** Cairo supports `if/else` statements for conditional execution based on boolean expressions, such as the result of an inter-contract call.\n\n**Example Dispatcher Usage (Conceptual based on hint):**\n```cairo\n// Inside a contract function or test\nuse starknet::ContractAddress;\nuse super::{IContractBDispatcher, IContractBDispatcherTrait}; // Import necessary dispatcher and trait\n\n// ...\nlet target_contract_address: ContractAddress = /* get address from storage or deployment */;\nlet target_dispatcher = IContractBDispatcher { contract_address: target_contract_address };\n\n// Call an external function\nlet is_enabled_result: bool = target_dispatcher.is_enabled();\n\nif is_enabled_result {\n    // Do something if enabled\n} else {\n    // Do something else if not enabled\n}\n```",
      "expected": "// Address all the TODOs to make the tests pass!\n\n\n\n#[starknet::interface]\ntrait IContractA<TContractState> {\n    fn set_value(ref self: TContractState, value: u128) -> bool;\n    fn get_value(self: @TContractState) -> u128;\n}\n\n\n#[starknet::contract]\nmod ContractA {\n    use starknet::ContractAddress;\n    use super::IContractBDispatcher;\n    use super::IContractBDispatcherTrait;\n    use starknet::storage::*;\n\n    #[storage]\n    struct Storage {\n        contract_b: ContractAddress,\n        value: u128,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, contract_b: ContractAddress) {\n        self.contract_b.write(contract_b)\n    }\n\n    #[abi(embed_v0)]\n    impl ContractAImpl of super::IContractA<ContractState> {\n        fn set_value(ref self: ContractState, value: u128) -> bool {\n            // TODO: check if contract_b is enabled.\n            // If it is, set the value and return true. Otherwise, return false.\n            let contract_b = self.contract_b.read();\n            let contract_b_dispatcher = IContractBDispatcher { contract_address: contract_b };\n            if contract_b_dispatcher.is_enabled() {\n                self.value.write(value);\n                return true;\n            }\n            return false;\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IContractB<TContractState> {\n    fn enable(ref self: TContractState);\n    fn disable(ref self: TContractState);\n    fn is_enabled(self: @TContractState) -> bool;\n}\n\n#[starknet::contract]\nmod ContractB {\n    use starknet::storage::*;\n\n    #[storage]\n    struct Storage {\n        enabled: bool\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {}\n\n    #[abi(embed_v0)]\n    impl ContractBImpl of super::IContractB<ContractState> {\n        fn enable(ref self: ContractState) {\n            self.enabled.write(true);\n        }\n\n        fn disable(ref self: ContractState) {\n            self.enabled.write(false);\n        }\n\n        fn is_enabled(self: @ContractState) -> bool {\n            self.enabled.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::ContractAddress;\n    use super::{IContractBDispatcher, IContractADispatcher, IContractADispatcherTrait, IContractBDispatcherTrait};\n\n\n    fn deploy_contract_b() -> IContractBDispatcher {\n        let contract = declare(\"ContractB\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IContractBDispatcher { contract_address }\n    }\n\n    fn deploy_contract_a(contract_b_address: ContractAddress) -> IContractADispatcher {\n        let contract = declare(\"ContractA\").unwrap().contract_class();\n        let constructor_calldata = array![contract_b_address.into()];\n        let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();\n        IContractADispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_interoperability() {\n        // Deploy ContractB\n        let contract_b = deploy_contract_b();\n\n        // Deploy ContractA\n        let contract_a = deploy_contract_a(contract_b.contract_address);\n\n        // Enable contract_b to make the test pass\n        contract_b.enable();\n\n        // Tests\n        assert(contract_a.set_value(300) == true, 'Could not set value');\n        assert(contract_a.get_value() == 300, 'Value was not set');\n        assert(contract_b.is_enabled() == true, 'Contract b is not enabled');\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n#[derive(Copy, Drop)]\nstruct ColorStruct { // TODO: Something goes here\n// TODO: Your struct needs to have red, green, blue felts\n}\n\n\n#[cfg(test)]\n#[test]\nfn classic_c_structs() {\n    // TODO: Instantiate a classic color struct!\n    // Green color neeeds to have green set to 255 and, red and blue, set to 0\n    // let green =\n\n    assert(green.red == 0, 0);\n    assert(green.green == 255, 0);\n    assert(green.blue == 0, 0);\n}\n```\n\nHint: Cairo has a single type of struct that are named collections of related data stored in fields.\nIn this exercise you need to complete and implement a struct.\nHere is how we describe a person struct that stores a name and an age,\n\n#[derive(Copy, Drop)]\nstruct Person {\n    name: felt252,\n    age: felt252,\n}\n\nYou'd use the struct like so,\n\nlet john = Person { name: 'John', age: 29 };\n\n\nRead more about structs in the Structs section of this article: https://book.cairo-lang.org/ch05-01-defining-and-instantiating-structs.html ",
      "chat_history": "",
      "context": "Structures ('structs') in Cairo are defined using the `struct` keyword, similar to C structs. They are named collections of related data stored in fields.\n\n**Struct Definition Syntax:**\n```cairo\n#[derive(Drop, Debug)] // Attributes like `Drop` and `Debug` can be derived.\nstruct Person {\n    name: ByteArray,\n    age: u8,\n}\n\n// An empty struct\n#[derive(Drop, Debug)]\nstruct Unit {}\n\n// A struct with two fields\n#[derive(Copy, Drop)] // `Copy` is also a common derive attribute.\nstruct Point {\n    x: u32,\n    y: u32,\n}\n\n// Structs can be reused as fields of another struct\n#[derive(Drop)]\nstruct Rectangle {\n    top_left: Point,\n    bottom_right: Point,\n}\n```\n\nFields within a struct are defined with a name and a type, e.g., `field_name: Type`.\nFor the user's specific case, fields `red`, `green`, `blue` of type `felt252` would be defined as:\n```cairo\nstruct ColorStruct {\n    red: felt252,\n    green: felt252,\n    blue: felt252,\n}\n```\n\n**Struct Instantiation:**\nStructs are instantiated by providing values for each of their fields. Field init shorthand can be used if the variable name is the same as the field name.\n```cairo\n// Create struct with field init shorthand\nlet name: ByteArray = \"Peter\";\nlet age = 27;\nlet peter = Person { name, age };\n\n// Instantiate a `Point` explicitly\nlet point: Point = Point { x: 5, y: 0 };\n\n// Example with felt252 fields (from query hint):\nlet john = Person { name: 'John', age: 29 };\n```\n\n**Accessing Struct Fields:**\nFields of an instantiated struct can be accessed using dot notation (`.`).\n```cairo\nprintln!(\"point coordinates: ({}, {})\", point.x, point.y);\n```\n\n**Struct Update Syntax:**\nNew structs can be created by using fields from an existing struct with the `..` syntax.\n```cairo\nlet another_point: Point = Point { x: 10, y: 0 };\nlet bottom_right = Point { x: 10, ..another_point };\n// `bottom_right.y` will be the same as `another_point.y` because we used that field from `another_point`\n```\n\n**Destructuring Structs:**\nStructs can be destructured using a `let` binding or within `match` blocks.\n```cairo\nlet Point { x: left_edge, y: top_edge } = point;\n\n#[derive(Copy, Drop)]\nstruct Foo {\n    x: (u32, u32),\n    y: u32,\n}\nlet faa = Foo { x: (1, 2), y: 3 };\nlet Foo { x: x0, y: y0 } = faa;\nprintln!(\"Outside: x0 = {x0:?}, y0 = {y0}\");\n\n// Destructuring works with nested structs as well:\n#[derive(Drop)]\nstruct Bar {\n    foo: Foo,\n}\nlet bar = Bar { foo: faa };\nlet Bar { foo: Foo { x: nested_x, y: nested_y } } = bar;\nprintln!(\"Nested: nested_x = {nested_x:?}, nested_y = {nested_y:?}\");\n```",
      "expected": "// Address all the TODOs to make the tests pass!\n\n#[derive(Copy, Drop)]\nstruct ColorStruct {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\n\n#[cfg(test)]\n#[test]\nfn classic_c_structs() {\n    // TODO: Instantiate a classic color struct!\n    // Green color neeeds to have green set to 255 and, red and blue, set to 0\n    let green = ColorStruct { red: 0, green: 255, blue: 0 };\n\n    assert(green.red == 0, 0);\n    assert(green.green == 255, 0);\n    assert(green.blue == 0, 0);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Destructure the `cat` tuple to call print on each member.\n\n// I AM NOT DONE\n\nfn main() {\n    let cat = ('Furry McFurson', 3);\n    let // your pattern here = cat;\n    println!(\"name is {}\", name);\n    println!(\"age is {}\", age);\n}\n```\n\nHint: You'll need to make a pattern to bind `name` and `age` to the appropriate parts\nof the tuple.\nIf you're familiar with Rust, you should know that Cairo has a similar syntax to \ndestructure tuples into multiple variables.\nhttps://book.cairo-lang.org/ch02-02-data-types.html?highlight=destructu#the-tuple-type\nYou can do it!!\n",
      "chat_history": "",
      "context": "# Structures\n\nStructures (\"structs\") can be created using the `struct` keyword.\n\n```cairo,editable\n#[derive(Drop, Debug)]\nstruct Person {\n    name: ByteArray,\n    age: u8,\n}\n\n// A struct with two fields\n#[derive(Drop)]\nstruct Point {\n    x: u32,\n    y: u32,\n}\n\nfn main() {\n    // Create struct with field init shorthand\n    let name: ByteArray = \"Peter\";\n    let age = 27;\n    let peter = Person { name, age };\n\n    // Print debug struct\n    println!(\"{:?}\", peter);\n\n    // Instantiate a `Point`\n    let point: Point = Point { x: 5, y: 0 };\n\n    // Access the fields of the point\n    println!(\"point coordinates: ({}, {})\", point.x, point.y);\n\n    // Destructure the point using a `let` binding\n    let Point { x: left_edge, y: top_edge } = point;\n\n    println!(\"left_edge: {}, top_edge: {}\", left_edge, top_edge);\n}\n```\n\n### See also\n\n[`Drop`][drop], and [destructuring][destructuring]\n\n[drop]: ../trait/drop.md\n[destructuring]: ../flow_control/match/destructuring.md",
      "expected": "// Destructure the `cat` tuple to call print on each member.\n\n\n\nfn main() {\n    let cat = ('Furry McFurson', 3);\n    let (name, age) = cat;\n    println!(\"name is {}\", name);\n    println!(\"age is {}\", age);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Dictionaries can be used to simulate dynamic array : the value they store can be accessed and modified.\n// Your task is to create a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\nuse core::dict::Felt252Dict;\n\n\nfn multiply_element_by_10(ref dict: Felt252Dict<u32>, n: usize) {\n    //TODO : make a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n\n\n}\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_3() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 3);\n\n    multiply_element_by_10(ref dict, 3);\n\n    assert(dict.get(0) == 10, 'First element is not 10');\n    assert(dict.get(1) == 20, 'Second element is not 20');\n    assert(dict.get(2) == 30, 'Third element is not 30');\n}\n\n#[cfg(test)]\n#[test]\nfn test_4() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 5);\n    dict.insert(3, 10);\n\n    multiply_element_by_10(ref dict, 4);\n\n    assert(dict.get(2) == 50, 'First element is not 50');\n    assert(dict.get(3) == 100, 'First element is not 100');\n\n}\n```\n\nHint: More info about the Felt252Dict type can be found in the following chapter :\nhttps://book.cairo-lang.org/ch03-02-dictionaries.html\n",
      "chat_history": "",
      "context": "The provided `raw_context` contains documentation and examples for `ByteArray`, `Vec`, `Span`, and `Array` traits, along with Starknet execution information functions. It does not include any specific information, methods, or examples for `core::dict::Felt252Dict`. Therefore, the provided context is not relevant to the query regarding `Felt252Dict` usage.",
      "expected": "// Dictionaries can be used to simulate dynamic array : the value they store can be accessed and modified.\n// Your task is to create a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n// Make me compile and pass the test!\n\nuse core::dict::Felt252Dict;\n\nfn multiply_element_by_10(ref dict: Felt252Dict<u32>, n: usize) {\n    //TODO : make a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n    for i in 0..n {\n        let current_value = dict.get(i.into());\n        dict.insert(i.into(), current_value * 10);\n    }\n}\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_3() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 3);\n\n    multiply_element_by_10(ref dict, 3);\n\n    assert(dict.get(0) == 10, 'First element is not 10');\n    assert(dict.get(1) == 20, 'Second element is not 20');\n    assert(dict.get(2) == 30, 'Third element is not 30');\n}\n\n#[cfg(test)]\n#[test]\nfn test_4() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 5);\n    dict.insert(3, 10);\n\n    multiply_element_by_10(ref dict, 4);\n\n    assert(dict.get(2) == 50, 'First element is not 50');\n    assert(dict.get(3) == 100, 'First element is not 100');\n\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // A short string is a string whose length is at most 31 characters, and therefore can fit into a single field element.\n    // Short strings are actually felts, they are not a real string.\n    // Note the _single_ quotes that are used with short strings.\n\n    let mut my_first_initial = 'C';\n    if is_alphabetic(\n        ref my_first_initial\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref my_first_initial\n    ) {\n        println!(\" Numerical !\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n\n    let  // Finish this line like the example! What's your favorite short string?\n    // Try a letter, try a number, try a special character, try a short string!\n    if is_alphabetic(\n        ref your_character\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref your_character\n    ) {\n        println!(\" Numerical!\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n}\n\nfn is_alphabetic(ref char: felt252) -> bool {\n    if char >= 'a' {\n        if char <= 'z' {\n            return true;\n        }\n    }\n    if char >= 'A' {\n        if char <= 'Z' {\n            return true;\n        }\n    }\n    false\n}\n\nfn is_numeric(ref char: felt252) -> bool {\n    if char >= '0' {\n        if char <= '9' {\n            return true;\n        }\n    }\n    false\n}\n\n// Note: the following code is not part of the challenge, it's just here to make the code above work.\n// Direct felt252 comparisons have been removed from the core library, so we need to implement them ourselves.\n// There will probably be a string / short string type in the future\nimpl PartialOrdFelt of PartialOrd<felt252> {\n    #[inline(always)]\n    fn le(lhs: felt252, rhs: felt252) -> bool {\n        !(rhs < lhs)\n    }\n    #[inline(always)]\n    fn ge(lhs: felt252, rhs: felt252) -> bool {\n        !(lhs < rhs)\n    }\n    #[inline(always)]\n    fn lt(lhs: felt252, rhs: felt252) -> bool {\n        let lhs_u256: u256 = lhs.into();\n        let rhs_u256: u256 = rhs.into();\n        lhs_u256 < rhs_u256\n    }\n    #[inline(always)]\n    fn gt(lhs: felt252, rhs: felt252) -> bool {\n        rhs < lhs\n    }\n}\n```\n\nHint: No hints this time ;)",
      "chat_history": "",
      "context": "The provided context includes documentation for Cairo's `ByteArray` and `Span` types, along with their associated traits and functions.\n- **`ByteArrayTrait`**: Provides functions like `append` (for `ByteArray`) and `concat` (for `ByteArray`).\n  - `fn append(ref self: ByteArray, other: ByteArray)`\n  - `fn concat(left: ByteArray, right: ByteArray) -> ByteArray`\n- **`MutableVecTrait` (for `starknet::storage::Vec`)**: Includes `append` for storage vectors.\n  - `fn append<T, T>(self: T) -> StoragePath<Mutable<MutableVecTrait<T>ElementType>>`\n  - `allocate` is mentioned as a replacement for the deprecated `append` for storage vectors, useful for dynamic size elements.\n- **`OptionTrait`**: A trait for `Option<T>` operations.\n  - `pub trait OptionTrait<T>`\n- **`SpanTrait`**: Provides functions for `Span<T>`.\n  - `fn multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n  - `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n  - `fn get<T, T>(self: Span<T>, index: u32) -> Option<Box<@T>>`\n  - `fn slice<T, T>(self: Span<T>, start: u32, length: u32) -> Span<T>`\n  - `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`\n  - `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n- **`ToSpanTrait`**: Converts a data structure into a span.\n  - `fn span<C, T, C, T>(self: @C) -> Span<T>`\n- **`ArrayTrait`**: Includes `append_span` for `Array<T>`.\n  - `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`\n- **Starknet-specific functions**:\n  - `cheatcode`: `pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;`\n  - `get_execution_info`: `pub fn get_execution_info() -> Box<ExecutionInfo>`\n  - `get_contract_address`: `pub fn get_contract_address() -> ContractAddress`\n\nThe context does not provide specific examples or documentation for declaring `felt252` variables with short string literals, but the user's query already demonstrates the syntax: `let mut my_first_initial = 'C';`.",
      "expected": "// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\nfn main() {\n    // A short string is a string whose length is at most 31 characters, and therefore can fit into a single field element.\n    // Short strings are actually felts, they are not a real string.\n    // Note the _single_ quotes that are used with short strings.\n\n    let mut my_first_initial = 'C';\n    if is_alphabetic(\n        ref my_first_initial\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref my_first_initial\n    ) {\n        println!(\" Numerical !\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n\n    let mut your_character = 'A'; // Finish this line like the example! What's your favorite short string?\n    // Try a letter, try a number, try a special character, try a short string!\n    if is_alphabetic(\n        ref your_character\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref your_character\n    ) {\n        println!(\" Numerical!\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n}\n\nfn is_alphabetic(ref char: felt252) -> bool {\n    if char >= 'a' {\n        if char <= 'z' {\n            return true;\n        }\n    }\n    if char >= 'A' {\n        if char <= 'Z' {\n            return true;\n        }\n    }\n    false\n}\n\nfn is_numeric(ref char: felt252) -> bool {\n    if char >= '0' {\n        if char <= '9' {\n            return true;\n        }\n    }\n    false\n}\n\n// Note: the following code is not part of the challenge, it's just here to make the code above work.\n// Direct felt252 comparisons have been removed from the core library, so we need to implement them ourselves.\n// There will probably be a string / short string type in the future\nimpl PartialOrdFelt of PartialOrd<felt252> {\n    #[inline(always)]\n    fn le(lhs: felt252, rhs: felt252) -> bool {\n        !(rhs < lhs)\n    }\n    #[inline(always)]\n    fn ge(lhs: felt252, rhs: felt252) -> bool {\n        !(lhs < rhs)\n    }\n    #[inline(always)]\n    fn lt(lhs: felt252, rhs: felt252) -> bool {\n        let lhs_u256: u256 = lhs.into();\n        let rhs_u256: u256 = rhs.into();\n        lhs_u256 < rhs_u256\n    }\n    #[inline(always)]\n    fn gt(lhs: felt252, rhs: felt252) -> bool {\n        rhs < lhs\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let // Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n```\n\nHint: No hints this time ;)",
      "chat_history": "",
      "context": "The provided context focuses on the `core::array::SpanTrait` and `core::byte_array::ByteArrayTrait` in Cairo. It includes function signatures and examples for:\n\n*   **`core::array::SpanTrait`**:\n    *   `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`: Pops a value from the front of the span.\n    *   `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`: Pops a value from the back of the span.\n    *   `fn slice<T, T>(self: Span<T>, start: u32, length: u32) -> Span<T>`: Returns a span containing values from `start` with `length`.\n    *   `fn len(self: Span<T>) -> usize`: Returns the length of the span.\n    *   `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`: Pops multiple values from the front.\n    *   `fn multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`: Pops multiple values from the back.\n    *   `fn at<T, T>(self: Span<T>, index: u32) -> @T`: Returns a snapshot of the element at the given index.\n    *   `fn get<T, T>(self: Span<T>, index: u32) -> Option<Box<@T>>`: Returns an option containing a box of a snapshot of the element at the given `index`.\n\n*   **`core::array::ToSpanTrait`**:\n    *   `pub trait ToSpanTrait<C, T>`: Converts a data structure into a span.\n    *   `fn span<C, T, C, T>(self: @C) -> Span<T>`: Returns a span pointing to the data in the input.\n\n*   **`core::array::ArrayTrait`**:\n    *   `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`: Appends a span to the end of an array.\n    *   `fn pop_front<T, T>(ref self: Array<T>) -> Option<T>`: Pops a value from the front of the array.\n\n*   **`core::byte_array::ByteArrayTrait`**:\n    *   `fn append_word(ref self: ByteArray, word: felt252, len: u32)`: Appends a word to the `ByteArray`.\n    *   `fn concat(left: ByteArray, right: ByteArray) -> ByteArray`: Concatenates two `ByteArray`s.\n    *   `fn append_byte(ref self: ByteArray, byte: u8)`: Appends a single byte.\n\n*   **`core::starknet::testing::cheatcode`**:\n    *   `pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;`: Returns a span containing the cheatcode's output.\n\nThe context does not contain information about basic Cairo variable declaration syntax, boolean types, or `if` statement usage, which are required to complete the user's code snippet.",
      "expected": "// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening = false;\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\n#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n\n    let result = loop {\n        if counter == 5 {\n    //TODO return a value from the loop\n        }\n        counter += 1;\n    };\n\n    assert(result == 5, 'result should be 5');\n}\n```\n\nHint: You can return values from loops by adding the value you want returned after the `break` expression you use to stop the loop. Don't forget that assigning a variable to the value returned from a `loop` is an expression, and thus must end with a semicolomn.\n",
      "chat_history": "",
      "context": "One of the uses of a `loop` is to retry an operation until it succeeds. If the operation returns a value, you can pass it to the rest of the code by putting it after the `break` keyword. This value will then be returned by the `loop` expression.\n\nExample:\n```cairo,editable\nfn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    assert!(result == 20);\n}\n```",
      "expected": "#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n\n    let result = loop {\n        if counter == 5 {\n            break counter;\n        }\n        counter += 1;\n    };\n\n    assert(result == 5, 'result should be 5');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\n#[cfg(test)]\n#[test]\nfn test_options() {\n    let target = 'starklings';\n    let optional_some = Option::Some(target);\n    let optional_none: Option<felt252> = Option::None;\n    simple_option(optional_some);\n    simple_option(optional_none);\n}\n\nfn simple_option(optional_target: Option<felt252>) {\n    // TODO: use the `is_some` and `is_none` methods to check if `optional_target` contains a value.\n    // Place the assertion and the print statement below in the correct blocks.\n    assert(optional_target.unwrap() == 'starklings', 'err1');\n    println!(\" option is empty ! \");\n}\n```\n\nHint: check out: https://github.com/starkware-libs/cairo/blob/main/corelib/src/option.cairo\nto see the implementation of the Option type and its methods.\n",
      "chat_history": "",
      "context": "The `Option` enum in Cairo is used to represent the presence or absence of a value. It is frequently returned by methods that might not always yield a result, such as those operating on collections.\n\n**`Option<@T>` as a return type:**\n*   `SpanTrait::pop_front`: `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   Returns `Some(@value)` if the span is not empty, `None` otherwise.\n    *   Example:\n        ```cairo\n        let mut span = array![1, 2, 3].span();\n        assert!(span.pop_front() == Some(@1));\n        ```\n*   `SpanTrait::pop_back`: `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   Returns `Some(@value)` if the array is not empty, `None` otherwise.\n    *   Example:\n        ```cairo\n        let mut span = array![1, 2, 3].span();\n        assert!(span.pop_back() == Some(@3));\n        ```\n*   `SpanTrait::get`: Returns an option containing a box of a snapshot of the element at the given 'index' if the span contains this index, 'None' otherwise.\n\n**`Option<Box<[T; SIZE]>>` as a return type:**\n*   `SpanTrait::multi_pop_front`: `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n    *   Pops multiple values from the front of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if successful, `None` otherwise.\n    *   Example:\n        ```cairo\n        let mut span = array![1, 2, 3].span();\n        let result = *(span.multi_pop_front::<2>().unwrap());\n        let unboxed_result = result.unbox();\n        assert!(unboxed_result == [1, 2]);\n        ```\n*   `SpanTrait::multi_pop_back`: `fn multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n    *   Pops multiple values from the back of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if successful, `None` otherwise.\n    *   Example:\n        ```cairo\n        let mut span = array![1, 2, 3].span();\n        let result = *(span.multi_pop_back::<2>().unwrap());\n        let unboxed_result = result.unbox();\n        assert!(unboxed_result == [2, 3]);\n        ```\n\n**Usage of `unwrap()`:**\nThe `unwrap()` method is used on an `Option` to extract the contained value, assuming the `Option` is `Some`. If the `Option` is `None`, `unwrap()` will panic. Examples above demonstrate its use after `multi_pop_front` and `multi_pop_back`.\n\nThe provided context does not include documentation for `Option::is_some` or `Option::is_none`.",
      "expected": "#[cfg(test)]\n#[test]\nfn test_options() {\n    let target = 'starklings';\n    let optional_some = Option::Some(target);\n    let optional_none: Option<felt252> = Option::None;\n    simple_option(optional_some);\n    simple_option(optional_none);\n}\n\nfn simple_option(optional_target: Option<felt252>) {\n    // TODO: use the `is_some` and `is_none` methods to check if `optional_target` contains a value.\n    // Place the assertion and the print statement below in the correct blocks.\n    if optional_target.is_some() {\n        assert!(optional_target.unwrap() == 'starklings');\n        println!(\" option is empty ! \");\n    } else {\n        assert!(optional_target.is_none());\n        println!(\" option is empty ! \");\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\n#[derive(Drop)]\nstruct Student {\n    name: felt252,\n    courses: Array<Option<felt252>>,\n}\n\n\nfn display_grades(student: @Student) {\n    let mut msg = ArrayTrait::new();\n    msg.append(*student.name);\n    msg.append('\\'s grades:');\n    println!(\"{:?}\", msg);\n\n    for course in student.courses.span() {\n        // TODO: Modify the following lines so that if there is a grade for the course, it is printed.\n        //       Otherwise, print \"No grade\".\n        //\n        println!(\"grade is {}\", course.unwrap());\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_all_defined() {\n    let courses = array![\n        Option::Some('A'),\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::Some('A'),\n    ];\n    let mut student = Student { name: 'Alice', courses: courses };\n    display_grades(@student);\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_some_empty() {\n    let courses = array![\n        Option::Some('A'),\n        Option::None,\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::None,\n    ];\n    let mut student = Student { name: 'Bob', courses: courses };\n    display_grades(@student);\n}\n```\n\nHint: Reminder: You can use a match statement with an Option to handle both the Some and None cases.\nThis syntax is more flexible than using unwrap, which only handles the Some case, and contributes to more robust code.\n",
      "chat_history": "",
      "context": "The `core::array::SpanTrait` provides methods that interact with `Option` types, indicating the presence or absence of a value. When iterating over a `Span<T>`, elements are typically accessed as snapshots (`@T`).\n\n### SpanTrait Functions Returning Option\n\n- **`pop_front`**: Pops a value from the front of the span. Returns `Option<@T>` if the span is not empty, `None` otherwise.\n  ```cairo\n  fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>\n  ```\n- **`pop_back`**: Pops a value from the back of the span. Returns `Option<@T>` if the span is not empty, `None` otherwise.\n  ```cairo\n  fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>\n  ```\n- **`multi_pop_front`**: Pops multiple values from the front of the span. Returns `Option<Box<[T; SIZE]>>` if successful, `None` otherwise.\n  ```cairo\n  fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>\n  ```\n- **`multi_pop_back`**: Pops multiple values from the back of the span. Returns `Option<Box<[T; SIZE]>>` if successful, `None` otherwise.\n  ```cairo\n  fn multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>\n  ```\n- **`get`**: Returns an option containing a box of a snapshot of the element at the given `index` if the span contains this index, `None` otherwise.\n  ```cairo\n  fn get<T, T>(self: Span<T>, index: u32) -> Option<Box<@T>>\n  ```\n\nThese examples illustrate that `Option` is used to handle cases where a value might or might not be present, and `Span` elements are often returned as snapshots (`@T`) or boxed snapshots (`Box<@T>`).",
      "expected": "#[derive(Drop)]\nstruct Student {\n    name: felt252,\n    courses: Array<Option<felt252>>,\n}\n\n\nfn display_grades(student: @Student) {\n    let mut msg = ArrayTrait::new();\n    msg.append(*student.name);\n    msg.append('\\'s grades:');\n    println!(\"{:?}\", msg);\n\n    for course in student.courses.span() {\n        if course.is_some() {\n            println!(\"grade is {}\", course.unwrap());\n        } else {\n            println!(\"No grade\");\n        }\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_all_defined() {\n    let courses = array![\n        Option::Some('A'),\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::Some('A'),\n    ];\n    let mut student = Student { name: 'Alice', courses: courses };\n    display_grades(@student);\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_some_empty() {\n    let courses = array![\n        Option::Some('A'),\n        Option::None,\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::None,\n    ];\n    let mut student = Student { name: 'Bob', courses: courses };\n    display_grades(@student);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\n// This function returns how much icecream there is left in the fridge.\n// If it's before 10PM, there's 5 pieces left. At 10PM, someone eats them\n// all, so there'll be no more left :(\nfn maybe_icecream(\n    time_of_day: usize\n) -> Option<usize> { // We use the 24-hour system here, so 10PM is a value of 22 and 12AM is a value of 0\n// The Option output should gracefully handle cases where time_of_day > 23.\n// TODO: Complete the function body - remember to return an Option!\n}\n\n\n#[cfg(test)]\n#[test]\nfn check_icecream() {\n    assert(maybe_icecream(9).unwrap() == 5, 'err_1');\n    assert(maybe_icecream(10).unwrap() == 5, 'err_2');\n    assert(maybe_icecream(23).unwrap() == 0, 'err_3');\n    assert(maybe_icecream(22).unwrap() == 0, 'err_4');\n    assert(maybe_icecream(25).is_none(), 'err_5');\n}\n\n#[cfg(test)]\n#[test]\nfn raw_value() {\n    // TODO: Fix this test. How do you get at the value contained in the Option?\n    let icecreams = maybe_icecream(12);\n    assert(icecreams == 5, 'err_6');\n}\n```\n\nHint: Options can have a Some value, with an inner value, or a None value, without an inner value.\nThere's multiple ways to get at the inner value, you can use unwrap, or pattern match. Unwrapping\nis the easiest, but how do you do it safely so that it doesn't panic in your face later?\nhttps://book.cairo-lang.org/ch06-01-enums.html#the-option-enum-and-its-advantages\n",
      "chat_history": "",
      "context": "The `Option` enum in Cairo is used to represent the presence or absence of a value. It can be either `Some(value)` if a value is present, or `None` if there is no value. The type of the inner value can vary, for example, `Option<@T>`, `Option<Box<[T; SIZE]>>`, `Option<Box<@T>>`, or `Option<T>`.\n\n**Returning Option values:**\n- Functions like `pop_front` and `pop_back` from `SpanTrait` return `Option<@T>`:\n  ```cairo\n  fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>\n  // Returns `Some(@value)` if the array is not empty, `None` otherwise.\n  ```\n  Example:\n  ```cairo\n  let mut span = array![1, 2, 3].span();\n  assert!(span.pop_front() == Some(@1));\n  assert!(span.pop_back() == Some(@3));\n  ```\n- Functions like `multi_pop_front` and `multi_pop_back` from `SpanTrait` return `Option<Box<[T; SIZE]>>`:\n  ```cairo\n  fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>\n  // Returns an option containing a snapshot of a box that contains the values as a fixed-size array if successful, 'None' otherwise.\n  ```\n  Example:\n  ```cairo\n  let mut span = array![1, 2, 3].span();\n  let result = *(span.multi_pop_front::<2>().unwrap());\n  let unboxed_result = result.unbox();\n  assert!(unboxed_result == [1, 2]);\n  ```\n- The `get` method from `SpanTrait` returns `Option<Box<@T>>`:\n  ```cairo\n  fn get<T, T>(self: Span<T>, index: u32) -> Option<Box<@T>>\n  // Returns an option containing a box of a snapshot of the element at the given 'index' if the span contains this index, 'None' otherwise.\n  ```\n  Example:\n  ```cairo\n  let span = array![2, 3, 4];\n  assert!(span.get(1).unwrap().unbox() == @3);\n  ```\n- The `pop_log` function from `starknet::testing` returns `Option<T>`:\n  ```cairo\n  pub fn pop_log<T, +starknet::Event<T>>(address: ContractAddress) -> Option<T>\n  ```\n  Example:\n  ```cairo\n  assert_eq!(\n      starknet::testing::pop_log(contract_address), Some(contract::Event::Event1(42))\n  );\n  assert_eq!(starknet::testing::pop_log_raw(contract_address), None);\n  ```\n\n**Extracting values from Option:**\n- The `unwrap()` method can be used to extract the inner value from a `Some` variant. If called on a `None` variant, it will panic.\n- If the `Option` contains a `Box` (e.g., `Option<Box<T>>`), the `unbox()` method is used to get the inner value from the `Box` after unwrapping the `Option`.",
      "expected": "// This function returns how much icecream there is left in the fridge.\n// If it's before 10PM, there's 5 pieces left. At 10PM, someone eats them\n// all, so there'll be no more left :(\nfn maybe_icecream(\n    time_of_day: usize\n) -> Option<usize> {\n    if time_of_day > 23 {\n        None\n    } else if time_of_day < 22 {\n        Some(5)\n    } else {\n        Some(0)\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn check_icecream() {\n    assert(maybe_icecream(9).unwrap() == 5, 'err_1');\n    assert(maybe_icecream(10).unwrap() == 5, 'err_2');\n    assert(maybe_icecream(23).unwrap() == 0, 'err_3');\n    assert(maybe_icecream(22).unwrap() == 0, 'err_4');\n    assert(maybe_icecream(25).is_none(), 'err_5');\n}\n\n#[cfg(test)]\n#[test]\nfn raw_value() {\n    // TODO: Fix this test. How do you get at the value contained in the Option?\n    let icecreams = maybe_icecream(12);\n    assert(icecreams.unwrap() == 5, 'err_6');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nconst NUMBER = 3;\nconst SMALL_NUMBER = 3_u8;\nfn main() {\n    println!(\"NUMBER is {}\", NUMBER);\n    println!(\"SMALL_NUMBER is {}\", SMALL_NUMBER);\n}\n```\n\nHint: We know about variables and mutability, but there is another important type of\nvariable available: constants.\nConstants are always immutable and they are declared with keyword 'const' rather\nthan keyword 'let'.\nConstants types must also always be annotated.\nYou can read about the constants here: https://book.cairo-lang.org/ch02-01-variables-and-mutability.html?highlight=const#constants\n",
      "chat_history": "",
      "context": "The provided context details various functions and traits from the Cairo core library, including:\n*   **`core::array::SpanTrait`**: Provides methods for manipulating `Span<T>` such as `pop_front`, `pop_back`, `multi_pop_front`, `multi_pop_back`, `slice`, `len`, `get`, and `at`.\n    *   `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`: Pops a value from the front.\n    *   `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`: Pops a value from the back.\n    *   `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`: Pops multiple values from the front.\n    *   `fn multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`: Pops multiple values from the back.\n    *   `fn slice<T, T>(self: Span<T>, start: u32, length: u32) -> Span<T>`: Returns a sub-span.\n    *   `fn get<T, T>(self: Span<T>, index: u32) -> Option<Box<@T>>`: Returns an optional snapshot of the element at `index`.\n    *   `fn at<T, T>(self: Span<T>, index: u32) -> @T`: Returns a snapshot of the element at `index`.\n*   **`core::array::ToSpanTrait`**: Converts a data structure into a span.\n    *   `pub trait ToSpanTrait<C, T>`\n    *   `fn span<C, T, C, T>(self: @C) -> Span<T>`: Returns a span pointing to the data.\n*   **`core::array::ArrayTrait`**: Provides methods for `Array<T>`.\n    *   `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`: Appends a span to the array.\n*   **`core::byte_array::ByteArrayTrait`**: Provides methods for `ByteArray`.\n    *   `fn append_word(ref self: ByteArray, word: felt252, len: u32)`: Appends a word.\n    *   `fn append(ref self: ByteArray, other: ByteArray)`: Appends another `ByteArray`.\n    *   `fn concat(left: ByteArray, right: ByteArray) -> ByteArray`: Concatenates two `ByteArray`s.\n    *   `append_byte`: Appends a single byte.\n*   **`core::starknet::testing::cheatcode`**: A public external function for testing.\n    *   `pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;`\n*   **`core::starknet::storage::vec::MutableVecTrait`**: For mutable storage vectors.\n    *   `fn append<T, T>(self: T) -> StoragePath<Mutable<MutableVecTrait<T>ElementType>>`: Appends an element (deprecated, replaced by `allocate`).\n    *   `allocate`: Allocates space for a new element.\n*   **`core::starknet::info::get_contract_address`**: Retrieves the contract address.\n    *   `pub fn get_contract_address() -> ContractAddress`\n\nThis context does not contain any information regarding Cairo constants, the `const` keyword, type annotation requirements for constants, or the `println!` macro, which are the subjects of the user's query.",
      "expected": "const NUMBER: felt252 = 3;\nconst SMALL_NUMBER: u8 = 3_u8;\nfn main() {\n    println!(\"NUMBER is {}\", NUMBER);\n    println!(\"SMALL_NUMBER is {}\", SMALL_NUMBER);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n\nfn call_me(num: u64) {\n    println!(\"num is {}\", num);\n}\n```\n\nHint: This time, the function *declaration* is okay, but there's something wrong\nwith the place where we're calling the function.\nAs a reminder, you can freely play around with different solutions in Starklings!\nWatch mode will only jump to the next exercise if you remove the I AM NOT DONE comment.",
      "chat_history": "",
      "context": "## for and range\nIterate through an `Iterator` using `for in`. Ranges `a..b` (exclusive end) and `a..=b` (inclusive end) create iterators.\n\n```cairo\nfn main() {\n    // `n` will take the values: 1, 2, ..., 100\n    for n in 1..101_u8 {\n        if n % 15 == 0 { println!(\"fizzbuzz\"); }\n        else if n % 3 == 0 { println!(\"fizz\"); }\n        else if n % 5 == 0 { println!(\"buzz\"); }\n        else { println!(\"{}\", n); }\n    }\n}\n```\n\n```cairo\nfn main() {\n    // `n` will take the values: 1, 2, ..., 100\n    for n in 1..= 100_u8 {\n        if n % 15 == 0 { println!(\"fizzbuzz\"); }\n        else if n % 3 == 0 { println!(\"fizz\"); }\n        else if n % 5 == 0 { println!(\"buzz\"); }\n        else { println!(\"{}\", n); }\n    }\n}\n```\n\n## Arrays, Spans, and Fixed-Size Arrays\n`Array` is a growable, write-once collection. `Span` is an immutable snapshot. `Fixed-Size Array` is an immutable sequence known at compile time.\n\n```cairo\nfn main() {\n    let mut arr = array![];\n    arr.append(1);\n    arr.append(2);\n    arr.append(3);\n\n    println!(\"First element of the array: {}\", *arr[0]);\n    println!(\"Second element of the array: {}\", *arr[1]);\n    println!(\"Number of elements in the array: {}\", arr.len());\n\n    let span = arr.span();\n    let _ = arr.pop_front();\n    println!(\"First element in span: {}\", *span[0]);\n\n    let xs: [u32; 3] = [1, 2, 3];\n    let ys: [u32; 3] = [0; 3];\n    println!(\"xs: {:?}\", xs);\n    println!(\"ys: {:?}\", ys);\n    println!(\"ys first element: {}\", *xs.span()[0]);\n}\n```\n\n## Formatted print\nPrinting is handled by macros in `core::fmt`: `format!`, `print!`, `println!`. Cairo checks formatting correctness at compile time.\n\n- `{}`: automatically replaced with stringified arguments.\n- `{0}`: positional arguments.\n- `{:x}`: different formatting (e.g., hexadecimal).\n- `fmt::Debug`: uses `{:?}` for debugging.\n- `fmt::Display`: uses `{}` for user-friendly output.\n\n```cairo\nstruct Structure { inner: i32, }\n\nfn main() {\n    println!(\"{} days\", 31);\n    let alice: ByteArray = \"Alice\";\n    let bob: ByteArray = \"Bob\";\n    println!(\"{0}, this is {1}. {1}, this is {0}\", alice, bob);\n    println!(\"Base 10:               {}\", 69420);\n    println!(\"Base 16 (hexadecimal): {:x}\", 69420);\n    let bond: ByteArray = \"Bond\";\n    println!(\"My name is {0}, {1} {0}\", bond, \"James\"); // Fixed: Added missing argument\n    // println!(\"This struct `{}` won't print...\", Structure(3)); // Will not compile without fmt::Display\n}\n```\n\n## Pulling `Result`s out of `Option`s\n`Option` and `Result` can be nested. `map` can be used to transform values within `Option`.\n\n```cairo\n#[derive(Drop, Debug)]\nstruct ParseError { message: ByteArray, }\n\nfn parse_ascii_digit(value: @ByteArray) -> Result<u32, ParseError> {\n    if value.len() != 1 { Result::Err(ParseError { message: \"Expected a single character\" }) }\n    else { let byte = value[0]; if byte >= '0' && byte <= '9' { Result::Ok((byte - '0').into()) } else { Result::Err(ParseError { message: \"Character is not a digit\" }) } }\n}\n\nfn double_first(arr: Array<ByteArray>) -> Option<Result<u32, ParseError>> {\n    arr.get(0).map(|first| { parse_ascii_digit(first.unbox()).map(|n| 2 * n) })\n}\n\nfn main() {\n    let numbers = array![\"4\", \"9\", \"1\"];\n    let empty = array![];\n    let strings = array![\"t\", \"9\", \"1\"];\n\n    println!(\"The first doubled is {:?}\", double_first(numbers));\n    println!(\"The first doubled is {:?}\", double_first(empty));\n    println!(\"The first doubled is {:?}\", double_first(strings));\n}\n```\n\n## `map` for `Result`\n`Result<T, E>` represents success (`Ok(T)`) or failure (`Err(E)`). `map`, `and_then` and other combinators are available for `Result`.\n\n```cairo\n#[derive(Drop)]\nstruct ParseError { message: ByteArray, }\n\nfn parse_ascii_digit(value: ByteArray) -> Result<u32, ParseError> {\n    if value.len() != 1 { Result::Err(ParseError { message: \"Expected a single character\" }) }\n    else { let byte = value[0]; if byte >= '0' && byte <= '9' { Result::Ok((byte - '0').into()) } else { Result::Err(ParseError { message: \"Character is not a digit\" }) } }\n}\n\n// Using match\nfn multiply_match(first_number: ByteArray, second_number: ByteArray) -> Result<u32, ParseError> {\n    match parse_ascii_digit(first_number) {\n        Result::Ok(first_number) => {\n            match parse_ascii_digit(second_number) {\n                Result::Ok(second_number) => { Result::Ok(first_number * second_number) },\n                Result::Err(e) => Result::Err(e),\n            }\n        },\n        Result::Err(e) => Result::Err(e),\n    }\n}\n\n// Using and_then\nfn multiply(first_number: ByteArray, second_number: ByteArray) -> Result<u32, ParseError> {\n    parse_ascii_digit(first_number)\n        .and_then(|first_number| { parse_ascii_digit(second_number).map(|second_number| first_number * second_number) })\n}\n\nfn print(result: Result<u32, ParseError>) {\n    match result {\n        Result::Ok(n) => println!(\"n is {}\", n),\n        Result::Err(e) => println!(\"Error: {}\", e.message),\n    }\n}\n\nfn main() {\n    let twenty = multiply(\"4\", \"5\");\n    print(twenty);\n    let tt = multiply(\"t\", \"2\");\n    print(tt);\n}\n```\n\n## Destructuring\n`match` blocks can destructure enums and structs. Structs can also be destructured with `let` bindings.\n\n## Attributes\nMetadata applied to modules, crates, or items, e.g., `#[derive(Debug)]`.\n\n```cairo\n#[derive(Debug)]\nstruct Rectangle { width: u32, height: u32, }\n```\n\n## `TryInto` for Fallible Conversions\nThe `TryInto` trait is used for conversions that might fail, returning `Option<T>`.\n\n```cairo\n#[derive(Copy, Drop, Debug)]\nstruct EvenNumber { value: u32, }\n\nimpl U32IntoEvenNumber of TryInto<u32, EvenNumber> {\n    fn try_into(self: u32) -> Option<EvenNumber> {\n        if self % 2 == 0 { Option::Some(EvenNumber { value: self }) } else { Option::None }\n    }\n}\n\nfn main() {\n    let even: Option<EvenNumber> = 8_u32.try_into();\n    println!(\"{:?}\", even);\n    let odd: Option<EvenNumber> = 5_u32.try_into();\n    println!(\"{:?}\", odd);\n}\n```\n\n## Retaining Ownership\n- **Snapshots (`@T`)**: Immutable view into memory cells.\n- **References (`ref T`)**: Syntactic sugar for mutable ownership transfer.\n\n## `Result`\n`Result<T, E>` describes possible error (`Err(E)`) or success (`Ok(T)`).\n\n```cairo\n#[derive(Drop)]\nstruct ParseIntError { message: ByteArray, }\n\nfn char_to_number(c: ByteArray) -> Result<u8, ParseIntError> {\n    if c.len() != 1 { return Result::Err(ParseIntError { message: \"Expected a single character\" }); }\n    let byte = c[0];\n    Result::Ok(byte)\n}\n\nfn main() {\n    let result = char_to_number(\"a\");\n    match result {\n        Result::Ok(number) => println!(\"Number: 0x{:x}\", number),\n        Result::Err(error) => println!(\"Error: {}\", error.message),\n    }\n    let result = char_to_number(\"ab\");\n    match result {\n        Result::Ok(number) => println!(\"Number: 0x{:x}\", number),\n        Result::Err(error) => println!(\"Error: {}\", error.message),\n    }\n}\n```\n\n## Returning from loops\nA `loop` can return a value using `break`.\n\n```cairo\nfn main() {\n    let mut counter = 0;\n    let result = loop {\n        counter += 1;\n        if counter == 10 { break counter * 2; }\n    };\n    assert!(result == 20);\n}\n```\n\n## while\nThe `while` keyword runs a loop while a condition is true.\n\n```cairo\nfn main() {\n    let mut n = 1_u8;\n    while n < 101 {\n        if n % 15 == 0 { println!(\"fizzbuzz\"); }\n        else if n % 3 == 0 { println!(\"fizz\"); }\n        else if n % 5 == 0 { println!(\"buzz\"); }\n        else { println!(\"{}\", n); }\n        n += 1;\n    }\n}\n```\n\n## ByteArrays\n`ByteArray` is the main string type in Cairo, optimized for sequences of bytes. Can be concatenated with `+`.\n\n```cairo\nfn main() {\n    let pangram: ByteArray = \"the quick brown fox jumps over the lazy dog\";\n    println!(\"Pangram: {}\", pangram);\n\n    let mut chars = pangram.clone().into_iter();\n    for c in chars {\n        println!(\"ASCII: 0x{:x}\", c);\n    }\n\n    let alice: ByteArray = \"I like dogs\";\n    let bob: ByteArray = \"I like \" + \"cats\";\n    println!(\"Alice says: {}\", alice);\n    println!(\"Bob says: {}\", bob);\n}\n```\n\n## Testcase: List\nImplementing `fmt::Display` for custom types, using `write!` and the `?` operator for error propagation.\n\n```cairo\nuse core::fmt;\n\n#[derive(Drop)]\nstruct List { inner: Array<i32>, }\n\nimpl ListDisplay of fmt::Display<List> {\n    fn fmt(self: @List, ref f: fmt::Formatter) -> Result<(), fmt::Error> {\n        let array_span = self.inner.span();\n        write!(f, \"[\")?;\n        let mut count = 0;\n        loop {\n            if count >= array_span.len() { break Ok(()); }\n            if count != 0 { match write!(f, \", \") { Ok(_) => {}, Err(e) => { break Err(e); }, } }\n            match write!(f, \"{}\", *array_span[count]) { Ok(_) => {}, Err(e) => { break Err(e); }, }\n            count += 1;\n        }?;\n        write!(f, \"]\")\n    }\n}\n\nfn main() {\n    let mut arr = ArrayTrait::new();\n    arr.append(1);\n    arr.append(2);\n    arr.append(3);\n    let v = List { inner: arr };\n    println!(\"{}\", v);\n}\n```\n\n## Structures\nStructures (`struct`s) define custom data types with named fields. They can be instantiated, their fields accessed, and destructured.\n\n```cairo\n#[derive(Drop, Debug)]\nstruct Person { name: ByteArray, age: u8, }\n\n#[derive(Drop, Debug)]\nstruct Unit {}\n\n#[derive(Drop)]\nstruct Point { x: u32, y: u32, }\n\n#[derive(Drop)]\nstruct Rectangle { top_left: Point, bottom_right: Point, }\n\nfn main() {\n    let name: ByteArray = \"Peter\";\n    let age = 27;\n    let peter = Person { name, age };\n    println!(\"{:?}\", peter);\n\n    let point: Point = Point { x: 5, y: 0 };\n    let another_point: Point = Point { x: 10, y: 0 };\n    println!(\"point coordinates: ({}, {})\", point.x, point.y);\n\n    let bottom_right = Point { x: 10, ..another_point };\n    println!(\"second point: ({}, {})\", bottom_right.x, bottom_right.y);\n\n    let Point { x: left_edge, y: top_edge } = point;\n    let _rectangle = Rectangle { top_left: Point { x: left_edge, y: top_edge }, bottom_right: bottom_right, };\n    let _unit = Unit {};\n}\n```\n\n## structs (destructuring)\nStructs can be destructured directly or nested.\n\n```cairo\n#[derive(Copy, Drop)]\nstruct Foo { x: (u32, u32), y: u32, }\n\n#[derive(Drop)]\nstruct Bar { foo: Foo, }\n\nfn main() {\n    let _foo = Foo { x: (1, 2), y: 3 };\n    let faa = Foo { x: (1, 2), y: 3 };\n\n    let Foo { x: x0, y: y0 } = faa;\n    println!(\"Outside: x0 = {x0:?}, y0 = {y0}\");\n\n    let bar = Bar { foo: faa };\n    let Bar { foo: Foo { x: nested_x, y: nested_y } } = bar;\n    println!(\"Nested: nested_x = {nested_x:?}, nested_y = {nested_y:?}\");\n}\n```",
      "expected": "fn main() {\n    call_me(5);\n}\n\nfn call_me(num: u64) {\n    println!(\"num is {}\", num);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n```\n\nHint: This main function is calling a function that it expects to exist, but the\nfunction doesn't exist. It expects this function to have the name `call_me`.\nIt expects this function to not take any arguments and not return a value.\nSounds a lot like `main`, doesn't it?",
      "chat_history": "",
      "context": "In Cairo, functions are defined using the `fn` keyword, followed by the function name, a parenthesized list of parameters, an optional `-> ReturnType` indicating the return type, and a function body enclosed in curly braces.\n\n**Function Definition Syntax:**\n```cairo\nfn function_name(parameter1: Type1, parameter2: Type2) -> ReturnType {\n    // Function body\n}\n```\n\n**Functions with no arguments and no return value:**\nIf a function takes no arguments, the parentheses remain empty `()`. If a function does not return a value, the `-> ReturnType` part is omitted.\n\n**Examples of Function Definitions:**\n\n*   **Basic `main` function (no arguments, no return value):**\n    ```cairo\n    fn main() {\n        // Function body\n    }\n    ```\n\n*   **Function with arguments and a return value:**\n    ```cairo\n    fn parse_ascii_digit(value: @ByteArray) -> Result<u32, ParseError> {\n        // ...\n    }\n    ```\n\n*   **Function with arguments and a return value (another example):**\n    ```cairo\n    fn multiply(first_number: ByteArray, second_number: ByteArray) -> Result<u32, ParseError> {\n        // ...\n    }\n    ```\n\n*   **Function with arguments and no explicit return value (implicitly returns `()`):**\n    ```cairo\n    fn print(result: Result<u32, ParseError>) {\n        // ...\n    }\n    ```\n\n*   **Function with mutable arguments:**\n    ```cairo\n    fn modify_array_mut(mut mutable_array: Array<u8>) {\n        mutable_array.append(4);\n        println!(\"mutable_array now contains {:?}\", mutable_array);\n    }\n    ```",
      "expected": "fn main() {\n    call_me();\n}\n\nfn call_me() {\n    println!(\"Hello, world!\");\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num:) {\n    println!(\"num is {}\", num);\n}\n```\n\nHint: Cairo requires that all parts of a function's signature have type annotations,\nbut `call_me` is missing the type annotation of `num`. What is the basic type in Cairo?",
      "chat_history": "",
      "context": "Cairo function signatures require type annotations for all parameters. A common basic type used for numerical values in Cairo is `felt252`.\n\n**Examples of `felt252` usage in function signatures:**\n*   `pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;`\n\n**Other relevant function signature examples from `core` library:**\n*   `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n*   `fn span<T, T>(snapshot: @Array<T>) -> Span<T>`\n*   `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n*   `fn concat(left: ByteArray, right: ByteArray) -> ByteArray`\n*   `pub fn get_execution_info() -> Box<ExecutionInfo>`\n*   `fn append<T, T>(ref self: Array<T>, value: T)`\n*   `fn filter<T, T, P, +core::ops::FnOnce<P, (@T,)>>[Output: bool], +Destruct<T>, +Destruct<P>>(self: Option<T>, predicate: P) -> Option<T>`\n*   `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`",
      "expected": "fn main() {\n    call_me(3);\n}\n\nfn call_me(num: u32) {\n    println!(\"num is {}\", num);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    let number = 1_u8; // don't change this line\n    println!(\"number is {}\", number);\n    number = 3; // don't rename this variable\n    println!(\"number is {}\", number);\n}\n```\n\nHint: In variables4 we already learned how to make an immutable variable mutable\nusing a special keyword. Unfortunately this doesn't help us much in this exercise\nbecause we want to assign a different typed value to an existing variable. Sometimes\nyou may also like to reuse existing variable names because you are just converting\nvalues to different types like in this exercise.\nFortunately Cairo has a powerful solution to this problem: 'Shadowing'!\nYou can see an example of variables and 'shadowing' here: https://book.cairo-lang.org/ch02-01-variables-and-mutability.html?highlight=shadow#shadowing\nYou can read about the different integer types here: https://book.cairo-lang.org/ch02-02-data-types.html#integer-types\nTry to solve this exercise afterwards using this technique.",
      "chat_history": "",
      "context": "In Cairo, variables are immutable by default. Once a value is bound to a name, you cannot change that value. To make a variable mutable, you use the `mut` keyword. However, `mut` only allows changing the *value* of a variable, not its *type*.\n\n**Shadowing**\nCairo provides a feature called \"shadowing,\" which allows you to declare a *new* variable with the same name as a previous variable. This new variable \"shadows\" the old one, meaning the new variable is what the compiler will see when you use that name. This is particularly useful when you want to transform a value from one type to another but keep the same variable name.\n\n**Syntax for Shadowing:**\nYou use the `let` keyword again to declare the new variable, even if it has the same name.\n\n**Example of Shadowing:**\n```cairo\nfn main() {\n    let x = 5; // x is an integer\n    let x = x + 1; // x is shadowed, new x is 6\n    let x = \"hello\"; // x is shadowed again, new x is a string (different type)\n}\n```\n\n**Integer Types in Cairo:**\nCairo supports various integer types, which are specified using suffixes for literals:\n*   `u8`: 8-bit unsigned integer (e.g., `1_u8`)\n*   `u16`: 16-bit unsigned integer\n*   `u32`: 32-bit unsigned integer\n*   `u64`: 64-bit unsigned integer\n*   `u128`: 128-bit unsigned integer\n*   `u256`: 256-bit unsigned integer\n*   `felt252`: A field element, which is the native integer type in Cairo, representing values in the range `[0, P - 1]` where `P` is a large prime number. Literals without a suffix often default to `felt252` or infer based on context.\n\nWhen performing operations or assignments, ensure the types are compatible or explicitly cast/shadow to the desired type. Shadowing allows you to re-declare a variable with a different integer type, for example, changing from `u8` to `u32` or `felt252`.",
      "expected": "fn main() {\n    let mut number = 1_u8;\n    println!(\"number is {}\", number);\n    number = 3; // don't rename this variable\n    println!(\"number is {}\", number);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    let x = 3;\n    println!(\"x is {}\", x);\n    x = 5; // don't change this line\n    println!(\"x is now {}\", x);\n}\n```\n\nHint: In Cairo, variable bindings are immutable by default. But here we're trying\nto reassign a different value to x! There's a keyword we can use to make\na variable binding mutable instead.",
      "chat_history": "",
      "context": "In Cairo, variable bindings are immutable by default. To allow a variable to be reassigned or modified after its initial declaration, the `mut` keyword must be used.\n\nFor example, when declaring an array, `mut` is used to make it mutable:\n```cairo,editable\nfn main() {\n    // Initialize an empty mutable array\n    let mut arr = array![];\n\n    // Elements can be appended to a mutable array\n    arr.append(1);\n    arr.append(2);\n    arr.append(3);\n\n    println!(\"Array: {:?}\", arr);\n}\n```\n\nMutability of data can also be changed when ownership is transferred, such as when passing a variable to a function that expects a mutable parameter:\n```cairo,editable\nfn modify_array_mut(mut mutable_array: Array<u8>) {\n    mutable_array.append(4);\n    println!(\"mutable_array now contains {:?}\", mutable_array);\n}\n\nfn main() {\n    let immutable_array = array![1, 2, 3];\n\n    println!(\"immutable_array contains {:?}\", immutable_array);\n\n    // Attempting to modify an immutable variable directly would result in a mutability error:\n    // immutable_array.append(4); // This line would cause a compilation error\n\n    // *Move* the array, changing the ownership (and mutability)\n    modify_array_mut(immutable_array);\n}\n```\nWithout the `mut` keyword, attempting to reassign a value to a variable will result in a compilation error, as variables are immutable by default.",
      "expected": "fn main() {\n    let mut x = 3;\n    println!(\"x is {}\", x);\n    x = 5; // don't change this line\n    println!(\"x is now {}\", x);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    let x: felt252;\n    println!(\"x is {}\", x);\n}\n```\n\nHint: Oops! In this exercise, we have a variable binding that we've created on\nline 7, and we're trying to use it on line 8, but we haven't given it a\nvalue. We can't print out something that isn't there; try giving x a value!\nThis is an error that can cause bugs that's very easy to make in any\nprogramming language -- thankfully the Cairo compiler has caught this for us!",
      "chat_history": "",
      "context": "The provided context details various Cairo core library functionalities, including:\n*   **`SpanTrait`**: Provides methods for `Span<T>` such as `pop_front`, `pop_back`, `multi_pop_front`, `multi_pop_back`, `slice`, `len`, `get`, and `at`.\n    *   `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n    *   `fn multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n    *   `fn slice<T, T>(self: Span<T>, start: u32, length: u32) -> Span<T>`\n    *   `fn get<T, T>(self: Span<T>, index: u32) -> Option<Box<@T>>`\n*   **`ToSpanTrait`**: Converts a data structure into a span.\n    *   `fn span<C, T, C, T>(self: @C) -> Span<T>`\n*   **`ArrayTrait`**: Provides methods for `Array<T>`.\n    *   `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`\n    *   `fn pop_front<T, T>(ref self: Array<T>) -> Option<T>`\n*   **`OptionTrait`**: Provides methods for `Option<T>`.\n    *   `fn is_some<T, T>(self: @Option<T>) -> bool`\n    *   `is_some_and`\n*   **`ByteArrayTrait`**: Provides methods for `ByteArray`.\n    *   `fn concat(left: ByteArray, right: ByteArray) -> ByteArray`\n    *   `append_byte`\n*   **Starknet-specific functions**:\n    *   `core::starknet::testing::cheatcode`: `pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;`\n    *   `core::starknet::info::get_execution_info`: `pub fn get_execution_info() -> Box<ExecutionInfo>`\n    *   `core::starknet::info::get_contract_address`: `pub fn get_contract_address() -> ContractAddress`\n\nThe context does not provide information on how to declare and initialize basic variables like `felt252` outside of array or span contexts.",
      "expected": "fn main() {\n    let x: felt252 = 0;\n    println!(\"x is {}\", x);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n\nuse core::fmt::{Display, Formatter, Error};\n\n#[derive(Copy, Drop)]\nenum Message { // TODO: define the different variants used below\n}\n\n\nfn main() { // don't change any of the lines inside main\n    let mut messages: Array<Message> = ArrayTrait::new();\n\n    //don't change any of the next 4 lines\n    messages.append(Message::Quit);\n    messages.append(Message::Echo('hello world'));\n    messages.append(Message::Move((10, 30)));\n    messages.append(Message::ChangeColor((0, 255, 255)));\n\n    print_messages_recursive(messages, 0)\n}\n\n// Utility function to print messages. Don't modify these.\n\ntrait MessageTrait<T> {\n    fn call(self: T);\n}\n\nimpl MessageImpl of MessageTrait<Message> {\n    fn call(self: Message) {\n        println!(\"{}\", self);\n    }\n}\n\nfn print_messages_recursive(messages: Array<Message>, index: u32) {\n    if index >= messages.len() {\n        return ();\n    }\n    let message = *messages.at(index);\n    message.call();\n    print_messages_recursive(messages, index + 1)\n}\n\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        println!(\"___MESSAGE BEGINS___\");\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo(msg) => format!(\"{}\", msg),\n            Message::Move((a, b)) => { format!(\"{} {}\", a, b) },\n            Message::ChangeColor((red, green, blue)) => { format!(\"{} {} {}\", red, green, blue) },\n        };\n        f.buffer.append(@str);\n        println!(\"___MESSAGE ENDS___\");\n        Result::Ok(())\n    }\n}\n```\n\nHint: You can create enumerations that have different variants with different types\nsuch as no data, structs, a single felt string, tuples, ...etc\nhttps://book.cairo-lang.org/ch06-01-enums.html\n",
      "chat_history": "",
      "context": "Cairo supports defining enumerations with various types of variants, including those with no data, single data fields, or tuples. For example, the `Result` type is an enum with `Ok(T)` and `Err(E)` variants:\n```cairo\nenum Result<T, E> {\n   Ok: T,\n   Err: E,\n}\n```\nFunctions can return `Result` for expected and recoverable errors, as shown:\n```cairo\nfn parse_version(header: felt252) -> Result<felt252, felt252> {\n    match header {\n        0 => Ok(0),\n        1 => Ok(1),\n        _ => Err('invalid version'),\n    }\n}\n\nlet version = parse_version(1);\nmatch version {\n    Ok(v) => println!(\"working with version {}\", v),\n    Err(e) => println!(\"error parsing version: {:?}\", e)\n}\n```\n\n`ByteArray` is used for string literals. `ByteArrayTrait` provides functions like `concat`:\n```cairo\nfn concat(left: ByteArray, right: ByteArray) -> ByteArray\n```\nExample usage:\n```cairo\nlet ba = \"1\";\nlet other_ba = \"2\";\nlet result = ByteArrayTrait::concat(@ba, @other_ba);\nassert!(result == \"12\");\n```\n\nThe `Formatter` struct, used in `Display` trait implementations, has a `buffer` member of type `ByteArray`:\n```cairo\npub buffer: ByteArray\n```\n\nInteger types like `u32` are available for numerical data. Tuples are also supported for grouping multiple values, such as `(x, y)` coordinates or `(red, green, blue)` color components.",
      "expected": "use core::fmt::{Display, Formatter, Error};\n\n#[derive(Copy, Drop)]\nenum Message {\n    Quit,\n    Echo: felt252,\n    Move: (u32, u32),\n    ChangeColor: (u8, u8, u8),\n}\n\n\nfn main() { // don't change any of the lines inside main\n    let mut messages: Array<Message> = ArrayTrait::new();\n\n    //don't change any of the next 4 lines\n    messages.append(Message::Quit);\n    messages.append(Message::Echo('hello world'));\n    messages.append(Message::Move((10, 30)));\n    messages.append(Message::ChangeColor((0, 255, 255)));\n\n    print_messages_recursive(messages, 0)\n}\n\n// Utility function to print messages. Don't modify these.\n\ntrait MessageTrait<T> {\n    fn call(self: T);\n}\n\nimpl MessageImpl of MessageTrait<Message> {\n    fn call(self: Message) {\n        println!(\"{}\", self);\n    }\n}\n\nfn print_messages_recursive(messages: Array<Message>, index: u32) {\n    if index >= messages.len() {\n        return ();\n    }\n    let message = *messages.at(index);\n    message.call();\n    print_messages_recursive(messages, index + 1)\n}\n\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        println!(\"___MESSAGE BEGINS___\");\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo(msg) => format!(\"{}\", msg),\n            Message::Move((a, b)) => { format!(\"{} {}\", a, b) },\n            Message::ChangeColor((red, green, blue)) => { format!(\"{} {} {}\", red, green, blue) },\n        };\n        f.buffer.append(@str);\n        println!(\"___MESSAGE ENDS___\");\n        Result::Ok(())\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n    //TODO make the test pass without changing any existing line\n    loop {\n        break ();\n        counter += 1;\n    };\n    assert(counter == 10, 'counter should be 10')\n}\n```\n\nHint: The `break` condition is reached too early. Can you introduce a condition so that the loop runs a little more?",
      "chat_history": "",
      "context": "# Flow of Control\n\nCairo provides several constructs for controlling program flow, including `if`/`else`, `for`, `while`, and `loop`.\n\n## `loop`\n\nThe `loop` keyword creates an infinite loop. This loop can be exited using the `break` keyword. A `loop` can also return a value by placing it after the `break` keyword.\n\n### Returning from loops\n\nA `loop` can be used to retry an operation until it succeeds. If the operation returns a value, it can be passed after the `break` keyword, and it will be returned by the `loop` expression.\n\n**Example:**\n```cairo\nfn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    assert!(result == 20);\n}\n```\n\n## `if`/`else`\n\nThe `if` and `else` keywords are used for conditional execution.\n\n**Example (conceptual, from `for` loop context):**\n```cairo\nif n % 15 == 0 {\n    println!(\"fizzbuzz\");\n} else if n % 3 == 0 {\n    println!(\"fizz\");\n} else if n % 5 == 0 {\n    println!(\"buzz\");\n} else {\n    println!(\"{}\", n);\n}\n```\n\n## `for` and `range`\n\nThe `for in` construct iterates through an `Iterator`. Ranges like `a..b` (exclusive) or `a..=b` (inclusive) can create iterators.\n\n**Example:**\n```cairo\nfn main() {\n    // `n` will take the values: 1, 2, ..., 100 in each iteration\n    for n in 1..= 100_u8 {\n        if n % 15 == 0 {\n            println!(\"fizzbuzz\");\n        } else if n % 3 == 0 {\n            println!(\"fizz\");\n        } else if n % 5 == 0 {\n            println!(\"buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n    }\n}\n```\n\n## `while`\n\nThe `while` keyword runs a loop as long as a condition is true.\n\n**Example:**\n```cairo\nfn main() {\n    let mut n = 1_u8;\n    while n < 101 {\n        if n % 15 == 0 {\n            println!(\"fizzbuzz\");\n        } else if n % 3 == 0 {\n            println!(\"fizz\");\n        } else if n % 5 == 0 {\n            println!(\"buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n        n += 1;\n    }\n}\n```",
      "expected": "#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n    //TODO make the test pass without changing any existing line\n    loop {\n        counter += 1;\n        if counter == 10 {\n            break ();\n        }\n    };\n    assert(counter == 10, 'counter should be 10')\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n// These modules have some issues, can you fix them?\n\nconst YEAR: u16 = 2050;\n\npub mod order {\n    #[derive(Copy, Drop)]\n    pub struct Order {\n        pub name: felt252,\n        pub year: u16,\n        pub made_by_phone: bool,\n        pub made_by_email: bool,\n        pub item: felt252,\n    }\n\n    pub fn new_order(name: felt252, made_by_phone: bool, item: felt252) -> Order {\n        Order { name, year: YEAR, made_by_phone, made_by_email: !made_by_phone, item,  }\n    }\n}\n\npub mod order_utils {\n    pub fn dummy_phoned_order(name: felt252) -> Order {\n        new_order(name, true, 'item_a')\n    }\n\n    pub fn dummy_emailed_order(name: felt252) -> Order {\n        new_order(name, false, 'item_a')\n    }\n\n    pub fn order_fees(order: Order) -> felt252 {\n        if order.made_by_phone {\n            return 500;\n        }\n\n        200\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_array() {\n    let order1 = order_utils::dummy_phoned_order('John Doe');\n    let fees1 = order_utils::order_fees(order1);\n    assert(fees1 == 500, 'Order fee should be 500');\n\n    let order2 = order_utils::dummy_emailed_order('Jane Doe');\n    let fees2 = order_utils::order_fees(order2);\n    assert(fees2 == 200, 'Order fee should be 200');\n}\n```\n\nHint: While using functions/structs and other items from outside the module,\nyou can refer to them with their full path or import them in the current context with the use keyword.\n",
      "chat_history": "",
      "context": "The provided `raw_context` is a 404 error page and contains no relevant technical documentation or code examples regarding Cairo's module system, `use` keyword, or path resolution.",
      "expected": "// These modules have some issues, can you fix them?\n\nconst YEAR: u16 = 2050;\n\npub mod order {\n    #[derive(Copy, Drop)]\n    pub struct Order {\n        pub name: felt252,\n        pub year: u16,\n        pub made_by_phone: bool,\n        pub made_by_email: bool,\n        pub item: felt252,\n    }\n\n    pub fn new_order(name: felt252, made_by_phone: bool, item: felt252) -> Order {\n        Order { name, year: super::YEAR, made_by_phone, made_by_email: !made_by_phone, item,  }\n    }\n}\n\npub mod order_utils {\n    use super::order::{new_order, Order};\n\n    pub fn dummy_phoned_order(name: felt252) -> Order {\n        new_order(name, true, 'item_a')\n    }\n\n    pub fn dummy_emailed_order(name: felt252) -> Order {\n        new_order(name, false, 'item_a')\n    }\n\n    pub fn order_fees(order: Order) -> felt252 {\n        if order.made_by_phone {\n            return 500;\n        }\n\n        200\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_array() {\n    let order1 = order_utils::dummy_phoned_order('John Doe');\n    let fees1 = order_utils::order_fees(order1);\n    assert(fees1 == 500, 'Order fee should be 500');\n\n    let order2 = order_utils::dummy_emailed_order('Jane Doe');\n    let fees2 = order_utils::order_fees(order2);\n    assert(fees2 == 200, 'Order fee should be 200');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\n// This exercise won't compile... Can you make it compile?\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "An integral part of any programming language are ways to modify control flow, and Cairo handles these constructs. The `fn main()` function is the entry point for a Cairo program.\n\nPrinting is handled by a series of macros defined in `core::fmt`, including `println!`, which prints formatted text to the console and appends a newline. All parse text in the same fashion, and Cairo checks formatting correctness at compile time.\n\n**Example of `fn main` and `println!`:**\n```cairo\nfn main() {\n    // In general, the `{}` will be automatically replaced with any\n    // arguments. These will be stringified.\n    println!(\"{} days\", 31);\n\n    // Positional arguments can be used. Specifying an integer inside `{}`\n    // determines which additional argument will be replaced. Arguments start\n    // at 0 immediately after the format string.\n    let alice: ByteArray = \"Alice\";\n    let bob: ByteArray = \"Bob\";\n    println!(\"{0}, this is {1}. {1}, this is {0}\", alice, bob);\n\n    // Different formatting can be invoked by specifying the format character\n    // after a `:`. \n    println!(\"Base 10:               {}\", 69420); // 69420\n    println!(\"Base 16 (hexadecimal): {:x}\", 69420); // 10f2c\n\n    // Cairo even checks to make sure the correct number of arguments are used.\n    let bond: ByteArray = \"Bond\";\n    println!(\"My name is {0}, James {0}\", bond);\n}\n```\n\nThe main string type in Cairo is `ByteArray`, an optimized data structure for sequences of bytes, primarily used for strings.\n\n**Example of `ByteArray` usage:**\n```cairo\nfn main() {\n    let pangram: ByteArray = \"the quick brown fox jumps over the lazy dog\";\n    println!(\"Pangram: {}\", pangram);\n\n    // ByteArray can be concatenated using the + operator\n    let alice: ByteArray = \"I like dogs\";\n    let bob: ByteArray = \"I like \" + \"cats\";\n\n    println!(\"Alice says: {}\", alice);\n    println!(\"Bob says: {}\", bob);\n}\n```",
      "expected": "// This exercise won't compile... Can you make it compile?\n\nfn main() {\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// I AM NOT DONE\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    //TODO fix the error here without modifying this line.\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\n\nHint: So you've got the \"ref argument must be a mutable variable.\" error on line 17,\nright? The fix for this is going to be adding one keyword, and the addition is NOT on line 17\nwhere the error is.\n\nAlso: Try accessing `arr0` after having called `fill_arr()`. See what happens!\n\nRead more about move semantics and ownership here: https://book.cairo-lang.org/ch04-01-what-is-ownership.html\n",
      "chat_history": "",
      "context": "The Cairo `core::array::ArrayTrait` provides methods for manipulating arrays. For methods that modify the array in place, such as `append` or `append_span`, the `self` parameter must be a mutable reference (`ref self: Array<T>`). This requires the array instance on which the method is called to be declared as mutable using the `mut` keyword.\n\n**Examples of mutable operations:**\n*   `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>` (from `core::array::SpanTrait`)\n*   `fn append_word(ref self: ByteArray, word: felt252, len: u32)` (from `core::byte_array::ByteArrayTrait`)\n*   `fn append_keys_and_data<T, T>(self: @T, ref keys: Array<felt252>, ref data: Array<felt252>)` (from `core::starknet::event::Event`)\n*   `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)` (from `core::array::ArrayTrait`)\n\nWhen working with `Array`s and ownership, if an `Array` is intended to be mutable throughout its lifecycle, it should be declared mutable at its initial creation. Even if an immutable `Array` is moved into a function and rebound to a mutable local variable (`let mut arr = arr;`), or returned and assigned to a mutable variable (`let mut arr1 = fill_arr(arr0);`), the underlying `Array` object might retain an immutable characteristic if its initial binding was immutable. To ensure full mutability for methods requiring `ref self`, the `Array` should be initialized with `mut`.\n\n**Example of `mut` usage:**\n```cairo\nlet mut span = array![1, 2, 3].span();\nassert!(span.pop_front() == Some(@1));\n```\nThis demonstrates that `span` must be `mut` to call `pop_front` which takes `ref self`.",
      "expected": "fn main() {\n    let mut arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    //TODO fix the error here without modifying this line.\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n\n}\n\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Integer types implement basic comparison and arithmetic operators.\n// Felt252 operations should be avoided where possible, as they could have unwanted behavior.\n\n// I AM NOT DONE\n\n\nfn poly(x: usize, y: usize) -> usize {\n    // Return the solution of x^3 + y - 2\n    // FILL ME\n    res // Do not change\n}\n\n\n// Do not change the test function\n#[cfg(test)]\n#[test]\nfn test_poly() {\n    let res = poly(5, 3);\n    assert(res == 126, 'Error message');\n    assert(res < 300, 'res < 300');\n    assert(res <= 300, 'res <= 300');\n    assert(res > 20, 'res > 20');\n    assert(res >= 2, 'res >= 2');\n    assert(res != 27, 'res != 27');\n    assert(res % 2 == 0, 'res %2 != 0');\n}\n```\n\nHint: You can check the list of available operators here:\nhttps://book.cairo-lang.org/appendix-02-operators-and-symbols.html\n",
      "chat_history": "",
      "context": "The provided context details various functionalities within the Cairo core library, including:\n\n*   **`core::array::SpanTrait`**:\n    *   `pop_front<T, T>(ref self: Span<T>) -> Option<@T>`: Pops a value from the front of a span.\n    *   `pop_back<T, T>(ref self: Span<T>) -> Option<@T>`: Pops a value from the back of a span.\n    *   `multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`: Pops multiple values from the front.\n    *   `multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`: Pops multiple values from the back.\n    *   `slice<T, T>(self: Span<T>, start: u32, length: u32) -> Span<T>`: Returns a sub-span.\n    *   `at<T, T>(self: Span<T>, index: u32) -> @T`: Returns a snapshot of the element at a given index.\n    *   `len()`: Returns the length of the span as a `usize`.\n*   **`core::array::ToSpanTrait`**:\n    *   `span<C, T, C, T>(self: @C) -> Span<T>`: Converts a data structure into a span.\n*   **`core::array::ArrayTrait`**:\n    *   `append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`: Appends a span to an array.\n    *   `pop_front`: Pops a value from the front of an array.\n*   **`core::byte_array::ByteArrayTrait` (and `ByteArrayImpl`)**:\n    *   `append_word(ref self: ByteArray, word: felt252, len: u32)`: Appends a word to a byte array.\n    *   `append(ref self: ByteArray, other: ByteArray)`: Appends another `ByteArray`.\n    *   `concat(left: ByteArray, right: ByteArray) -> ByteArray`: Concatenates two `ByteArray`s.\n    *   `append_byte`: Appends a single byte.\n*   **`core::starknet::testing::cheatcode`**:\n    *   `pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;`: Returns a span containing the cheatcode's output.\n*   **`core::starknet::storage::vec::MutableVecTrait`**:\n    *   `allocate<T, T>(self: T) -> StoragePath<Mutable<MutableVecTrait<T>ElementType>>`: Allocates space for a nested vector in storage.\n    *   `push`: Pushes a new value onto the vector, incrementing length and writing to storage.\n*   **`core::starknet::info::get_execution_info`**:\n    *   `pub fn get_execution_info() -> Box<ExecutionInfo>`: Returns a boxed `ExecutionInfo` containing caller address, contract address, entry point selector, etc.\n\nThe context does not provide information on basic arithmetic operators (`+`, `-`, `*`, `/`, `%`) or exponentiation for `usize` or other integer types in Cairo.",
      "expected": "// Integer types implement basic comparison and arithmetic operators.\n// Felt252 operations should be avoided where possible, as they could have unwanted behavior.\n\n\n\n\nfn poly(x: usize, y: usize) -> usize {\n    // Return the solution of x^3 + y - 2\n    let res = x * x * x + y - 2;\n    res // Do not change\n}\n\n\n// Do not change the test function\n#[cfg(test)]\n#[test]\nfn test_poly() {\n    let res = poly(5, 3);\n    assert(res == 126, 'Error message');\n    assert(res < 300, 'res < 300');\n    assert(res <= 300, 'res <= 300');\n    assert(res > 20, 'res > 20');\n    assert(res >= 2, 'res >= 2');\n    assert(res != 27, 'res != 27');\n    assert(res % 2 == 0, 'res %2 != 0');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Joe liked Jill's work very much. He really likes how useful storage can be.\n// Now they decided to write a contract to track the number of exercises they\n// complete successfully. Jill says they can use the owner code and allow\n// only the owner to update the contract, they agree.\n// Can you help them write this contract?\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IProgressTracker<TContractState> {\n    fn set_progress(ref self: TContractState, user: ContractAddress, new_progress: u16);\n    fn get_progress(self: @TContractState, user: ContractAddress) -> u16;\n    fn get_contract_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod ProgressTracker {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address; // Required to use get_caller_address function\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        // TODO: Set types for Map\n        progress: Map<>\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl ProgressTrackerImpl of super::IProgressTracker<ContractState> {\n        fn set_progress(\n            ref self: ContractState, user: ContractAddress, new_progress: u16\n        ) { // TODO: assert owner is calling\n        // TODO: set new_progress for user,\n        }\n\n        fn get_progress(self: @ContractState, user: ContractAddress) -> u16 { // Get user progress\n        }\n\n        fn get_contract_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::IProgressTrackerDispatcher;\n    use super::IProgressTrackerDispatcherTrait;\n    use super::ProgressTracker;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Sensei'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n        assert(owner == dispatcher.get_contract_owner(), 'Mr. Sensei should be the owner');\n    }\n\n    #[test]\n    fn test_set_progress() {\n        let owner = util_felt_addr('Sensei');\n        let dispatcher = deploy_contract();\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Set progress\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n        dispatcher.set_progress('Jill'.try_into().unwrap(), 25);\n\n        let joe_score = dispatcher.get_progress('Joe'.try_into().unwrap());\n        assert(joe_score == 20, 'Joe\\'s progress should be 20');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_progress_fail() {\n        let dispatcher = deploy_contract();\n\n        let jon_doe = util_felt_addr('JonDoe');\n        // Caller not owner\n        start_cheat_caller_address(dispatcher.contract_address, jon_doe);\n\n        // Try to set progress, should panic to pass test!\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> IProgressTrackerDispatcher {\n        let owner: felt252 = 'Sensei';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"ProgressTracker\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        IProgressTrackerDispatcher { contract_address }\n    }\n}\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "The provided context includes documentation for `core::array::SpanTrait` functions (`pop_front`, `pop_back`, `multi_pop_front`, `multi_pop_back`, `get`), `core::array::ArrayTrait` functions (`span`, `append`, `append_span`), `core::byte_array::ByteArrayTrait` functions (`append_word`, `append`, `concat`), and `core::starknet::testing` functions (`cheatcode`, `pop_log`). It also mentions `core::starknet::info::get_contract_address`. None of these directly address the requirements for defining a `Map` storage type, using `starknet::get_caller_address` for access control, or implementing `assert` statements within a contract.",
      "expected": "// Joe liked Jill's work very much. He really likes how useful storage can be.\n// Now they decided to write a contract to track the number of exercises they\n// complete successfully. Jill says they can use the owner code and allow\n// only the owner to update the contract, they agree.\n// Can you help them write this contract?\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IProgressTracker<TContractState> {\n    fn set_progress(ref self: TContractState, user: ContractAddress, new_progress: u16);\n    fn get_progress(self: @TContractState, user: ContractAddress) -> u16;\n    fn get_contract_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod ProgressTracker {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address; // Required to use get_caller_address function\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map, StorageMapReadAccess, StorageMapWriteAccess};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        progress: Map<ContractAddress, u16>\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl ProgressTrackerImpl of super::IProgressTracker<ContractState> {\n        fn set_progress(\n            ref self: ContractState, user: ContractAddress, new_progress: u16\n        ) {\n            // Assert owner is calling\n            let caller = get_caller_address();\n            let owner = self.contract_owner.read();\n            assert(caller == owner, 'Only owner can set progress');\n\n            // Set new_progress for user\n            self.progress.write(user, new_progress);\n        }\n\n        fn get_progress(self: @ContractState, user: ContractAddress) -> u16 {\n            // Get user progress\n            self.progress.read(user)\n        }\n\n        fn get_contract_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::IProgressTrackerDispatcher;\n    use super::IProgressTrackerDispatcherTrait;\n    use super::ProgressTracker;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Sensei'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n        assert(owner == dispatcher.get_contract_owner(), 'Mr. Sensei should be the owner');\n    }\n\n    #[test]\n    fn test_set_progress() {\n        let owner = util_felt_addr('Sensei');\n        let dispatcher = deploy_contract();\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Set progress\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n        dispatcher.set_progress('Jill'.try_into().unwrap(), 25);\n\n        let joe_score = dispatcher.get_progress('Joe'.try_into().unwrap());\n        assert(joe_score == 20, 'Joe\\'s progress should be 20');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_progress_fail() {\n        let dispatcher = deploy_contract();\n\n        let jon_doe = util_felt_addr('JonDoe');\n        // Caller not owner\n        start_cheat_caller_address(dispatcher.contract_address, jon_doe);\n\n        // Try to set progress, should panic to pass test!\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> IProgressTrackerDispatcher {\n        let owner: felt252 = 'Sensei';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"ProgressTracker\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        IProgressTrackerDispatcher { contract_address }\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Joe's contract in the last exercise showed that Joe is the owner of the contract.\n// He thanks you for helping him out!\n// Jill says that contract should allow setting the owner when contract is deployed.\n// Help Jill rewrite the contract with a Storage and a constructor.\n// There is a `ContractAddress` type which should be used for Wallet addresses.\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::contract]\nmod JillsContract {\n    // This is required to use ContractAddress type\n    use starknet::ContractAddress;\n\n    #[storage]\n    struct Storage { // TODO: Add `contract_owner` storage, with ContractAddress type\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, owner: ContractAddress,\n    ) { // TODO: Write `owner` to contract_owner storage\n    }\n\n    #[abi(embed_v0)]\n    impl IJillsContractImpl of super::IJillsContract<ContractState> {\n        fn get_owner(self: @ContractState) -> ContractAddress { // TODO: Read contract_owner storage\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IJillsContract<TContractState> {\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{ContractClassTrait, DeclareResultTrait, declare};\n    use super::{IJillsContractDispatcher, IJillsContractDispatcherTrait, JillsContract};\n\n    #[test]\n    fn test_owner_setting() {\n        let mut calldata = ArrayTrait::new();\n        calldata.append('Jill');\n\n        let contract = declare(\"JillsContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        let dispatcher = IJillsContractDispatcher { contract_address };\n        let owner = dispatcher.get_owner();\n        assert(owner == 'Jill'.try_into().unwrap(), 'Owner should be Jill');\n    }\n}\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "### Control Flow: `for` and `while` Loops\nCairo supports `for` loops for iterating over `Iterator`s, commonly used with range notation `a..b` (exclusive end) or `a..=b` (inclusive end).\n```cairo\nfn main() {\n    for n in 1..101_u8 { /* ... */ }\n    for n in 1..= 100_u8 { /* ... */ }\n}\n```\nThe `while` keyword runs a loop as long as a condition is true.\n```cairo\nfn main() {\n    let mut n = 1_u8;\n    while n < 101 { /* ... */ n += 1; }\n}\n```\nLoops can return values using `break`.\n```cairo\nfn main() {\n    let mut counter = 0;\n    let result = loop {\n        counter += 1;\n        if counter == 10 { break counter * 2; }\n    };\n    assert!(result == 20);\n}\n```\n\n### Data Structures: Arrays, Spans, and Fixed-Size Arrays\nAn `Array` is a growable collection of same-type objects in contiguous memory. Values cannot be modified; only appending elements (`append`) or removing from the front (`pop_front`) is allowed. `len()` returns the number of elements. Indexing starts at 0.\nA `Span` is an immutable snapshot of an `Array` at a specific state.\nA Fixed-Size Array is an immutable sequence of elements with compile-time known size and contents. They can be converted to spans.\n```cairo\nfn main() {\n    let mut arr = array![];\n    arr.append(1);\n    arr.append(2);\n    arr.append(3);\n    println!(\"First element of the array: {}\", *arr[0]);\n    println!(\"Number of elements in the array: {}\", arr.len());\n    let span = arr.span();\n    let _ = arr.pop_front();\n    println!(\"First element in span: {}\", *span[0]);\n\n    let xs: [u32; 3] = [1, 2, 3];\n    let ys: [u32; 3] = [0; 3]; // All elements initialized to 0\n    println!(\"xs: {:?}\", xs);\n    println!(\"ys: {:?}\", ys);\n    println!(\"ys first element: {}\", *xs.span()[0]);\n}\n```\n\n### Error Handling: `Result` and `Option`\n`Result<T, E>` describes possible success (`Ok(T)`) or error (`Err(E)`). `Option<T>` describes possible presence (`Some(T)`) or absence (`None`). Both have combinators like `map` and `and_then`. `unwrap()` yields the element or panics.\n```cairo\n#[derive(Drop, Debug)]\nstruct ParseError { message: ByteArray, }\n\nfn parse_ascii_digit(value: @ByteArray) -> Result<u32, ParseError> {\n    if value.len() != 1 { Result::Err(ParseError { message: \"Expected a single character\" }) }\n    else {\n        let byte = value[0];\n        if byte >= '0' && byte <= '9' { Result::Ok((byte - '0').into()) }\n        else { Result::Err(ParseError { message: \"Character is not a digit\" }) }\n    }\n}\n\nfn double_first(arr: Array<ByteArray>) -> Option<Result<u32, ParseError>> {\n    arr.get(0).map(|first| { parse_ascii_digit(first.unbox()).map(|n| 2 * n) })\n}\n\nfn multiply(first_number: ByteArray, second_number: ByteArray) -> Result<u32, ParseError> {\n    parse_ascii_digit(first_number)\n        .and_then(|first_number| {\n            parse_ascii_digit(second_number).map(|second_number| first_number * second_number)\n        })\n}\n\nfn print(result: Result<u32, ParseError>) {\n    match result {\n        Result::Ok(n) => println!(\"n is {}\", n),\n        Result::Err(e) => println!(\"Error: {}\", e.message),\n    }\n}\n\nfn main() {\n    let numbers = array![\"4\", \"9\", \"1\"];\n    println!(\"The first doubled is {:?}\", double_first(numbers)); // Some(Ok(8))\n    let twenty = multiply(\"4\", \"5\");\n    print(twenty); // n is 20\n    let tt = multiply(\"t\", \"2\");\n    print(tt); // Error: Character is not a digit\n}\n```\nThe `?` operator can be used for early returns on `Err` values, but it does not work inside loops.\n```cairo\nuse core::fmt;\n#[derive(Drop)]\nstruct List { inner: Array<i32>, }\nimpl ListDisplay of fmt::Display<List> {\n    fn fmt(self: @List, ref f: fmt::Formatter) -> Result<(), fmt::Error> {\n        let array_span = self.inner.span();\n        write!(f, \"[\")?;\n        let mut count = 0;\n        loop {\n            if count >= array_span.len() { break Ok(()); }\n            if count != 0 { match write!(f, \", \") { Ok(_) => {}, Err(e) => { break Err(e); }, } }\n            match write!(f, \"{}\", *array_span[count]) { Ok(_) => {}, Err(e) => { break Err(e); }, }\n            count += 1;\n        }?;\n        write!(f, \"]\")\n    }\n}\nfn main() {\n    let mut arr = ArrayTrait::new(); arr.append(1); arr.append(2); arr.append(3);\n    let v = List { inner: arr }; println!(\"{}\", v); // [1, 2, 3]\n}\n```\n\n### Formatted Printing\nMacros like `format!`, `print!`, `println!` handle formatted text. `println!` appends a newline. Arguments are stringified. Positional arguments can be used (`{0}`). Different formatting can be invoked with `{:x}` for hexadecimal. Cairo checks formatting correctness at compile time.\n`fmt::Display` (`{}`) is for user-friendly output, `fmt::Debug` (`{:?}`) for debugging. Custom types require implementing these traits.\n```cairo\nstruct Structure { inner: i32, }\nfn main() {\n    println!(\"{} days\", 31);\n    let alice: ByteArray = \"Alice\"; let bob: ByteArray = \"Bob\";\n    println!(\"{0}, this is {1}. {1}, this is {0}\", alice, bob);\n    println!(\"Base 10:               {}\", 69420); // 69420\n    println!(\"Base 16 (hexadecimal): {:x}\", 69420); // 10f2c\n    let bond: ByteArray = \"Bond\";\n    println!(\"My name is {0}, James {0}\", bond); // Fixed: added \"James\"\n    // println!(\"This struct `{}` won't print...\", Structure(3)); // Will not compile without fmt::Display\n}\n```\n\n### Attributes\nAttributes (`#[outer_attribute]`) are metadata applied to modules, crates, or items (functions, structs, etc.). They can be used for conditional compilation, disabling lints, enabling compiler features, or marking tests. Attributes can take arguments: `#[attribute(key: \"value\")]` or `#[attribute(value)]`.\n```cairo\n#[derive(Debug)]\nstruct Rectangle { width: u32, height: u32, }\n```\n\n### Ownership and Mutability\nData mutability can change when ownership is transferred.\n- `Snapshots` (`@T`): Immutable view into memory cells.\n- `References` (`ref T`): Syntactic sugar for a variable whose ownership is transferred, can be mutated, and returned.\n```cairo\nfn modify_array_mut(mut mutable_array: Array<u8>) {\n    mutable_array.append(4);\n    println!(\"mutable_array now contains {:?}\", mutable_array);\n}\nfn main() {\n    let immutable_array = array![1, 2, 3];\n    println!(\"immutable_array contains {:?}\", immutable_array);\n    // immutable_array.append(4); // Mutability error\n    modify_array_mut(immutable_array); // Moves ownership, allowing mutation\n}\n```\n\n### Structures (`struct`)\nStructures are created using the `struct` keyword. They can have fields and can be nested.\n```cairo\n#[derive(Drop, Debug)]\nstruct Person { name: ByteArray, age: u8, }\n#[derive(Drop, Debug)]\nstruct Unit {} // An empty struct\n#[derive(Drop)]\nstruct Point { x: u32, y: u32, }\n#[derive(Drop)]\nstruct Rectangle { top_left: Point, bottom_right: Point, }\n\nfn main() {\n    let name: ByteArray = \"Peter\"; let age = 27;\n    let peter = Person { name, age }; // Field init shorthand\n    println!(\"{:?}\", peter);\n\n    let point: Point = Point { x: 5, y: 0 };\n    println!(\"point coordinates: ({}, {})\", point.x, point.y);\n\n    let another_point: Point = Point { x: 10, y: 0 };\n    let bottom_right = Point { x: 10, ..another_point }; // Struct update syntax\n    println!(\"second point: ({}, {})\", bottom_right.x, bottom_right.y);\n\n    let Point { x: left_edge, y: top_edge } = point; // Destructuring\n    let _rectangle = Rectangle { top_left: Point { x: left_edge, y: top_edge }, bottom_right: bottom_right, };\n    let _unit = Unit {};\n}\n```\n\n### ByteArrays\n`ByteArray` is the main string type in Cairo, optimized for sequences of bytes. It supports concatenation (`+`) and iteration.\n```cairo\nfn main() {\n    let pangram: ByteArray = \"the quick brown fox jumps over the lazy dog\";\n    println!(\"Pangram: {}\", pangram);\n    let mut chars = pangram.clone().into_iter();\n    for c in chars { println!(\"ASCII: 0x{:x}\", c); }\n    let alice: ByteArray = \"I like dogs\";\n    let bob: ByteArray = \"I like \" + \"cats\";\n    println!(\"Alice says: {}\", alice);\n    println!(\"Bob says: {}\", bob);\n}\n```",
      "expected": "// Joe's contract in the last exercise showed that Joe is the owner of the contract.\n// He thanks you for helping him out!\n// Jill says that contract should allow setting the owner when contract is deployed.\n// Help Jill rewrite the contract with a Storage and a constructor.\n// There is a `ContractAddress` type which should be used for Wallet addresses.\n\nuse starknet::ContractAddress;\n\n#[starknet::contract]\nmod JillsContract {\n    // This is required to use ContractAddress type\n    use starknet::ContractAddress;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, owner: ContractAddress\n    ) {\n        self.contract_owner.write(owner);\n    }\n\n    #[abi(embed_v0)]\n    impl IJillsContractImpl of super::IJillsContract<ContractState> {\n        fn get_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IJillsContract<TContractState> {\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[cfg(test)]\nmod test {\n    use super::IJillsContractDispatcher;\n    use super::IJillsContractDispatcherTrait;\n    use super::JillsContract;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n\n    #[test]\n    fn test_owner_setting() {\n        let mut calldata = ArrayTrait::new();\n        calldata.append('Jill');\n\n        let contract = declare(\"JillsContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        let dispatcher = IJillsContractDispatcher { contract_address };\n        let owner = dispatcher.get_owner();\n        assert(owner == 'Jill'.try_into().unwrap(), 'Owner should be Jill');\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Liz, a friend of Jill, wants to manage inventory for her store on-chain.\n// This is a bit challenging for Joe and Jill, Liz prepared an outline\n// for how contract should work, can you help Jill and Joe write it?\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait ILizInventory<TContractState> {\n    fn add_stock(ref self: TContractState, product: felt252, new_stock: u32);\n    fn purchase(ref self: TContractState, product: felt252, quantity: u32);\n    fn get_stock(self: @TContractState, product: felt252) -> u32;\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod LizInventory {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        // TODO: add storage inventory, that maps product (felt252) to stock quantity (u32)\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl LizInventoryImpl of super::ILizInventory<ContractState> {\n        fn add_stock(ref self: ContractState, ) {\n            // TODO:\n            // * takes product and new_stock\n            // * adds new_stock to stock in inventory\n            // * only owner can call this\n        }\n\n        fn purchase(ref self: ContractState, ) {\n            // TODO:\n            // * takes product and quantity\n            // * subtracts quantity from stock in inventory\n            // * anybody can call this\n        }\n\n        fn get_stock(self: @ContractState, ) -> u32 {\n            // TODO:\n            // * takes product\n            // * returns product stock in inventory\n        }\n\n        fn get_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::LizInventory;\n    use super::ILizInventoryDispatcher;\n    use super::ILizInventoryDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Elizabeth'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n\n        // Check that contract owner is set\n        let contract_owner = dispatcher.get_owner();\n        assert(contract_owner == owner, 'Elizabeth should be the owner');\n    }\n\n    #[test]\n    fn test_stock() {\n        let dispatcher = deploy_contract();\n        let owner = util_felt_addr('Elizabeth');\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 10, 'stock should be 10');\n\n        dispatcher.add_stock('Nano', 15);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 25, 'stock should be 25');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    fn test_stock_purchase() {\n        let owner = util_felt_addr('Elizabeth');\n        let dispatcher = deploy_contract();\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 10, 'stock should be 10');\n\n        // Call contract as different address\n        stop_cheat_caller_address(dispatcher.contract_address);\n        start_cheat_caller_address(dispatcher.contract_address, 0.try_into().unwrap());\n\n        dispatcher.purchase('Nano', 2);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 8, 'stock should be 8');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_stock_fail() {\n        let dispatcher = deploy_contract();\n        // Try to add stock, should panic to pass test!\n        dispatcher.add_stock('Nano', 20);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_purchase_out_of_stock() {\n        let dispatcher = deploy_contract();\n        // Purchase out of stock\n        dispatcher.purchase('Nano', 2);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> ILizInventoryDispatcher {\n        let owner: felt252 = 'Elizabeth';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"LizInventory\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        ILizInventoryDispatcher { contract_address }\n    }\n}\n```\n\nHint: \nYou can use Map<felt252, u32> for inventory.\n",
      "chat_history": "",
      "context": "The provided context details various Cairo core library functionalities and Starknet testing utilities. It includes:\n\n*   **`ByteArray` Trait and Impl**: Functions for manipulating byte arrays such as `append_word`, `append`, `concat`, `len`, and `at`. These are used for string and byte sequence operations.\n    *   `fn append_word(ref self: ByteArray, word: felt252, len: u32)`\n    *   `fn append(ref self: ByteArray, other: ByteArray)`\n    *   `fn concat(left: ByteArray, right: ByteArray) -> ByteArray`\n    *   `fn len(self: ByteArray) -> u32`\n    *   `fn at(self: ByteArray, index: u32) -> Option<@u8>`\n*   **`Array` and `Span` Traits**: Functions for dynamic arrays and immutable slices (spans).\n    *   `ArrayTrait::append<T>(ref self: Array<T>, value: T)`: Adds an element to the end of an array.\n    *   `ArrayTrait::append_span<T>(ref self: Array<T>, span: Span<T>)`: Adds a span of elements to an array.\n    *   `ArrayTrait::span<T>(snapshot: @Array<T>) -> Span<T>`: Converts an array to a span.\n    *   `SpanTrait::multi_pop_back<T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`: Pops multiple elements from the back.\n    *   `SpanTrait::pop_front<T>(ref self: Span<T>) -> Option<@T>`: Pops an element from the front.\n    *   `SpanTrait::pop_back<T>(ref self: Span<T>) -> Option<@T>`: Pops an element from the back.\n    *   `SpanTrait::get<T>(self: Span<T>, index: u32) -> Option<Box<@T>>`: Returns an element at a given index.\n    *   `SpanTrait::multi_pop_front<T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`: Pops multiple elements from the front.\n    *   `ToSpanTrait<C, T>::span(self: @C) -> Span<T>`: Converts a data structure to a span.\n*   **`Result` Trait**: Functions for handling `Result` types.\n    *   `ResultTrait::ok<T, E>(self: Result<T, E>) -> Option<T>`: Converts `Result` to `Option` discarding the error.\n    *   `ResultTrait::err<T, E>(self: Result<T, E>) -> Option<E>`: Converts `Result` to `Option` discarding the success value.\n*   **`starknet::testing` Utilities**: Functions for contract testing.\n    *   `pop_log<T, +starknet::Event<T>>(address: ContractAddress) -> Option<T>`: Retrieves the last emitted event of a specific type from a contract.\n    *   `cheatcode(input: Span<felt252>) -> Span<felt252> nopanic`: Executes a cheatcode.\n*   **Component Mentions**: Brief mentions of `VotesComponent`, `Initializable`, `ERC20`, `ERC721`, and `ERC4626` components, primarily discussing their purpose and security considerations in a general context, without specific code examples for implementation.\n\nThis context provides general Cairo type and utility information but does not directly cover patterns for `Map` storage, `get_caller_address` for access control, or `assert!` usage in the context of contract state modifications, which are central to the inventory management contract.",
      "expected": "// Liz, a friend of Jill, wants to manage inventory for her store on-chain.\n// This is a bit challenging for Joe and Jill, Liz prepared an outline\n// for how contract should work, can you help Jill and Joe write it?\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait ILizInventory<TContractState> {\n    fn add_stock(ref self: TContractState, product: felt252, new_stock: u32);\n    fn purchase(ref self: TContractState, product: felt252, quantity: u32);\n    fn get_stock(self: @TContractState, product: felt252) -> u32;\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod LizInventory {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map, StorageMapReadAccess, StorageMapWriteAccess};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        inventory: Map<felt252, u32>,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl LizInventoryImpl of super::ILizInventory<ContractState> {\n        fn add_stock(ref self: ContractState, product: felt252, new_stock: u32) {\n            // Only owner can call this\n            let caller = get_caller_address();\n            let owner = self.contract_owner.read();\n            assert(caller == owner, 'Only owner can add stock');\n\n            // Add new_stock to existing stock in inventory\n            let current_stock = self.inventory.entry(product).read();\n            let updated_stock = current_stock + new_stock;\n            self.inventory.entry(product).write(updated_stock);\n        }\n\n        fn purchase(ref self: ContractState, product: felt252, quantity: u32) {\n            // Anybody can call this\n            // Subtract quantity from stock in inventory\n            let current_stock = self.inventory.entry(product).read();\n            assert(current_stock >= quantity, 'Insufficient stock');\n\n            let updated_stock = current_stock - quantity;\n            self.inventory.entry(product).write(updated_stock);\n        }\n\n        fn get_stock(self: @ContractState, product: felt252) -> u32 {\n            // Returns product stock in inventory\n            self.inventory.entry(product).read()\n        }\n\n        fn get_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::LizInventory;\n    use super::ILizInventoryDispatcher;\n    use super::ILizInventoryDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Elizabeth'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n\n        // Check that contract owner is set\n        let contract_owner = dispatcher.get_owner();\n        assert(contract_owner == owner, 'Elizabeth should be the owner');\n    }\n\n    #[test]\n    fn test_stock() {\n        let dispatcher = deploy_contract();\n        let owner = util_felt_addr('Elizabeth');\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 10, 'stock should be 10');\n\n        dispatcher.add_stock('Nano', 15);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 25, 'stock should be 25');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    fn test_stock_purchase() {\n        let owner = util_felt_addr('Elizabeth');\n        let dispatcher = deploy_contract();\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 10, 'stock should be 10');\n\n        // Call contract as different address\n        stop_cheat_caller_address(dispatcher.contract_address);\n        start_cheat_caller_address(dispatcher.contract_address, 0.try_into().unwrap());\n\n        dispatcher.purchase('Nano', 2);\n        let stock = dispatcher.get_stock('Nano');\n        assert(stock == 8, 'stock should be 8');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_stock_fail() {\n        let dispatcher = deploy_contract();\n        // Try to add stock, should panic to pass test!\n        dispatcher.add_stock('Nano', 20);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_purchase_out_of_stock() {\n        let dispatcher = deploy_contract();\n        // Purchase out of stock\n        dispatcher.purchase('Nano', 2);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> ILizInventoryDispatcher {\n        let owner: felt252 = 'Elizabeth';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"LizInventory\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        ILizInventoryDispatcher { contract_address }\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\nfn create_array() -> Array<felt252> {\n    let a = ArrayTrait::new(); // something to change here...\n    a.append(0);\n    a.append(1);\n    a.append(2);\n    a.pop_front().unwrap();\n    a\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_arrays3() {\n    let mut a = create_array();\n    //TODO modify the method called below to make the test pass.\n    // You should not change the index accessed.\n    a.at(2);\n}\n```\n\nHint: The test fails because you are trying to access an element that is out of bounds!\nBy using array.pop_front(), we remove the first element from the array, so the index of the last element is no longer 2.\nWithout changing the index accessed, how can we make the test pass? Is there a method that returns an option that could help us?\n",
      "chat_history": "",
      "context": "### SpanTrait::pop_front\nFully qualified path: [core](./core.md)::[array](./core-array.md)::[SpanTrait](./core-array-SpanTrait.md)::[pop_front](./core-array-SpanTrait.md#pop_front)\n<pre><code class=\"language-cairo\">fn pop_front&lt;T, T&gt;(ref self: Span&lt;T&gt;) -&gt; <a href=\"core-option-Option.html\">Option&lt;@T&gt;</a></code></pre>\n\n### SpanTrait::get\nReturns an option containing a box of a snapshot of the element at the given 'index' if the span contains this index, 'None' otherwise. Element at index 0 is the front of the array.\nFully qualified path: [core](./core.md)::[array](./core-array.md)::[SpanTrait](./core-array-SpanTrait.md)::[get](./core-array-SpanTrait.md#get)\n<pre><code class=\"language-cairo\">fn get&lt;T, T&gt;(self: Span&lt;T&gt;, index: <a href=\"core-integer-usize.html\">usize</a>) -&gt; <a href=\"core-option-Option.html\">Option&lt;@T&gt;</a></code></pre>\n\n### ToSpanTrait::span\nReturns a span pointing to the data in the input.\nFully qualified path: [core](./core.md)::[array](./core-array.md)::[ToSpanTrait](./core-array-ToSpanTrait.md)::[span](./core-array-ToSpanTrait.md#span)\n<pre><code class=\"language-cairo\">fn span&lt;C, T, C, T&gt;(self: @C) -&gt; <a href=\"core-array-Span.html\">Span&lt;T&gt;</a></code></pre>",
      "expected": "// Make me compile and pass the test!\n\n\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new(); // something to change here...\n    a.append(0);\n    a.append(1);\n    a.append(2);\n    a.pop_front().unwrap();\n    a\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_arrays3() {\n    let mut a = create_array();\n    let _ = a.get(2);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n\n// I AM NOT DONE\n\n#[cfg(test)]\n#[test]\nfn main() {\n    let mut a = ArrayTrait::new();\n    let mut b = pass_by_value(a);\n    pass_by_ref(ref a);\n    pass_by_ref(ref b);\n    pass_by_snapshot(@a);\n}\n\nfn pass_by_value(mut arr: Array<felt252>) -> Array<felt252> {\n    arr\n}\n\nfn pass_by_ref(ref arr: Array<felt252>) {}\n\nfn pass_by_snapshot(x: @Array<felt252>) {}\n```\n\nHint: Carefully reason about how each function takes ownership of the variable passed.\nIt depends on the keyword used to pass the variable.\nWhat happens when a function takes ownership of a variable and then returns it?\nCan we still use it later on?\n",
      "chat_history": "",
      "context": "Cairo's ownership system dictates how values are managed in memory, preventing data races and ensuring memory safety. Key concepts include:\n\n*   **Ownership**: Every value in Cairo has a single owner. When the owner goes out of scope, the value is dropped.\n*   **Move Semantics (Pass by Value)**:\n    *   When a variable is passed to a function by value (e.g., `fn func(x: Type)`), ownership of the value is transferred to the function.\n    *   For types like `Array<felt252>`, which do not implement the `Copy` trait (they implement `Drop`), passing by value results in a *move*. This means the original variable becomes invalid after the transfer.\n    *   If the function returns the value (e.g., `fn func(x: Type) -> Type`), ownership is transferred back to the caller, and the caller can bind it to a new or existing variable.\n    *   **Example**: In `let mut b = pass_by_value(a);`, `a` is moved into `pass_by_value`. The function returns the array, which is then moved into `b`. Consequently, `a` is consumed and cannot be used after this line.\n\n*   **Mutable References (Pass by `ref`)**:\n    *   When a variable is passed by mutable reference (e.g., `fn func(ref x: Type)`), the function gains temporary mutable access to the value without taking ownership.\n    *   The original variable must be declared `mut`.\n    *   Only one mutable reference to a specific piece of data can exist at any given time.\n    *   While a mutable reference is active, the original variable cannot be used by value or by snapshot. However, the borrow is typically short-lived, ending when the function call returns.\n    *   **Example**: `pass_by_ref(ref arr: Array<felt252>)` allows `arr` to be modified within the function. After the call, the original variable remains valid and owned.\n\n*   **Snapshots (Pass by `@`)**:\n    *   When a variable is passed by snapshot (e.g., `fn func(x: @Type)`), the function receives a read-only view of the value at the time the snapshot was taken.\n    *   This does not transfer ownership, and the original variable remains owned by the caller.\n    *   Multiple snapshots can exist simultaneously.\n    *   While a snapshot exists, the original variable cannot be mutably borrowed or moved. Similar to `ref`, the snapshot's lifetime is typically limited to the function call.\n    *   **Example**: `pass_by_snapshot(x: @Array<felt252>)` allows `x` to be read. After the call, the original variable remains valid, owned, and mutable.\n\nTo ensure code compiles, operations must respect these rules, especially the consumption of variables when moved.",
      "expected": "// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n\n\n\n#[cfg(test)]\n#[test]\nfn main() {\n    let mut a = ArrayTrait::new();\n    pass_by_ref(ref a);\n    pass_by_snapshot(@a);\n    let mut b = pass_by_value(a);\n    pass_by_ref(ref b);\n}\n\nfn pass_by_value(mut arr: Array<felt252>) -> Array<felt252> {\n    arr\n}\n\nfn pass_by_ref(ref arr: Array<felt252>) {}\n\nfn pass_by_snapshot(x: @Array<felt252>) {}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n\n// I AM NOT DONE\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\n\nHint: The difference between this one and the previous ones is that the first line\nof `fn fill_arr` that had `let mut arr = arr;` is no longer there. You can,\ninstead of adding that line back, add `mut` in one place that will change\nan existing binding to be a mutable binding instead of an immutable one :)",
      "chat_history": "",
      "context": "The Cairo `ArrayTrait` methods that modify the array, such as `append_span`, require a mutable reference to the array instance. For example, `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)` indicates that `self` must be mutable. When an `Array` is passed as a function parameter, it is immutable by default. To enable modification of the array within the function, the parameter must be explicitly declared as mutable using the `mut` keyword in the function signature.\n\nExample of `ArrayTrait::append_span` requiring `ref self`:\n```cairo\nlet mut arr: Array<u8> = array![];\narr.append_span(array![1, 2, 3].span());\nassert!(arr == array![1, 2, 3]);\n```\nFully qualified path: `core::array::ArrayTrait::append_span`\nSignature: `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`\n\nOther relevant `SpanTrait` methods:\n- `pop_front`: `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n- `pop_back`: `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`\n- `multi_pop_front`: `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`",
      "expected": "// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(mut arr: Array<felt252>) -> Array<felt252> {\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile without changing the indicated lines\n\n// I AM NOT DONE\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut _arr1 = fill_arr(arr0);\n\n    // Do not change the following line!\n    print_arr(arr0);\n}\n\nfn print_arr(arr: Array<felt252>) {\n    println!(\"arr: {:?}\", arr);\n}\n\n// Do not change the following line!\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\n\nHint: So, `arr0` is passed into the `fill_arr` function as an argument. In Cairo,\nwhen an argument is passed to a function and it's not explicitly returned,\nyou can't use the original variable anymore. We call this \"moving\" a variable.\nVariables that are moved into a function (or block scope) and aren't explicitly\nreturned get \"dropped\" at the end of that function. This is also what happens here.\nThere's a few ways to fix this, try them all if you want:\n1. Make another, separate version of the data that's in `arr0` and pass that\n   to `fill_arr` instead.\n2. Make `fill_arr` *mutably* borrow a reference to its argument (which will need to be\n   mutable) with the `ref` keyword , modify it directly, then not return anything. Then you can get rid\n   of `arr1` entirely -- note that this will change what gets printed by the\n   first `print`\n3. Make `fill_arr` borrow an immutable view of its argument instead of taking ownership by using the snapshot operator `@`,\n   and then copy the data within the function in order to return an owned\n   `Array<felt>`. This requires an explicit clone of the array and should generally be avoided in Cairo, as the memory is write-once and cloning can be expensive. To clone an object, you will need to import the trait `clone::Clone` and the implementation of the Clone trait for the array located in `array::ArrayTCloneImpl`",
      "chat_history": "",
      "context": "In Cairo, variables are moved by default when passed as arguments to functions. This means the original variable cannot be used after the function call unless it is explicitly returned by the function. Variables that are moved into a function and not returned are 'dropped' at the end of that function's scope.\n\nHere are the common ways to address this, based on Cairo's ownership and borrowing rules:\n\n1.  **Cloning before passing:**\n    To retain ownership of the original array (`arr0`) while allowing the `fill_arr` function to operate on a separate copy, you can explicitly clone the array before passing it. The `Array` type supports cloning if its elements (`T`) implement the `Clone` trait. For example, the `ArrayTrait::append_span` function has the signature `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`, indicating that `Array<T>` can be cloned. To clone an array, you would typically use `arr.clone()`. This approach requires importing the `clone::Clone` trait and the `array::ArrayTCloneImpl` implementation.\n\n2.  **Mutable References (`ref`):**\n    To allow a function to modify an array in-place without taking ownership, you can pass a mutable reference using the `ref` keyword. The function signature would change to accept a mutable reference, for example: `fn fill_arr(ref arr: Array<felt252>)`. Inside the function, `arr` can be directly modified (e.g., `arr.append(value)`). The function would not need to return the array. When calling such a function, you must pass a mutable reference to the array, like `fill_arr(ref mut arr0);`. Examples from the Corelib demonstrating mutable references include:\n    *   `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`\n\n3.  **Immutable Snapshots (`@`) and Internal Cloning:**\n    You can pass an immutable view (snapshot) of the array using the `@` operator. The function signature would be `fn fill_arr(arr: @Array<felt252>)`. This means the function receives a read-only view of the original array. If the function needs to modify the data and return a new, owned array, it must first clone the snapshot internally to create a new mutable array, then perform modifications, and finally return the new array. This approach can be less efficient in Cairo due to its write-once memory model, as cloning can be an expensive operation. Examples from the Corelib demonstrating immutable snapshots include:\n    *   `fn span<C, T, C, T>(self: @C) -> Span<T>` (for converting a data structure to a span)\n    *   Return types like `Option<@T>` from functions such as `SpanTrait::pop_front` or `SpanTrait::get`.",
      "expected": "// Make me compile without changing the indicated lines\n\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    // Do not change the following line!\n    print_arr(arr0);\n}\n\nfn print_arr(arr: Array<felt252>) {\n    println!(\"arr: {:?}\", arr);\n}\n\n// Do not change the following line!\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make me compile!\n\n// I AM NOT DONE\n\nfn main() {\n    x = 5 ;\n    println!(\" x is {}\", x)\n}\n```\n\nHint: The declaration on line 8 is missing a keyword that is needed in Cairo\nto create a new variable binding.",
      "chat_history": "",
      "context": "In Cairo, variables are declared using the `let` keyword. This keyword is essential for creating new variable bindings. Variables can be immutable by default or mutable if declared with `let mut`.\n\nExamples of variable declarations from the provided context:\n\n*   **Immutable variable declaration:**\n    ```cairo\n    let span = array![1, 2, 3].span();\n    let ba = \"1\";\n    let execution_info = get_execution_info().unbox();\n    let contract_address = get_contract_address();\n    ```\n\n*   **Mutable variable declaration:**\n    ```cairo\n    let mut span = array![1, 2, 3].span();\n    let mut ba: ByteArray = \"1\";\n    let mut arr: Array<u8> = array![];\n    ```\n\nThese examples demonstrate that `let` is the required keyword for variable declaration in Cairo.",
      "expected": "// Make me compile!\n\n\n\nfn main() {\n    let x = 5;\n    println!(\" x is {}\", x)\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Make the tests pass.\n\n// I AM NOT DONE\n\nfn bigger(a: usize, b: usize) -> usize { // Complete this function to return the bigger number!\n// Do not use:\n// - another function call\n// - additional variables\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::bigger;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert(10 == bigger(10, 8), '10 bigger than 8');\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert(42 == bigger(32, 42), '42 bigger than 32');\n    }\n}\n```\n\nHint: Remember in Cairo that:\n- the `if` condition does not need to be surrounded by parentheses\n- `if`/`else` conditionals are expressions\n- Each condition is followed by a `{}` block.",
      "chat_history": "",
      "context": "## Flow of Control\nAn integral part of any programming language are ways to modify control flow: `if`/`else`, `for`, and others. Let's explore how Cairo handles these control flow constructs.\n\n### `if`/`else` expressions\nIn Cairo, `if`/`else` conditionals are expressions, meaning they evaluate to a value. The condition does not need to be surrounded by parentheses, and each condition is followed by a `{}` block.\n\nExample demonstrating `if`/`else if`/`else` as an expression:\n```cairo,editable\nfn main() {\n    // `n` will take the values: 1, 2, ..., 100 in each iteration\n    for n in 1..101_u8 {\n        if n % 15 == 0 {\n            println!(\"fizzbuzz\");\n        } else if n % 3 == 0 {\n            println!(\"fizz\");\n        } else if n % 5 == 0 {\n            println!(\"buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n    }\n}\n```\nAlternatively, `a..=b` can be used for a range that is inclusive on both ends.\n```cairo,editable\nfn main() {\n    // `n` will take the values: 1, 2, ..., 100 in each iteration\n    for n in 1..= 100_u8 {\n        if n % 15 == 0 {\n            println!(\"fizzbuzz\");\n        } else if n % 3 == 0 {\n            println!(\"fizz\");\n        } else if n % 5 == 0 {\n            println!(\"buzz\");\n        } else {\n            println!(\"{}\", n);\n        }\n    }\n}\n```",
      "expected": "// Make the tests pass.\n\nfn bigger(a: usize, b: usize) -> usize {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::bigger;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert(10 == bigger(10, 8), '10 bigger than 8');\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert(42 == bigger(32, 42), '42 bigger than 32');\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 3 cairobucks.\n// - If Mary buys more than 40 apples, each apple only costs 2 cairobuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\nfn calculate_price_of_apples{\n\n}\n\n// Do not change the tests!\n#[cfg(test)]\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert(105 == price1, 'Incorrect price');\n    assert(120 == price2, 'Incorrect price');\n    assert(82 == price3, 'Incorrect price');\n    assert(130 == price4, 'Incorrect price');\n}\n```\n\nHint: No hints this time ;)",
      "chat_history": "",
      "context": "The provided context is not relevant to the query. It contains documentation for `starknet::storage::Vec`, `core::array::SpanTrait`, `core::byte_array::ByteArrayTrait`, and `core::starknet::testing::cheatcode`, which are not required for implementing basic arithmetic and conditional logic in a Cairo function.",
      "expected": "// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 3 cairobucks.\n// - If Mary buys more than 40 apples, each apple only costs 2 cairobuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\nfn calculate_price_of_apples(quantity: u32) -> u32 {\n    if quantity > 40 {\n        quantity * 2\n    } else {\n        quantity * 3\n    }\n}\n\n// Do not change the tests!\n#[cfg(test)]\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert(105 == price1, 'Incorrect price');\n    assert(120 == price2, 'Incorrect price');\n    assert(82 == price3, 'Incorrect price');\n    assert(130 == price4, 'Incorrect price');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Modify the integer types to make the tests pass.\n// Learn how to convert between integer types, and felts.\n\n// I AM NOT DONE\n\nfn sum_u8s(x: u8, y: u8) -> u8 {\n    x + y\n}\n\n//TODO modify the types of this function to prevent an overflow when summing big values\nfn sum_big_numbers(x: u8, y: u8) -> u8 {\n    x + y\n}\n\nfn convert_to_felt(x: u8) -> felt252 { //TODO return x as a felt252.\n}\n\nfn convert_felt_to_u8(x: felt252) -> u8 { //TODO return x as a u8.\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_u8s() {\n    assert(sum_u8s(1, 2_u8) == 3_u8, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_big_numbers() {\n    //TODO modify this test to use the correct integer types.\n    // Don't modify the values, just the types.\n    // See how using the _u8 suffix on the numbers lets us specify the type?\n    // Try to do the same thing with other integer types.\n    assert(sum_big_numbers(255_u8, 255_u8) == 510_u8, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_felt() {\n    assert(convert_to_felt(1_u8) == 1, 'Type conversion went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_u8() {\n    assert(convert_felt_to_u8(1) == 1_u8, 'Type conversion went wrong');\n}\n```\n\nHint: There are multiple integer types in Cairo. You can read about them here:\nhttps://book.cairo-lang.org/ch02-02-data-types.html#integer-types\nIf you try to sum two integers and the result is bigger than the biggest integer of this type, you'll get a compilation error.\nYou can convert integers to felts using the `.into()` method. Make sure that you imported the `Into` trait.\nYou can convert felts to integers using the `.try_into()` method. Make sure that you imported the `TryInto` trait.\nThis method will return an `Option` type, so you'll need to unwrap it. To use the `unwrap()` method, you'll need to import the `OptionTrait` trait.\nTake a look at the top of the file to see how these traits are imported.\n",
      "chat_history": "",
      "context": "The provided context does not contain information relevant to Cairo integer types, type conversion between integers and `felt252` using `Into` and `TryInto` traits, or the `OptionTrait` for unwrapping.",
      "expected": "// Modify the integer types to make the tests pass.\n// Learn how to convert between integer types, and felts.\n\n\nfn sum_u8s(x: u8, y: u8) -> u8 {\n    x + y\n}\n\n//TODO modify the types of this function to prevent an overflow when summing big values\nfn sum_big_numbers(x: u16, y: u16) -> u16 {\n    x + y\n}\n\nfn convert_to_felt(x: u8) -> felt252 {\n    x.into()\n}\n\nfn convert_felt_to_u8(x: felt252) -> u8 {\n    x.try_into().unwrap()\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_u8s() {\n    assert(sum_u8s(1, 2_u8) == 3_u8, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_big_numbers() {\n    //TODO modify this test to use the correct integer types.\n    // Don't modify the values, just the types.\n    // See how using the _u8 suffix on the numbers lets us specify the type?\n    // Try to do the same thing with other integer types.\n    assert(sum_big_numbers(255_u16, 255_u16) == 510_u16, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_felt() {\n    assert(convert_to_felt(1_u8) == 1, 'Type conversion went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_u8() {\n    assert(convert_felt_to_u8(1) == 1_u8, 'Type conversion went wrong');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Refactor this code so that instead of passing `arr0` into the `fill_arr` function,\n// the Array gets created in the function itself and passed back to the main\n// function.\n\n// I AM NOT DONE\n\nfn main() {\n    let arr0 = ArrayTrait::<felt252>::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\n// `fill_arr()` should no longer take `arr: Array<felt252>` as argument\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\n\nHint: Stop reading whenever you feel like you have enough direction :) Or try\ndoing one step and then fixing the compiler errors that result!\nSo the end goal is to:\n   - get rid of the first line in main that creates the new array\n   - so then `arr0` doesn't exist, so we can't pass it to `fill_arr`\n   - we don't want to pass anything to `fill_arr`, so its signature should\n     reflect that it does not take any arguments\n   - since we're not creating a new array in `main` anymore, we need to create\n     a new array in `fill_arr`, similarly to the way we did in `main`",
      "chat_history": "",
      "context": "### `core::array::ArrayTrait`\n\n*   **`append_span`**: Appends a `Span` to the end of an `Array`.\n    *   **Signature**: `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`\n    *   **Example**:\n        ```cairo\n        let mut arr: Array<u8> = array![];\n        arr.append_span(array![1, 2, 3].span());\n        assert!(arr == array![1, 2, 3]);\n        ```\n\n### `core::array::SpanTrait`\n\n*   **`pop_front`**: Pops a value from the front of the span. Returns `Some(@value)` if not empty, `None` otherwise.\n    *   **Signature**: `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   **Example**:\n        ```cairo\n        let mut span = array![1, 2, 3].span();\n        assert!(span.pop_front() == Some(@1));\n        ```\n*   **`pop_back`**: Pops a value from the back of the span. Returns `Some(@value)` if not empty, `None` otherwise.\n    *   **Signature**: `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   **Example**:\n        ```cairo\n        let mut span = array![1, 2, 3].span();\n        assert!(span.pop_back() == Some(@3));\n        ```\n*   **`multi_pop_front`**: Pops multiple values from the front of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if successful, `None` otherwise.\n    *   **Signature**: `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n    *   **Example**:\n        ```cairo\n        let mut span = array![1, 2, 3].span();\n        let result = *(span.multi_pop_front::<2>().unwrap());\n        let unboxed_result = result.unbox();\n        assert!(unboxed_result == [1, 2]);\n        ```\n\n### `core::array::ToSpanTrait`\n\n*   **`span`**: Converts a data structure into a span of its data.\n    *   **Signature**: `pub trait ToSpanTrait<C, T>`\n    *   **Trait function signature**: `fn span<C, T, C, T>(self: @C) -> Span<T>`\n    *   **Example**: (Implicitly shown in `pop_front` and `append_span` examples, e.g., `array![1, 2, 3].span()`)",
      "expected": "// Refactor this code so that instead of passing `arr0` into the `fill_arr` function,\n// the Array gets created in the function itself and passed back to the main\n// function.\n\nfn main() {\n    let mut arr1 = fill_arr();\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\n// `fill_arr()` should no longer take `arr: Array<felt252>` as argument\nfn fill_arr() -> Array<felt252> {\n    let mut arr = ArrayTrait::<felt252>::new();\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Remember last time you calculated division in Cairo0?\n// Now Cairo1 has native integer types e.g. u8, u32, ...u256, usize which support more operators than felts\n// And always watch out for overflows e.g in the last test\n// Let try to use them\n\n// I AM NOT DONE\n\nfn modulus(x: u8, y: u8) -> u8 {\n    // calculate the modulus of x and y\n    // FILL ME\n    res\n}\n\nfn floor_division(x: usize, y: usize) -> usize {\n    // calculate the floor_division of x and y\n    // FILL ME\n    res\n}\n\nfn multiplication(x: u64, y: u64) -> u64 {\n    // calculate the multiplication of x and y\n    // FILL ME\n    res\n}\n\n\n// Do not change the tests\n#[cfg(test)]\n#[test]\nfn test_modulus() {\n    let res = modulus(16, 2);\n    assert(res == 0, 'Error message');\n\n    let res = modulus(17, 3);\n    assert(res == 2, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\nfn test_floor_division() {\n    let res = floor_division(160, 2);\n    assert(res == 80, 'Error message');\n\n    let res = floor_division(21, 4);\n    assert(res == 5, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\nfn test_mul() {\n    let res = multiplication(16, 2);\n    assert(res == 32, 'Error message');\n\n    let res = multiplication(21, 4);\n    assert(res == 84, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn test_u64_mul_overflow_1() {\n    let _res = multiplication(0x100000000, 0x100000000);\n}\n```\n\nHint: Use % for modulus, / for division, and * for multiplication.",
      "chat_history": "",
      "context": "The provided context details functions and traits for `core::array::SpanTrait` (e.g., `pop_front`, `pop_back`, `multi_pop_front`, `multi_pop_back`, `at`, `slice`, `ToSpanTrait`, `append_span`), `core::byte_array::ByteArray` (e.g., `append`, `concat`, `append_byte`), `core::starknet::storage::vec::MutableVecTrait` (e.g., `append`, `allocate`), and `core::starknet::testing::cheatcode`. These functions are for manipulating arrays, byte arrays, and storage vectors, and for interacting with testing cheatcodes. They do not provide information on basic arithmetic operators (`%`, `/`, `*`) for integer types in Cairo 1.",
      "expected": "// Remember last time you calculated division in Cairo0?\n// Now Cairo1 has native integer types e.g. u8, u32, ...u256, usize which support more operators than felts\n// And always watch out for overflows e.g in the last test\n// Let try to use them\n\nfn modulus(x: u8, y: u8) -> u8 {\n    // calculate the modulus of x and y\n    x % y\n}\n\nfn floor_division(x: usize, y: usize) -> usize {\n    // calculate the floor_division of x and y\n    x / y\n}\n\nfn multiplication(x: u64, y: u64) -> u64 {\n    // calculate the multiplication of x and y\n    x * y\n}\n\n\n// Do not change the tests\n#[cfg(test)]\n#[test]\nfn test_modulus() {\n    let res = modulus(16, 2);\n    assert(res == 0, 'Error message');\n\n    let res = modulus(17, 3);\n    assert(res == 2, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\nfn test_floor_division() {\n    let res = floor_division(160, 2);\n    assert(res == 80, 'Error message');\n\n    let res = floor_division(21, 4);\n    assert(res == 5, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\nfn test_mul() {\n    let res = multiplication(16, 2);\n    assert(res == 32, 'Error message');\n\n    let res = multiplication(21, 4);\n    assert(res == 84, 'Error message');\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn test_u64_mul_overflow_1() {\n    let _res = multiplication(0x100000000, 0x100000000);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Starkling, Joe, is writing a really simple contract.\n// The contract shows that he is the owner of the contract.\n// However, his contract is not working. What's he missing?\n\n// I AM NOT DONE\n\n#[starknet::interface]\ntrait IJoesContract<TContractState> {\n    fn get_owner(self: @TContractState) -> felt252;\n}\n\n#[starknet::contract]\nmod JoesContract {\n    #[storage]\n    struct Storage {}\n\n    impl IJoesContractImpl of super::IJoesContract<ContractState> {\n        fn get_owner(self: @ContractState) -> felt252 {\n            'Joe'\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{ContractClassTrait, DeclareResultTrait, declare};\n    use super::{IJoesContractDispatcher, IJoesContractDispatcherTrait, JoesContract};\n\n    #[test]\n    fn test_contract_view() {\n        let dispatcher = deploy_contract();\n        assert('Joe' == dispatcher.get_owner(), 'Joe should be the owner.');\n    }\n\n    fn deploy_contract() -> IJoesContractDispatcher {\n        let contract = declare(\"JoesContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IJoesContractDispatcher { contract_address }\n    }\n}\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "Cairo smart contracts define their state using a `#[storage]` struct. This struct holds the contract's persistent data. The contract's initial state is set up using a `#[constructor]` function, which is executed only once upon contract deployment.\n\n**Defining Storage:**\nContract storage is defined within the `mod` block using the `#[storage]` attribute:\n```cairo\n#[storage]\npub struct Storage {\n    // Storage variables are declared here\n    // Example: owner: felt252,\n}\n```\n\n**Contract Constructor:**\nThe `#[constructor]` attribute marks a function that initializes the contract's state. It takes a mutable reference to `ContractState` (which contains the `Storage` struct) as its first argument, allowing it to modify the storage variables.\n\nExample of a constructor initializing a storage variable:\n```cairo\n#[starknet::contract]\npub mod MyContract {\n    #[storage]\n    pub struct Storage {\n        pub owner: felt252,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, initial_owner: felt252) {\n        self.owner.write(initial_owner);\n    }\n}\n```\n\nIn the context of OpenZeppelin components, constructors are often used to initialize sub-storages of components:\n\n```cairo\n#[starknet::contract]\nmod ERC20VotesContract {\n    use openzeppelin_governance::votes::VotesComponent;\n    use openzeppelin_token::erc20::{ERC20Component, DefaultConfig};\n    use openzeppelin_utils::cryptography::nonces::NoncesComponent;\n    use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;\n    use starknet::ContractAddress;\n\n    component!(path: VotesComponent, storage: erc20_votes, event: ERC20VotesEvent);\n    component!(path: ERC20Component, storage: erc20, event: ERC20Event);\n    component!(path: NoncesComponent, storage: nonces, event: NoncesEvent);\n\n    #[storage]\n    pub struct Storage {\n        #[substorage(v0)]\n        pub erc20_votes: VotesComponent::Storage,\n        #[substorage(v0)]\n        pub erc20: ERC20Component::Storage,\n        #[substorage(v0)]\n        pub nonces: NoncesComponent::Storage\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {\n        self.erc20.initializer(\"MyToken\", \"MTK\");\n    }\n}\n```\n\n`felt252` is a common type used for short strings and addresses in Cairo.",
      "expected": "// Starkling, Joe, is writing a really simple contract.\n// The contract shows that he is the owner of the contract.\n// However, his contract is not working. What's he missing?\n\n#[starknet::interface]\ntrait IJoesContract<TContractState> {\n    fn get_owner(self: @TContractState) -> felt252;\n}\n\n#[starknet::contract]\nmod JoesContract {\n    #[storage]\n    struct Storage {}\n\n    #[abi(embed_v0)]\n    impl IJoesContractImpl of super::IJoesContract<ContractState> {\n        fn get_owner(self: @ContractState) -> felt252 {\n            'Joe'\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::JoesContract;\n    use super::IJoesContractDispatcher;\n    use super::IJoesContractDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n\n    #[test]\n    fn test_contract_view() {\n        let dispatcher = deploy_contract();\n        assert('Joe' == dispatcher.get_owner(), 'Joe should be the owner.');\n    }\n\n    fn deploy_contract() -> IJoesContractDispatcher {\n        let contract = declare(\"JoesContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IJoesContractDispatcher { contract_address }\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n\n// I AM NOT DONE\n\nfn foo_if_fizz(fizzish: felt252) -> felt252 {\n    // Complete this function using if, else if and/or else blocks.\n    // If fizzish is,\n    // 'fizz', return 'foo'\n    // 'fuzz', return 'bar'\n    // anything else, return 'baz'\n    if fizzish == 'fizz' {\n        'foo'\n    } else {\n        1_u32\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::foo_if_fizz;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert(foo_if_fizz('fizz') == 'foo', 'fizz returns foo')\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert(foo_if_fizz('fuzz') == 'bar', 'fuzz returns bar');\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert(foo_if_fizz('literally anything') == 'baz', 'anything else returns baz');\n    }\n}\n```\n\nHint: For that first compiler error, it's important in Cairo that each conditional\nblock returns the same type! To get the tests passing, you will need a couple\nconditions checking different input values.",
      "chat_history": "",
      "context": "No relevant information was found in the provided context to address the user's query regarding Cairo `if/else if/else` syntax, `felt252` character literals, or conditional block return type consistency. The context primarily covers `core::array::SpanTrait`, `core::starknet::testing::cheatcode`, `core::byte_array::ByteArrayTrait`, and `core::starknet::info` functions, which are not applicable to the problem.",
      "expected": "// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n\n\n\nfn foo_if_fizz(fizzish: felt252) -> felt252 {\n    // Complete this function using if, else if and/or else blocks.\n    // If fizzish is,\n    // 'fizz', return 'foo'\n    // 'fuzz', return 'bar'\n    // anything else, return 'baz'\n    if fizzish == 'fizz' {\n        'foo'\n    } else if fizzish == 'fuzz' {\n        'bar'\n    } else {\n        'baz'\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::foo_if_fizz;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert(foo_if_fizz('fizz') == 'foo', 'fizz returns foo')\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert(foo_if_fizz('fuzz') == 'bar', 'fuzz returns bar');\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert(foo_if_fizz('literally anything') == 'baz', 'anything else returns baz');\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Package {\n    sender_country: felt252,\n    recipient_country: felt252,\n    weight_in_grams: usize,\n}\n\ntrait PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package;\n    fn is_international(ref self: Package) -> //???;\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> //???;\n}\nimpl PackageImpl of PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package {\n        if weight_in_grams <= 0{\n            let mut data = ArrayTrait::new();\n            data.append('x');\n            panic(data);\n        }\n        Package { sender_country, recipient_country, weight_in_grams,  }\n    }\n\n    fn is_international(ref self: Package) -> //???\n    {\n    /// Something goes here...\n    }\n\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> //???\n    {\n    /// Something goes here...\n    }\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn fail_creating_weightless_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Austria';\n    PackageTrait::new(sender_country, recipient_country, 0);\n}\n\n#[cfg(test)]\n#[test]\nfn create_international_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Russia';\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == true, 'Not international');\n}\n\n#[cfg(test)]\n#[test]\nfn create_local_package() {\n    let sender_country = 'Canada';\n    let recipient_country = sender_country;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == false, 'International');\n}\n\n#[cfg(test)]\n#[test]\nfn calculate_transport_fees() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Spain';\n\n    let cents_per_gram = 3;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1500);\n\n    assert(package.get_fees(cents_per_gram) == 4500, 'Wrong fees');\n}\n```\n\nHint: For is_international: What makes a package international? Seems related to the places it goes through right?\n\nFor get_fees: This method takes an additional argument, is there a field in the Package struct that this relates to?\n\nLooking at the test functions will also help you understand more about the syntax.\nThis section will help you understanding more about methods https://book.cairo-lang.org/ch05-03-method-syntax.html\n",
      "chat_history": "",
      "context": "```cairo\nuse core::array::ArrayTrait;\nuse core::panic::panic;\nuse core::traits::{Copy, Drop};\n\n#[derive(Copy, Drop)]\nstruct Package {\n    sender_country: felt252,\n    recipient_country: felt252,\n    weight_in_grams: usize,\n}\n\ntrait PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package;\n    fn is_international(ref self: Package) -> bool;\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> usize;\n}\n\nimpl PackageImpl of PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package {\n        if weight_in_grams <= 0 {\n            let mut data = ArrayTrait::new();\n            data.append('Weight must be positive'); // Changed 'x' to a more descriptive message\n            panic(data);\n        }\n        Package { sender_country, recipient_country, weight_in_grams, }\n    }\n\n    fn is_international(ref self: Package) -> bool {\n        self.sender_country != self.recipient_country\n    }\n\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> usize {\n        self.weight_in_grams * cents_per_gram\n    }\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn fail_creating_weightless_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Austria';\n    PackageTrait::new(sender_country, recipient_country, 0);\n}\n\n#[cfg(test)]\n#[test]\nfn create_international_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Russia';\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == true, 'Not international');\n}\n\n#[cfg(test)]\n#[test]\nfn create_local_package() {\n    let sender_country = 'Canada';\n    let recipient_country = sender_country;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == false, 'International');\n}\n\n#[cfg(test)]\n#[test]\nfn calculate_transport_fees() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Spain';\n\n    let cents_per_gram = 3;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1500);\n\n    assert(package.get_fees(cents_per_gram) == 4500, 'Wrong fees');\n}\n```",
      "expected": "// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n\n#[derive(Copy, Drop)]\nstruct Package {\n    sender_country: felt252,\n    recipient_country: felt252,\n    weight_in_grams: usize,\n}\n\ntrait PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package;\n    fn is_international(ref self: Package) -> bool;\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> usize;\n}\nimpl PackageImpl of PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package {\n        if weight_in_grams <= 0{\n            let mut data = ArrayTrait::new();\n            data.append('x');\n            panic(data);\n        }\n        Package { sender_country, recipient_country, weight_in_grams,  }\n    }\n\n    fn is_international(ref self: Package) -> bool {\n        self.sender_country != self.recipient_country\n    }\n\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> usize {\n        self.weight_in_grams * cents_per_gram\n    }\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn fail_creating_weightless_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Austria';\n    PackageTrait::new(sender_country, recipient_country, 0);\n}\n\n#[cfg(test)]\n#[test]\nfn create_international_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Russia';\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == true, 'Not international');\n}\n\n#[cfg(test)]\n#[test]\nfn create_local_package() {\n    let sender_country = 'Canada';\n    let recipient_country = sender_country;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert(package.is_international() == false, 'International');\n}\n\n#[cfg(test)]\n#[test]\nfn calculate_transport_fees() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Spain';\n\n    let cents_per_gram = 3;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1500);\n\n    assert(package.get_fees(cents_per_gram) == 4500, 'Wrong fees');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// The Felt252Dict maps a felt252 to a value of the specified type.\n// In this exercise, you will map a `felt252` key to a value of type `u32`.\n\n// Your task is to create a `Felt252Dict`  containing three elements of type `u32`.\n// The first element should map the key 'A' to the value 1, the second key 'B' to the value 2\n// and the third should map 'bob' to the value 3.\n// Make me compile and pass the test!\n\n// I AM NOT DONE\nuse core::dict::Felt252Dict;\n\nfn create_dictionary() -> Felt252Dict<u32> {\n    let mut dict: Felt252Dict<u32> = Default::default();\n//TODO\n\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_dict() {\n    let mut dict = create_dictionary();\n    assert(dict.get('A') == 1, 'First element is not 1');\n    assert(dict.get('B') == 2, 'Second element is not 2');\n    assert(dict.get('bob') == 3, 'Third element is not 3');\n}\n```\n\nHint: More info about the Felt252Dict type can be found in the following chapter :\nhttps://book.cairo-lang.org/ch03-02-dictionaries.html\n",
      "chat_history": "",
      "context": "The provided context does not contain information relevant to `core::dict::Felt252Dict` or its operations. It includes examples and function signatures for:\n*   **`core::array::SpanTrait`**: `pop_front`, `pop_back`, `multi_pop_front`, `multi_pop_back`, `get`, `at`.\n    *   `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n    *   `fn multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`\n    *   `fn get<T, T>(self: Span<T>, index: u32) -> Option<Box<@T>>`\n*   **`core::array::ArrayTrait`**: `span`, `append_span`, `pop_front`.\n    *   `fn span<T, T>(snapshot: @Array<T>) -> Span<T>`\n    *   `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`\n*   **`core::array::ToSpanTrait`**: `span`.\n    *   `pub trait ToSpanTrait<C, T>`\n    *   `fn span<C, T, C, T>(self: @C) -> Span<T>`\n*   **`core::byte_array::ByteArrayTrait`**: `append_word`, `append`, `concat`.\n    *   `fn append_word(ref self: ByteArray, word: felt252, len: u32)`\n    *   `fn append(ref self: ByteArray, other: ByteArray)`\n    *   `fn concat(left: ByteArray, right: ByteArray) -> ByteArray`\n*   **`core::option::OptionTrait`**: `is_some`, `is_some_and`.\n    *   `fn is_some<T, T>(self: @Option<T>) -> bool`\n*   **`core::starknet::testing`**: `cheatcode`, `pop_log`.\n    *   `pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;`\n    *   `pub fn pop_log<T, +starknet::Event<T>>(address: ContractAddress) -> Option<T>`\n*   **`core::starknet::info`**: `get_execution_info`, `get_contract_address`.\n    *   `pub fn get_execution_info() -> Box<ExecutionInfo>`\n    *   `pub fn get_contract_address() -> ContractAddress`",
      "expected": "// The Felt252Dict maps a felt252 to a value of the specified type.\n// In this exercise, you will map a `felt252` key to a value of type `u32`.\n\n// Your task is to create a `Felt252Dict`  containing three elements of type `u32`.\n// The first element should map the key 'A' to the value 1, the second key 'B' to the value 2\n// and the third should map 'bob' to the value 3.\n// Make me compile and pass the test!\n\nuse core::dict::Felt252Dict;\n\nfn create_dictionary() -> Felt252Dict<u32> {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    // Insert the required key-value pairs\n    dict.insert('A', 1);\n    dict.insert('B', 2);\n    dict.insert('bob', 3);\n\n    dict\n\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_dict() {\n    let mut dict = create_dictionary();\n    assert(dict.get('A') == 1, 'First element is not 1');\n    assert(dict.get('B') == 2, 'Second element is not 2');\n    assert(dict.get('bob') == 3, 'Third element is not 3');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// The previous exercise did not make the distinction\n// between different types of animals, but this one does.\n// The trait `AnimalTrait` has two functions:\n// `new` and `make_noise`.\n// `new` should return a new instance of the type\n// implementing the trait.\n// `make_noise` should return the noise the animal makes.\n// The types `Cat` and `Cow` are already defined for you.\n// You need to implement the trait `AnimalTrait` for them.\n\n// No hints for this one!\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Cat {\n    noise: felt252,\n}\n\n#[derive(Copy, Drop)]\nstruct Cow {\n    noise: felt252,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n}\n\nimpl CatImpl of AnimalTrait<Cat> { // TODO: implement the trait Animal for the type Cat\n}\n\n// TODO: implement the trait Animal for the type Cow\n\n#[cfg(test)]\n#[test]\nfn test_traits2() {\n    let kitty: Cat = AnimalTrait::new();\n    assert(kitty.make_noise() == 'meow', 'Wrong noise');\n\n    let cow: Cow = AnimalTrait::new();\n    assert(cow.make_noise() == 'moo', 'Wrong noise');\n}\n```\n\nHint:  No hints for this one! It is very similar to the previous exercise.",
      "chat_history": "",
      "context": "The provided context contains examples and documentation for `core::byte_array::ByteArrayTrait`, `core::array::SpanTrait`, `core::array::ArrayTrait`, `core::array::ToSpanTrait`, `core::option::OptionTrait`, and Starknet functions such as `starknet::get_tx_info`, `starknet::get_execution_info`, `starknet::get_contract_address`, `starknet::testing::pop_log`, and `starknet::testing::cheatcode`. This information is not directly relevant to implementing custom traits for structs or handling `felt252` character literals, which is the core of the user's query.",
      "expected": "// The previous exercise did not make the distinction\n// between different types of animals, but this one does.\n// The trait `AnimalTrait` has two functions:\n// `new` and `make_noise`.\n// `new` should return a new instance of the type\n// implementing the trait.\n// `make_noise` should return the noise the animal makes.\n// The types `Cat` and `Cow` are already defined for you.\n// You need to implement the trait `AnimalTrait` for them.\n\n// No hints for this one!\n\n\n\n#[derive(Copy, Drop)]\nstruct Cat {\n    noise: felt252,\n}\n\n#[derive(Copy, Drop)]\nstruct Cow {\n    noise: felt252,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n}\n\nimpl CatImpl of AnimalTrait<Cat> {\n    fn new() -> Cat {\n        Cat { noise: 'meow' }\n    }\n\n    fn make_noise(self: Cat) -> felt252 {\n        self.noise\n    }\n}\n\nimpl CowImpl of AnimalTrait<Cow> {\n    fn new() -> Cow {\n        Cow { noise: 'moo' }\n    }\n\n    fn make_noise(self: Cow) -> felt252 {\n        self.noise\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_traits2() {\n    let kitty: Cat = AnimalTrait::new();\n    assert(kitty.make_noise() == 'meow', 'Wrong noise');\n\n    let cow: Cow = AnimalTrait::new();\n    assert(cow.make_noise() == 'moo', 'Wrong noise');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// This code is using Starknet components to make a reusable owner feature.\n// This should add OwnableComponent containing functionality which any contracts can include.\n// But something is fishy here as this component is not working, can you find the error and make the tests pass?\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IOwnable<TContractState> {\n    fn owner(self: @TContractState) -> ContractAddress;\n    fn set_owner(ref self: TContractState, new_owner: ContractAddress);\n}\n\npub mod OwnableComponent {\n    use starknet::ContractAddress;\n    use super::IOwnable;\n\n    #[storage]\n    pub struct Storage {\n        owner: ContractAddress,\n    }\n\n    #[embeddable_as(Ownable)]\n    impl OwnableImpl<\n        TContractState, +HasComponent<TContractState>\n    > of IOwnable<ComponentState<TContractState>> {\n        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n            self.owner.read()\n        }\n        fn set_owner(ref self: ComponentState<TContractState>, new_owner: ContractAddress) {\n            self.owner.write(new_owner);\n        }\n    }\n}\n\n#[starknet::contract]\npub mod OwnableCounter {\n    use starknet::ContractAddress;\n    use super::OwnableComponent;\n\n    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);\n\n    #[abi(embed_v0)]\n    impl OwnableImpl = OwnableComponent::Ownable<ContractState>;\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        #[flat]\n        OwnableEvent: OwnableComponent::Event,\n    }\n    #[storage]\n    pub struct Storage {\n        counter: u128,\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::IOwnableDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::{contract_address_const, ContractAddress};\n    use super::IOwnableDispatcher;\n\n    fn deploy_ownable_counter() -> IOwnableDispatcher {\n        let contract = declare(\"OwnableCounter\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IOwnableDispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_contract_read() {\n        let dispatcher = deploy_ownable_counter();\n        dispatcher.set_owner(contract_address_const::<0>());\n        assert(contract_address_const::<0>() == dispatcher.owner(), 'Some fuck up happened');\n    }\n}\n```\n\nHint: Is there maybe a decorator that annotates that a module is a component? 🤔🤔🤔\n",
      "chat_history": "",
      "context": "The provided `raw_context` is a large HTML snippet of a website's footer and header, which does not contain any technical documentation or code examples relevant to Cairo or Starknet components. Therefore, no information can be extracted or summarized from the `raw_context` to directly address the user's query. The solution will be based on general knowledge of Cairo's component system.",
      "expected": "// This code is using Starknet components to make a reusable owner feature.\n// This should add OwnableComponent containing functionality which any contracts can include.\n// But something is fishy here as this component is not working, can you find the error and make the tests pass?\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IOwnable<TContractState> {\n    fn owner(self: @TContractState) -> ContractAddress;\n    fn set_owner(ref self: TContractState, new_owner: ContractAddress);\n}\n\n#[starknet::component]\npub mod OwnableComponent {\n    use starknet::ContractAddress;\n    use starknet::storage::*;\n    use super::IOwnable;\n\n    #[storage]\n    pub struct Storage {\n        owner: ContractAddress,\n    }\n\n    #[embeddable_as(Ownable)]\n    impl OwnableImpl<\n        TContractState, +HasComponent<TContractState>\n    > of IOwnable<ComponentState<TContractState>> {\n        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n            self.owner.read()\n        }\n        fn set_owner(ref self: ComponentState<TContractState>, new_owner: ContractAddress) {\n            self.owner.write(new_owner);\n        }\n    }\n}\n\n#[starknet::contract]\npub mod OwnableCounter {\n    use starknet::ContractAddress;\n    use super::OwnableComponent;\n\n    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);\n\n    #[abi(embed_v0)]\n    impl OwnableImpl = OwnableComponent::Ownable<ContractState>;\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        #[flat]\n        OwnableEvent: OwnableComponent::Event,\n    }\n    #[storage]\n    pub struct Storage {\n        counter: u128,\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::IOwnableDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::{contract_address_const, ContractAddress};\n    use super::IOwnableDispatcher;\n\n    fn deploy_ownable_counter() -> IOwnableDispatcher {\n        let contract = declare(\"OwnableCounter\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IOwnableDispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_contract_read() {\n        let dispatcher = deploy_ownable_counter();\n        dispatcher.set_owner(contract_address_const::<0>());\n        assert(contract_address_const::<0>() == dispatcher.owner(), 'Some fuck up happened');\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// This exercise doesn't do anything yet but it still compiles! Cairo file getting run\n// needs to have a `main` function. So this file is a valid Cairo file.\n// Other exercises will require you to write Cairo code to make the exercise file compile.\n\n// I AM NOT DONE\n\nfn main() {}\n```\n\nHint: No hints this time ;)\n",
      "chat_history": "",
      "context": "The Cairo core library provides utilities for array, span, and byte array manipulation, as well as Starknet-specific functionalities.\n\n### `core::array::SpanTrait<T>`\nA trait for operations on `Span<T>`.\n-   **`fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`**\n    Pops a value from the front of the span. Returns `Some(@value)` if not empty, `None` otherwise.\n    ```cairo\n    let mut span = array![1, 2, 3].span();\n    assert!(span.pop_front() == Some(@1));\n    ```\n-   **`fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>`**\n    Pops a value from the back of the span. Returns `Some(@value)` if not empty, `None` otherwise.\n    ```cairo\n    let mut span = array![1, 2, 3].span();\n    assert!(span.pop_back() == Some(@3));\n    ```\n-   **`fn slice<T, T>(self: Span<T>, start: u32, length: u32) -> Span<T>`**\n    Returns a new span containing a slice of the original span.\n    ```cairo\n    let span = array![1, 2, 3].span();\n    assert!(span.slice(1, 2) == array![2, 3].span());\n    ```\n-   **`fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`**\n    Pops multiple values from the front of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if successful, `None` otherwise.\n    ```cairo\n    let mut span = array![1, 2, 3].span();\n    let result = *(span.multi_pop_front::<2>().unwrap());\n    let unboxed_result = result.unbox();\n    assert!(unboxed_result == [1, 2]);\n    ```\n-   **`fn multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>`**\n    Pops multiple values from the back of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if successful, `None` otherwise.\n    ```cairo\n    let mut span = array![1, 2, 3].span();\n    let result = *(span.multi_pop_back::<2>().unwrap());\n    let unboxed_result = result.unbox();\n    assert!(unboxed_result == [2, 3]);\n    ```\n\n### `core::array::ToSpanTrait<C, T>`\nA trait to convert a data structure into a span of its data.\n-   **`fn span<C, T, C, T>(self: @C) -> Span<T>`**\n    Returns a span pointing to the data in the input.\n\n### `core::array::ArrayTrait<T>`\nA trait for operations on `Array<T>`.\n-   **`fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)`**\n    Appends a span of elements to the end of the array.\n    ```cairo\n    let mut arr: Array<u8> = array![];\n    arr.append_span(array![1, 2, 3].span());\n    assert!(arr == array![1, 2, 3]);\n    ```\n\n### `core::byte_array::ByteArrayTrait`\nA trait for operations on `ByteArray`.\n-   **`fn append_word(ref self: ByteArray, word: felt252, len: u32)`**\n    Appends a word (felt252) to the end of the `ByteArray`.\n    ```cairo\n    let mut ba = \"\";\n    ba.append_word('word', 4);\n    assert!(ba == \"word\");\n    ```\n-   **`fn append(ref self: ByteArray, other: ByteArray)`**\n    Appends a `ByteArray` to the end of another `ByteArray`.\n    ```cairo\n    let mut ba: ByteArray = \"1\";\n    ba.append(@\"2\");\n    assert!(ba == \"12\");\n    ```\n-   **`fn concat(left: ByteArray, right: ByteArray) -> ByteArray`**\n    Concatenates two `ByteArray`s and returns the result. The content of `left` is cloned in a new memory segment.\n    ```cairo\n    let ba = \"1\";\n    let other_ba = \"2\";\n    let result = ByteArrayTrait::concat(@ba, @other_ba);\n    assert!(result == \"12\");\n    ```\n\n### `core::starknet::testing`\nUtilities for Starknet contract testing.\n-   **`pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;`**\n    Returns a span containing the cheatcode's output.\n-   **`pub fn pop_log<T, +starknet::Event<T>>(address: ContractAddress) -> Option<T>`**\n    Pops an event log from a contract address.\n    ```cairo\n    #[starknet::contract]\n    mod contract {\n       #[event]\n       #[derive(Copy, Drop, Debug, PartialEq, starknet::Event)]\n       pub enum Event {\n          Event1: felt252,\n          Event2: u128,\n       }\n       // ...\n    }\n\n    #[test]\n    fn test_event() {\n        let contract_address = somehow_get_contract_address();\n        call_code_causing_events(contract_address);\n        assert_eq!(\n            starknet::testing::pop_log(contract_address), Some(contract::Event::Event1(42))\n        );\n        assert_eq!(\n            starknet::testing::pop_log(contract_address), Some(contract::Event::Event2(41))\n        );\n        assert_eq!(\n            starknet::testing::pop_log(contract_address), Some(contract::Event::Event1(40))\n        );\n        assert_eq!(starknet::testing::pop_log_raw(contract_address), None);\n    }\n    ```\n\n### `core::starknet::contract_address`\n-   **`pub extern fn contract_address_const() -> ContractAddress nopanic;`**\n    Returns a constant contract address.\n    ```cairo\n    use starknet::contract_address::contract_address_const;\n\n    let contract_address = contract_address_const::<0x0>();\n    ```\n\n### `core::starknet::info`\nFunctions to retrieve execution information.\n-   **`pub fn get_execution_info() -> Box<ExecutionInfo>`**\n    Returns a boxed `ExecutionInfo` struct containing details about the current execution context.\n    ```cairo\n    use starknet::get_execution_info;\n\n    let execution_info = get_execution_info().unbox();\n\n    // Access various execution context information\n    let caller = execution_info.caller_address;\n    let contract = execution_info.contract_address;\n    let selector = execution_info.entry_point_selector;\n    ```\n-   **`pub fn get_contract_address() -> ContractAddress`**\n    Returns the address of the currently executing contract.\n    ```cairo\n    use starknet::get_contract_address;\n\n    let contract_address = get_contract_address();\n    ```",
      "expected": "// This exercise doesn't do anything yet but it still compiles! Cairo file getting run\n// needs to have a `main` function. So this file is a valid Cairo file.\n// Other exercises will require you to write Cairo code to make the exercise file compile.\n\nfn main() {}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// This store is having a sale where if the price is an even number, you get\n// 10 Cairobucks off, but if it's an odd number, it's 3 Cairobucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\n// I AM NOT DONE\n\nfn main() {\n    let original_price = 51;\n    println!(\"sale_price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: u32) -> {\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: u32) -> bool {\n    num % 2 == 0\n}\n```\n\nHint: The error message points to line 18 and says it expects a type after the\n`->`. This is where the function's return type should be -- take a look at\nthe `is_even` function for an example!\n",
      "chat_history": "",
      "context": "In Cairo, function signatures specify the return type after the `->` symbol.\n\n**Examples of Cairo Function Signatures with Return Types:**\n\n*   `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n    *   Returns an `Option` containing a snapshot of type `T`.\n*   `pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;`\n    *   Returns a `Span<felt252>`.\n*   `fn span<T, T>(snapshot: @Array<T>) -> Span<T>`\n    *   Returns a `Span<T>`.\n*   `fn slice<T, T>(self: Span<T>, start: u32, length: u32) -> Span<T>`\n    *   Returns a `Span<T>`. Note the use of `u32` for `start` and `length` parameters.\n*   `fn concat(left: ByteArray, right: ByteArray) -> ByteArray`\n    *   Returns a `ByteArray`.\n*   `fn at<T, T>(self: Span<T>, index: u32) -> @T`\n    *   Returns a snapshot of type `T`.\n\nThe `u32` type is a common integer type used for lengths and indices, as seen in `slice` and `at` function signatures.",
      "expected": "// This store is having a sale where if the price is an even number, you get\n// 10 Cairobucks off, but if it's an odd number, it's 3 Cairobucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\n\n\nfn main() {\n    let original_price = 51;\n    println!(\"sale_price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: u32) -> u32 {\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: u32) -> bool {\n    num % 2 == 0\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Time to implement some traits!\n\n// Your task is to implement the trait\n// `AnimalTrait` for the type `Animal`\n//\n\n// Fill in the impl block to make the code work.\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Animal {\n    noise: felt252\n}\n\ntrait AnimalTrait {\n    fn new(noise: felt252) -> Animal;\n    fn make_noise(self: Animal) -> felt252;\n}\n\nimpl AnimalImpl of AnimalTrait { // TODO: implement the trait AnimalTrait for Animal\n}\n\n#[cfg(test)]\n#[test]\nfn test_traits1() {\n    // TODO make the test pass by creating two instances of Animal\n    // and calling make_noise on them\n\n    assert(cat.make_noise() == 'meow', 'Wrong noise');\n    assert(cow.make_noise() == 'moo', 'Wrong noise');\n}\n```\n\nHint: \nIf you want to implement a trait for a type, you have to implement all the methods in the trait.\nBased on the signature of the method, you can easily implement it.\n\nIn the test, you need to instantiate two objects of type `Animal`.\nYou can call the method of a trait by using the MyTrait::foo() syntax.\nHow would you instantiate the two objects with AnimalTrait?\nMaybe you need to specify the type of the object?\nhttps://book.cairo-lang.org/ch08-02-traits-in-cairo.html\n",
      "chat_history": "",
      "context": "In Cairo, `struct`s are custom data types that can be defined using the `struct` keyword, similar to C structs. They can have fields of various types. For example:\n```cairo\n#[derive(Drop, Debug)]\nstruct Person {\n    name: ByteArray,\n    age: u8,\n}\n```\n\n`felt252` can be used to represent short string literals by enclosing them in single quotes, e.g., `'meow'` or `'moo'`.\n\nTraits define shared behavior across different types. To implement a trait for a specific type, you use the `impl` keyword followed by the implementation name, the `of` keyword, the trait name, and finally the type for which the trait is being implemented. All functions and associated functions defined in the trait must be implemented within the `impl` block.\n\nAn example of trait implementation for `fmt::Display` shows the general structure:\n```cairo\nuse core::fmt::{Formatter, Display};\nuse core::fmt;\n\n#[derive(Drop)]\nstruct City {\n    name: ByteArray,\n    lat: i32,\n    lon: i32,\n}\n\nimpl CityDisplay of Display<City> {\n    fn fmt(self: @City, ref f: Formatter) -> Result<(), fmt::Error> {\n        // Implementation details\n        write!(f, \"{}: {}'{} {}'{}\", self.name, *self.lat, lat_c, *self.lon, lon_c)\n    }\n}\n```\n\nWithin an `impl` block, functions can be associated functions (like static methods) or methods. Associated functions are called using the `TraitName::function_name()` syntax, while methods are called on an instance using `instance.method_name()`.\n\nAttributes like `#[derive(Copy, Drop)]` are metadata applied to items, enabling automatic implementation of certain traits (`Copy` for types that can be duplicated by simple bitwise copy, `Drop` for types that can be safely dropped from memory). `#[cfg(test)]` and `#[test]` are used for conditional compilation and marking functions as unit tests, respectively.",
      "expected": "// Time to implement some traits!\n\n// Your task is to implement the trait\n// `AnimalTrait` for the type `Animal`\n//\n\n// Fill in the impl block to make the code work.\n\n\n\n#[derive(Copy, Drop)]\nstruct Animal {\n    noise: felt252\n}\n\ntrait AnimalTrait {\n    fn new(noise: felt252) -> Animal;\n    fn make_noise(self: Animal) -> felt252;\n}\n\nimpl AnimalImpl of AnimalTrait { // TODO: implement the trait AnimalTrait for Animal\n    fn new(noise: felt252) -> Animal {\n        Animal { noise }\n    }\n\n    fn make_noise(self: Animal) -> felt252 {\n        self.noise\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_traits1() {\n    // TODO make the test pass by creating two instances of Animal\n    // and calling make_noise on them\n    let cat = AnimalTrait::new('meow');\n    let cow = AnimalTrait::new('moo');\n\n    assert(cat.make_noise() == 'meow', 'Wrong noise');\n    assert(cow.make_noise() == 'moo', 'Wrong noise');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// We are writing an app for a restaurant,\n// but take_order functions are not being called correctly.\n// Can you fix this?\n\n// I AM NOT DONE\n\npub mod restaurant {\n    pub fn take_order() -> felt252 {\n        'order_taken'\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_mod_fn() {\n    // Fix this line to call take_order function from module\n    let order_result = take_order();\n\n    assert(order_result == 'order_taken', 'Order not taken');\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_super_fn() {\n        // Fix this line to call take_order function\n        let order_result = take_order();\n\n        assert(order_result == 'order_taken', 'Order not taken');\n    }\n}\n```\n\nHint: You can bring a parent's modules items in the current module with super::item_name\n",
      "chat_history": "",
      "context": "The provided context does not contain information relevant to Cairo's module system, function calling conventions across modules, or the use of `super::` or `crate::` for path resolution. It details various `corelib` functionalities such as:\n\n*   **`core::starknet::event::Event`**:\n    *   `append_keys_and_data`: `fn append_keys_and_data<T, T>(self: @T, ref keys: Array<felt252>, ref data: Array<felt252>)` - Serializes event keys and data.\n    *   `deserialize`: `fn deserialize<T, T>(ref keys: Span<felt252>, ref data: Span<felt252>) -> Option<T>` - Deserializes event keys and data.\n*   **`core::starknet::storage::vec::MutableVecTrait`**:\n    *   `append`: `fn append<T, T>(self: T) -> StoragePath<Mutable<MutableVecTrait<T>ElementType>>` - Allocates space for a new element at the end of a storage vector.\n*   **`core::option::OptionTrait`**:\n    *   `pub trait OptionTrait<T>` - Trait for `Option<T>` operations.\n    *   `filter`: `fn filter<T, T, P, +core::ops::FnOnce<P, (@T,)>[Output: bool], +Destruct<T>, +Destruct<P>>(self: Option<T>, predicate: P) -> Option<T>` - Filters an `Option` based on a predicate.\n    *   `flatten`: Converts `Option<Option<T>>` to `Option<T>`.\n*   **`core::array::SpanTrait`**:\n    *   `multi_pop_back`: `fn multi_pop_back<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>` - Pops multiple values from the back.\n    *   `get`: `fn get<T, T>(self: Span<T>, index: u32) -> Option<Box<@T>>` - Returns an option containing a snapshot of the element at `index`.\n    *   `pop_front`: `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>` - Pops a value from the front.\n    *   `pop_back`: `fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>` - Pops a value from the back.\n    *   `slice`: `fn slice<T, T>(self: Span<T>, start: u32, length: u32) -> Span<T>` - Returns a sub-span.\n    *   `len`: Returns the length of the span as `usize`.\n    *   `at`: `fn at<T, T>(self: Span<T>, index: u32) -> @T` - Returns a snapshot of the element at `index`.\n    *   `multi_pop_front`: `fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>` - Pops multiple values from the front.\n*   **`core::array::ToSpanTrait`**:\n    *   `pub trait ToSpanTrait<C, T>` - Trait to convert a data structure into a span.\n    *   `span`: `fn span<C, T, C, T>(self: @C) -> Span<T>` - Returns a span pointing to the data.\n*   **`core::array::ArrayTrait`**:\n    *   `append_span`: `fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)` - Adds a span to the end of the array.\n    *   `pop_front`: Pops a value from the front of the array.\n    *   `append`: `fn append<T, T>(ref self: Array<T>, value: T)` - Appends a value to the end of the array.\n*   **`core::byte_array::ByteArrayTrait`**:\n    *   `concat`: `fn concat(left: ByteArray, right: ByteArray) -> ByteArray` - Concatenates two `ByteArray`s.\n    *   `append_byte`: Appends a single byte.\n    *   `append_word`: `fn append_word(ref self: ByteArray, word: felt252, len: u32)` - Appends a word.\n    *   `append`: Appends a `ByteArray`.\n*   **`core::starknet::testing`**:\n    *   `cheatcode`: `pub extern fn cheatcode(input: Span<felt252>) -> Span<felt252> nopanic;` - Executes a cheatcode.\n*   **`core::starknet::info`**:\n    *   `get_execution_info`: `pub fn get_execution_info() -> Box<ExecutionInfo>` - Returns execution context information.\n    *   `get_contract_address`: `pub fn get_contract_address() -> ContractAddress` - Returns the current contract address.",
      "expected": "// We are writing an app for a restaurant,\n// but take_order functions are not being called correctly.\n// Can you fix this?\n\npub mod restaurant {\n    pub fn take_order() -> felt252 {\n        'order_taken'\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_mod_fn() {\n    // Fix this line to call take_order function from module\n    let order_result = restaurant::take_order();\n\n    assert(order_result == 'order_taken', 'Order not taken');\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_super_fn() {\n        // Fix this line to call take_order function\n        let order_result = super::restaurant::take_order();\n\n        assert(order_result == 'order_taken', 'Order not taken');\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// You can't change anything except adding or removing references.\n\n// I AM NOT DONE\n\n#[derive(Drop)]\nstruct Number {\n    value: u32, \n}\n\nfn main() {\n    let mut number = Number { value: 1111111 };\n\n    get_value(number);\n\n    set_value(number);\n}\n\n// Should not take ownership and not modify the variable passed.\nfn get_value(number: Number) -> u32 {\n    number.value\n}\n\n// Should take ownership\nfn set_value(number: Number) {\n    let value = 2222222;\n    number = Number { value };\n    println!(\"Number is: {}\", number.value);\n}\n```\n\nHint: The first problem is that `get_value` is taking ownership of the Number struct.\nSo `Number` is moved and can't be used for `set_value`\n`number` is moved to `get_value` first, meaning that `set_value` cannot manipulate the data.\nWhat can we use to pass an immutable reference to `get_value`? What special operator do we use for that?\nWhat other operator do we use to \"desnap\" a snapshot?\nHint: It involves the `@` and `*` operators.\n\nOnce you've fixed that, `set_value`'s function signature will also need to be adjusted.\nCan you figure out how?\n",
      "chat_history": "",
      "context": "Cairo's ownership system allows for different ways to access data without always transferring ownership.\n\n**Retaining Ownership**\nTo access data without taking ownership, Cairo provides two mechanisms:\n*   **Snapshots (`@T`)**: An immutable view into memory cells at a specific state. When an object is passed by snapshot (`@T`), the function receives an immutable copy of the pointer to the data. The original variable's ownership is not transferred, and the data cannot be mutated through the snapshot.\n*   **References (`ref T`)**: A syntactic sugar for a variable whose ownership is transferred, can be mutated, and returned back to the original owner. When an object is passed by reference (`ref T`), the function receives a mutable pointer to the data. The original variable's ownership is not transferred, but the data can be mutated through the reference.\n\n**Dereferencing (`*`)**\nTo access the value contained within a snapshot or a reference, the dereference operator `*` is used. For example, if `s` is a snapshot (`@T`), then `*s` accesses the value of type `T`. Similarly, if `r` is a mutable reference (`ref T`), `*r` accesses the value of type `T` and allows modification.\n\n**Structures (`struct`)**\nStructures (structs) are custom data types that can group related data. They are defined using the `struct` keyword.\n```cairo\n#[derive(Drop, Debug)]\nstruct Person {\n    name: ByteArray,\n    age: u8,\n}\n```\nFields of a struct can be accessed using dot notation (e.g., `point.x`). Structs can also be destructured using `let` bindings.\n\n**Formatted Print (`println!`)**\nThe `println!` macro is used for printing formatted text to the console. It supports positional arguments and various formatting specifiers. For example, `println!(\"{} days\", 31)` or `println!(\"Base 16 (hexadecimal): {:x}\", 69420)`. Types must implement `core::fmt::Display` for `{}` formatting or `core::fmt::Debug` for `{:?}` formatting. Primitive types like `u32` typically implement `Display`.",
      "expected": "// You can't change anything except adding or removing references.\n\n#[derive(Drop)]\nstruct Number {\n    value: u32,\n}\n\nfn main() {\n    let mut number = Number { value: 1111111 };\n\n    get_value(@number);\n\n    set_value(number);\n}\n\n// Should not take ownership and not modify the variable passed.\nfn get_value(number: @Number) -> u32 {\n    *number.value\n}\n\n// Should take ownership\nfn set_value(mut number: Number) {\n    let value = 2222222;\n    number = Number { value };\n    println!(\"Number is: {}\", number.value);\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Your task is to create an `Array` which holds three elements of type `felt252`.\n// The first element should be 0.\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\nfn create_array() -> Array<felt252> {\n    let a = ArrayTrait::new(); // something to change here...\n    a.append(1);\n    a\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_array_len() {\n    let mut a = create_array();\n    assert(a.len() == 3, 'Array length is not 3');\n    assert(a.pop_front().unwrap() == 0, 'First element is not 0');\n}\n```\n\nHint: You can declare an array in Cairo using the following syntax:\n`let your_array = ArrayTrait::new();`\nYou can append elements to an array using the following syntax:\n`your_array.append(element);`\n\nThe `pop_front` method removes the first element from the array and returns an Option::Some(value) if the array is not empty, or Option::None() if the array is empty.\n",
      "chat_history": "",
      "context": "The Cairo core library provides traits and implementations for various collection types, including `Array`, `Span`, `ByteArray`, and `Vec` (for storage).\n\n### Array Operations\n\n*   **`ArrayTrait::append_span`**: Appends a `Span` of elements to the end of an `Array`.\n    ```cairo\n    fn append_span<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>, span: Span<T>)\n    ```\n    **Example:**\n    ```cairo\n    let mut arr: Array<u8> = array![];\n    arr.append_span(array![1, 2, 3].span());\n    assert!(arr == array![1, 2, 3]);\n    ```\n\n### Span Operations\n\n`Span` represents a view into a contiguous sequence of elements.\n\n*   **`SpanTrait::pop_front`**: Pops a value from the front of the span. Returns `Some(@value)` if the span is not empty, `None` otherwise.\n    ```cairo\n    fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>\n    ```\n    **Example:**\n    ```cairo\n    let mut span = array![1, 2, 3].span();\n    assert!(span.pop_front() == Some(@1));\n    ```\n*   **`SpanTrait::pop_back`**: Pops a value from the back of the span. Returns `Some(@value)` if the span is not empty, `None` otherwise.\n    ```cairo\n    fn pop_back<T, T>(ref self: Span<T>) -> Option<@T>\n    ```\n    **Example:**\n    ```cairo\n    let mut span = array![1, 2, 3].span();\n    assert!(span.pop_back() == Some(@3));\n    ```\n*   **`SpanTrait::multi_pop_front`**: Pops multiple values from the front of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if successful, `None` otherwise.\n    ```cairo\n    fn multi_pop_front<T, T, SIZE>(ref self: Span<T>) -> Option<Box<[T; SIZE]>>\n    ```\n    **Example:**\n    ```cairo\n    let mut span = array![1, 2, 3].span();\n    let result = *(span.multi_pop_front::<2>().unwrap());\n    let unboxed_result = result.unbox();\n    assert!(unboxed_result == [1, 2]);\n    ```\n*   **`SpanTrait::multi_pop_back`**: Pops multiple values from the back of the span. Returns an option containing a snapshot of a box that contains the values as a fixed-size array if successful, `None` otherwise.\n*   **`SpanTrait::len`**: Returns the length of the span as a `usize` value.\n*   **`SpanTrait::slice`**: Returns a new `Span` representing a sub-section of the original span.\n    ```cairo\n    fn slice<T, T>(self: Span<T>, start: u32, length: u32) -> Span<T>\n    ```\n    **Example:**\n    ```cairo\n    let span = array![1, 2, 3].span();\n    assert!(span.slice(1, 2) == array![2, 3].span());\n    ```\n*   **`SpanTrait::get`**: Returns a snapshot of the element at the given index. Element at index 0 is the front of the array.\n    ```cairo\n    fn get<T, T>(self: Span<T>, index: u32) -> Option<Box<@T>>\n    ```\n    **Example:**\n    ```cairo\n    let span = array![2, 3, 4];\n    assert!(span.get(1).unwrap().unbox() == @3);\n    ```\n\n### Conversion to Span\n\n*   **`ToSpanTrait`**: A trait that converts a data structure into a span of its data.\n    ```cairo\n    pub trait ToSpanTrait<C, T>\n    ```\n    *   **`ToSpanTrait::span`**: Returns a span pointing to the data in the input.\n        ```cairo\n        fn span<C, T, C, T>(self: @C) -> Span<T>\n        ```\n\n### ByteArray Operations\n\n`ByteArray` is a sequence of bytes.\n\n*   **`ByteArrayImpl::append_word`**: Appends a `felt252` word and its length to the `ByteArray`.\n    ```cairo\n    fn append_word(ref self: ByteArray, word: felt252, len: u32)\n    ```\n    **Example:**\n    ```cairo\n    let mut ba = \"\";\n    ba.append_word('word', 4);\n    assert!(ba == \"word\");\n    ```\n*   **`ByteArrayTrait::append`**: Appends another `ByteArray` to the end of the current `ByteArray`.\n    ```cairo\n    fn append(ref self: ByteArray, other: ByteArray)\n    ```\n    **Example:**\n    ```cairo\n    let mut ba: ByteArray = \"1\";\n    ba.append(@\"2\");\n    assert!(ba == \"12\");\n    ```\n*   **`ByteArrayImpl::concat`**: Concatenates two `ByteArray`s and returns the result. The content of `left` is cloned in a new memory segment.\n    ```cairo\n    fn concat(left: ByteArray, right: ByteArray) -> ByteArray\n    ```\n    **Example:**\n    ```cairo\n    let ba = \"1\";\n    let other_ba = \"2\";\n    let result = ByteArrayTrait::concat(@ba, @other_ba);\n    assert!(result == \"12\");\n    ```\n*   **`ByteArrayTrait::append_byte`**: Appends a single byte to the end of the `ByteArray`. (No signature or example provided in context).\n\n### Storage Vector Operations (`Vec`)\n\n`Vec` is a growable list of elements stored in contract storage.\n\n*   **`MutableVecTrait::append` (deprecated)**: Allocates space for a new element at the end of the vector, returning a mutable storage path to write the element. This function is a replacement for the deprecated `append` function, which allowed appending new elements to a vector.\n    ```cairo\n    fn append<T, T>(self: T) -> StoragePath<Mutable<MutableVecTrait<T>ElementType>>\n    ```\n    **Example:**\n    ```cairo\n    use starknet::storage::{Vec, MutableVecTrait, StoragePointerWriteAccess};\n\n    #[storage]\n    struct Storage {\n        numbers: Vec<u256>,\n    }\n\n    fn push_number(ref self: ContractState, number: u256) {\n        self.numbers.append().write(number);\n    }\n    ```\n*   **`allocate`**: This function is a replacement for the deprecated `append` function, specifically useful when you need to prepare space for elements of unknown or dynamic size.",
      "expected": "// Your task is to create an `Array` which holds three elements of type `felt252`.\n// The first element should be 0.\n// Make me compile and pass the test!\n\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new();\n    a.append(0);\n    a.append(1);\n    a.append(2);\n    a\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_array_len() {\n    let mut a = create_array();\n    assert(a.len() == 3, 'Array length is not 3');\n    assert(a.pop_front().unwrap() == 0, 'First element is not 0');\n}"
    },
    {
      "query": "Complete the following Cairo code:\n\n```cairo\n// Your task is to make the test pass without modifying the `create_array` function.\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\n// Don't modify this function\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new();\n    a.append(42);\n    a\n}\n\nfn remove_element_from_array(\n    ref a: Array<felt252>\n) { //TODO something to do here...Is there an array method I can use?\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2() {\n    let mut a = create_array();\n    assert(*a.at(0) == 42, 'First element is not 42');\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2_empty() {\n    let mut a = create_array();\n    remove_element_from_array(ref a);\n    assert(a.len() == 0, 'Array length is not 0');\n}\n```\n\nHint: How can you remove the first element from the array?\nTake a look at the previous exercise for a hint. Don't forget to call `.unwrap()` on the returned value.\nThis will prevent the `Variable not dropped` error.\n",
      "chat_history": "",
      "context": "The `core::array::ArrayTrait` provides a `pop_front` function to remove the first element from an `Array`.\n\n**`ArrayTrait::pop_front`**\n- **Fully qualified path:** `core::array::ArrayTrait::pop_front`\n- **Signature:** `fn pop_front<T, T, +Clone<T>, +Drop<T>>(ref self: Array<T>) -> Option<T>`\n- **Description:** Pops a value from the front of the array. Returns `Some(value)` if the array is not empty, `None` otherwise.\n\n**Example Usage (Conceptual, based on signature):**\n```cairo\nlet mut arr: Array<felt252> = array![42];\nlet popped_value = arr.pop_front().unwrap(); // Removes 42 from arr, arr becomes empty.\nassert(arr.len() == 0, 'Array should be empty');\nassert(popped_value == 42, 'Popped value should be 42');\n```\n\nThe `core::array::SpanTrait` also has a `pop_front` method, but it operates on a `Span` (a view into an array) and modifies the span's internal pointer, not the original `Array`'s length.\n- **Fully qualified path:** `core::array::SpanTrait::pop_front`\n- **Signature:** `fn pop_front<T, T>(ref self: Span<T>) -> Option<@T>`\n- **Example:**\n  ```cairo\n  let mut span = array![1, 2, 3].span();\n  assert!(span.pop_front() == Some(@1));\n  ```\n\nTo modify the `Array` directly and reduce its length, `ArrayTrait::pop_front` is the correct method. The `unwrap()` call is necessary to handle the `Option` return type and prevent `Variable not dropped` errors.",
      "expected": "// Your task is to make the test pass without modifying the `create_array` function.\n// Make me compile and pass the test!\n\n\n\n// Don't modify this function\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new();\n    a.append(42);\n    a\n}\n\nfn remove_element_from_array(ref a: Array<felt252>) {\n    let _ = a.pop_front();\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2() {\n    let mut a = create_array();\n    assert(a.len() == 1, 'Array should have one element');\n    assert(*a.at(0) == 42, 'First element should be 42');\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2_empty() {\n    let mut a = create_array();\n    remove_element_from_array(ref a);\n    assert(a.len() == 0, 'Array length is not 0');\n}"
    }
  ],
  "metadata": {
    "count": 52,
    "source": "starklings",
    "generated_at": "2025-07-16 17:57:26"
  }
}
