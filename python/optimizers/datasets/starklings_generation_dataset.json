{
  "examples": [
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n//\n// The previous exercise showed how to implement a trait for multiple types.\n// This exercise shows how you can implement multiple traits for a single type.\n// This is useful when you have types that share some common functionality, but\n// also have some unique functionality.\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Fish {\n    noise: felt252,\n    distance: u32,\n}\n\n#[derive(Copy, Drop)]\nstruct Dog {\n    noise: felt252,\n    distance: u32,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n    fn get_distance(self: T) -> u32;\n}\n\ntrait FishTrait {\n    fn swim(ref self: Fish) -> ();\n}\n\ntrait DogTrait {\n    fn walk(ref self: Dog) -> ();\n}\n\nimpl AnimalFishImpl of AnimalTrait<Fish> {\n    fn new() -> Fish {\n        Fish { noise: 'blub', distance: 0 }\n    }\n    fn make_noise(self: Fish) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Fish) -> u32 {\n        self.distance\n    }\n}\n\nimpl AnimalDogImpl of AnimalTrait<Dog> {\n    fn new() -> Dog {\n        Dog { noise: 'woof', distance: 0 }\n    }\n    fn make_noise(self: Dog) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Dog) -> u32 {\n        self.distance\n    }\n}\n\n// TODO: implement FishTrait for the type Fish\n\n// TODO: implement DogTrait for the type Dog\n\n#[cfg(test)]\n#[test]\nfn test_traits3() {\n    // Don't modify this test!\n    let mut salmon: Fish = AnimalTrait::new();\n    salmon.swim();\n    assert!(salmon.make_noise() == 'blub', \"Wrong noise\");\n    assert!(salmon.get_distance() == 1, \"Wrong distance\");\n\n    let mut dog: Dog = AnimalTrait::new();\n    dog.walk();\n    assert!(dog.make_noise() == 'woof', \"Wrong noise\");\n    assert!(dog.get_distance() == 1, \"Wrong distance\");\n}\n```\n\nHint: \nYou can implement multiple traits for a type.\nWhen a trait is destined to be implemented by a single type, you don't need to use generics.\nIf you're having trouble updating the distance value in the `Fish` and `Dog` impls, remember that you need to first\n1. Destructure the object into mutable variables\n2. Update the distance variable\n3. Reconstruct `self` with the updated variables (`self = MyStruct { ... }`) \n",
      "reference": "//\n// The previous exercise showed how to implement a trait for multiple types.\n// This exercise shows how you can implement multiple traits for a single type.\n// This is useful when you have types that share some common functionality, but\n// also have some unique functionality.\n\n\n\n#[derive(Copy, Drop)]\nstruct Fish {\n    noise: felt252,\n    distance: u32,\n}\n\n#[derive(Copy, Drop)]\nstruct Dog {\n    noise: felt252,\n    distance: u32,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n    fn get_distance(self: T) -> u32;\n}\n\ntrait FishTrait {\n    fn swim(ref self: Fish) -> ();\n}\n\ntrait DogTrait {\n    fn walk(ref self: Dog) -> ();\n}\n\nimpl AnimalFishImpl of AnimalTrait<Fish> {\n    fn new() -> Fish {\n        Fish { noise: 'blub', distance: 0 }\n    }\n    fn make_noise(self: Fish) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Fish) -> u32 {\n        self.distance\n    }\n}\n\nimpl AnimalDogImpl of AnimalTrait<Dog> {\n    fn new() -> Dog {\n        Dog { noise: 'woof', distance: 0 }\n    }\n    fn make_noise(self: Dog) -> felt252 {\n        self.noise\n    }\n    fn get_distance(self: Dog) -> u32 {\n        self.distance\n    }\n}\n\nimpl FishTraitImpl of FishTrait {\n    fn swim(ref self: Fish) {\n        self.distance += 1;\n    }\n}\n\nimpl DogTraitImpl of DogTrait {\n    fn walk(ref self: Dog) {\n        self.distance += 1;\n    }\n}\n\n#[test]\nfn test_traits3() {\n    // Don't modify this test!\n    let mut salmon: Fish = AnimalTrait::new();\n    salmon.swim();\n    assert!(salmon.make_noise() == 'blub', \"Wrong noise\");\n    assert!(salmon.get_distance() == 1, \"Wrong distance\");\n\n    let mut dog: Dog = AnimalTrait::new();\n    dog.walk();\n    assert!(dog.make_noise() == 'woof', \"Wrong noise\");\n    assert!(dog.get_distance() == 1, \"Wrong distance\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Order {\n    name: felt252,\n    year: felt252,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: felt252,\n    count: felt252,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: 'Bob',\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0\n    }\n}\n#[cfg(test)]\n#[test]\nfn test_your_order() {\n    let order_template = create_order_template();\n    // TODO: Destructure your order into multiple variables to make the assertions pass!\n    // let ...\n\n    assert!(name == 'Bob', \"Wrong name\");\n    assert!(year == order_template.year, \"Wrong year\");\n    assert!(made_by_phone == order_template.made_by_phone, \"Wrong phone\");\n    assert!(made_by_mobile == order_template.made_by_mobile, \"Wrong mobile\");\n    assert!(made_by_email == order_template.made_by_email, \"Wrong email\");\n    assert!(item_number == order_template.item_number, \"Wrong item number\");\n    assert!(count == 0, \"Wrong count\");\n}\n```\n\nHint: Cairo requires you to initialize all fields when creating a struct and there is no update syntax available at the moment.\nYou can have multiple data types in a struct, and even other structs.\n\nThere are some shortcuts that can be taken when destructuring structs,\n```\nlet Foo {x, y} = foo; // Creates variables x and y with values foo.x and foo.y\nlet Foo {x: a, y: b} = foo; // Creates variables a and b with values foo.x and foo.y\n```\nRead more about structs in the Structs section of this article: https://book.cairo-lang.org/ch05-01-defining-and-instantiating-structs.html ",
      "reference": "// Address all the TODOs to make the tests pass!\n\n#[derive(Copy, Drop)]\nstruct Order {\n    name: felt252,\n    year: felt252,\n    made_by_phone: bool,\n    made_by_mobile: bool,\n    made_by_email: bool,\n    item_number: felt252,\n    count: felt252,\n}\n\nfn create_order_template() -> Order {\n    Order {\n        name: 'Bob',\n        year: 2019,\n        made_by_phone: false,\n        made_by_mobile: false,\n        made_by_email: true,\n        item_number: 123,\n        count: 0\n    }\n}\n#[cfg(test)]\n#[test]\nfn test_your_order() {\n    let order_template = create_order_template();\n    // TODO: Destructure your order into multiple variables to make the assertions pass!\n    let Order { name, year, made_by_phone, made_by_mobile, made_by_email, item_number, count } = order_template;\n\n    assert!(name == 'Bob', \"Wrong name\");\n    assert!(year == order_template.year, \"Wrong year\");\n    assert!(made_by_phone == order_template.made_by_phone, \"Wrong phone\");\n    assert!(made_by_mobile == order_template.made_by_mobile, \"Wrong mobile\");\n    assert!(made_by_email == order_template.made_by_email, \"Wrong email\");\n    assert!(item_number == order_template.item_number, \"Wrong item number\");\n    assert!(count == 0, \"Wrong count\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n\n#[derive(Drop, Copy)]\nenum Message { // TODO: implement the message variant types based on their usage below\n}\n\n#[derive(Drop, Copy)]\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\n#[derive(Drop, Copy)]\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\ntrait StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8));\n    fn quit(ref self: State);\n    fn echo(ref self: State, s: felt252);\n    fn move_position(ref self: State, p: Point);\n    fn process(ref self: State, message: Message);\n}\nimpl StateImpl of StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8)) {\n        let State { color: _, position, quit } = self;\n        self = State { color: new_color, position: position, quit: quit };\n    }\n    fn quit(ref self: State) {\n        let State { color, position, quit: _ } = self;\n        self = State { color: color, position: position, quit: true };\n    }\n\n    fn echo(ref self: State, s: felt252) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(ref self: State, p: Point) {\n        let State { color, position: _, quit } = self;\n        self = State { color: color, position: p, quit: quit };\n    }\n\n    fn process(\n        ref self: State, message: Message,\n    ) { // TODO: create a match expression to process the different message variants\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_match_message_call() {\n    let mut state = State { quit: false, position: Point { x: 0, y: 0 }, color: (0, 0, 0) };\n    state.process(Message::ChangeColor((255, 0, 255)));\n    state.process(Message::Echo('hello world'));\n    state.process(Message::Move(Point { x: 10, y: 15 }));\n    state.process(Message::Quit);\n\n    assert(state.color == (255, 0, 255), 'wrong color');\n    assert!(state.position.x == 10, \"wrong x position\");\n    assert!(state.position.y == 15, \"wrong y position\");\n    assert!(state.quit == true, \"quit should be true\");\n}\n```\n\nHint: As a first step, you can define enums to compile this code without errors.\nand then create a match expression in `process()`.\nNote that you need to deconstruct some message variants\nin the match expression to get value in the variant.\nhttps://book.cairo-lang.org/ch06-01-enums.html\n",
      "reference": "// Address all the TODOs to make the tests pass!\n\n\n\n#[derive(Drop, Copy)]\nenum Message {\n    Quit,\n    Echo: felt252,\n    Move: Point,\n    ChangeColor: (u8, u8, u8),\n}\n\n#[derive(Drop, Copy)]\nstruct Point {\n    x: u8,\n    y: u8,\n}\n\n#[derive(Drop, Copy)]\nstruct State {\n    color: (u8, u8, u8),\n    position: Point,\n    quit: bool,\n}\n\ntrait StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8));\n    fn quit(ref self: State);\n    fn echo(ref self: State, s: felt252);\n    fn move_position(ref self: State, p: Point);\n    fn process(ref self: State, message: Message);\n}\nimpl StateImpl of StateTrait {\n    fn change_color(ref self: State, new_color: (u8, u8, u8)) {\n        let State { color: _, position, quit } = self;\n        self = State { color: new_color, position: position, quit: quit };\n    }\n    fn quit(ref self: State) {\n        let State { color, position, quit: _ } = self;\n        self = State { color: color, position: position, quit: true };\n    }\n\n    fn echo(ref self: State, s: felt252) {\n        println!(\"{}\", s);\n    }\n\n    fn move_position(ref self: State, p: Point) {\n        let State { color, position: _, quit } = self;\n        self = State { color: color, position: p, quit: quit };\n    }\n\n    fn process(\n        ref self: State, message: Message,\n    ) {\n        match message {\n            Message::Quit => self.quit(),\n            Message::Echo(s) => self.echo(s),\n            Message::Move(p) => self.move_position(p),\n            Message::ChangeColor(c) => self.change_color(c),\n        }\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_match_message_call() {\n    let mut state = State { quit: false, position: Point { x: 0, y: 0 }, color: (0, 0, 0) };\n    state.process(Message::ChangeColor((255, 0, 255)));\n    state.process(Message::Echo('hello world'));\n    state.process(Message::Move(Point { x: 10, y: 15 }));\n    state.process(Message::Quit);\n\n    assert(state.color == (255, 0, 255), 'wrong color');\n    assert!(state.position.x == 10, \"wrong x position\");\n    assert!(state.position.y == 15, \"wrong y position\");\n    assert!(state.quit, \"quit should be true\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n\n#[starknet::interface]\ntrait IContractA<TContractState> {\n    fn set_value(ref self: TContractState, value: u128) -> bool;\n    fn get_value(self: @TContractState) -> u128;\n}\n\n\n#[starknet::contract]\nmod ContractA {\n    use starknet::ContractAddress;\n    use super::IContractBDispatcher;\n    use super::IContractBDispatcherTrait;\n\n    #[storage]\n    struct Storage {\n        contract_b: ContractAddress,\n        value: u128,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, contract_b: ContractAddress) {\n        self.contract_b.write(contract_b)\n    }\n\n    #[abi(embed_v0)]\n    impl ContractAImpl of super::IContractA<ContractState> {\n        fn set_value(ref self: ContractState, value: u128) -> bool {\n            // TODO: check if contract_b is enabled.\n            // If it is, set the value and return true. Otherwise, return false.\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IContractB<TContractState> {\n    fn enable(ref self: TContractState);\n    fn disable(ref self: TContractState);\n    fn is_enabled(self: @TContractState) -> bool;\n}\n\n#[starknet::contract]\nmod ContractB {\n    #[storage]\n    struct Storage {\n        enabled: bool\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {}\n\n    #[abi(embed_v0)]\n    impl ContractBImpl of super::IContractB<ContractState> {\n        fn enable(ref self: ContractState) {\n            self.enabled.write(true);\n        }\n\n        fn disable(ref self: ContractState) {\n            self.enabled.write(false);\n        }\n\n        fn is_enabled(self: @ContractState) -> bool {\n            self.enabled.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::ContractAddress;\n    use super::{IContractBDispatcher, IContractADispatcher, IContractADispatcherTrait, IContractBDispatcherTrait};\n\n\n    fn deploy_contract_b() -> IContractBDispatcher {\n        let contract = declare(\"ContractB\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IContractBDispatcher { contract_address }\n    }\n\n    fn deploy_contract_a(contract_b_address: ContractAddress) -> IContractADispatcher {\n        let contract = declare(\"ContractA\").unwrap().contract_class();\n        let constructor_calldata = array![contract_b_address.into()];\n        let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();\n        IContractADispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_interoperability() {\n        // Deploy ContractB\n        let contract_b = deploy_contract_b();\n\n        // Deploy ContractA\n        let contract_a = deploy_contract_a(contract_b.contract_address);\n\n        //TODO interact with contract_b to make the test pass.\n\n        // Tests\n        assert!(contract_a.set_value(300) == true, \"Could not set value\");\n        assert!(contract_a.get_value() == 300, \"Value was not set\");\n        assert!(contract_b.is_enabled() == true, \"Contract b is not enabled\");\n    }\n}\n```\n\nHint: \nYou can call other contracts from inside a contract. To do this, you will need to create a Dispatcher object\nof the type of the called contract. Dispatchers have associated methods available under the `DispatcherTrait`, corresponding to the external functions of the contract that you want to call.\n",
      "reference": "// Address all the TODOs to make the tests pass!\n\n\n\n#[starknet::interface]\ntrait IContractA<TContractState> {\n    fn set_value(ref self: TContractState, value: u128) -> bool;\n    fn get_value(self: @TContractState) -> u128;\n}\n\n\n#[starknet::contract]\nmod ContractA {\n    use starknet::ContractAddress;\n    use super::IContractBDispatcher;\n    use super::IContractBDispatcherTrait;\n    use starknet::storage::*;\n\n    #[storage]\n    struct Storage {\n        contract_b: ContractAddress,\n        value: u128,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, contract_b: ContractAddress) {\n        self.contract_b.write(contract_b)\n    }\n\n    #[abi(embed_v0)]\n    impl ContractAImpl of super::IContractA<ContractState> {\n        fn set_value(ref self: ContractState, value: u128) -> bool {\n            // TODO: check if contract_b is enabled.\n            // If it is, set the value and return true. Otherwise, return false.\n            let contract_b = self.contract_b.read();\n            let contract_b_dispatcher = IContractBDispatcher { contract_address: contract_b };\n            if contract_b_dispatcher.is_enabled() {\n                self.value.write(value);\n                return true;\n            }\n            return false;\n        }\n\n        fn get_value(self: @ContractState) -> u128 {\n            self.value.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IContractB<TContractState> {\n    fn enable(ref self: TContractState);\n    fn disable(ref self: TContractState);\n    fn is_enabled(self: @TContractState) -> bool;\n}\n\n#[starknet::contract]\nmod ContractB {\n    use starknet::storage::*;\n\n    #[storage]\n    struct Storage {\n        enabled: bool\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState) {}\n\n    #[abi(embed_v0)]\n    impl ContractBImpl of super::IContractB<ContractState> {\n        fn enable(ref self: ContractState) {\n            self.enabled.write(true);\n        }\n\n        fn disable(ref self: ContractState) {\n            self.enabled.write(false);\n        }\n\n        fn is_enabled(self: @ContractState) -> bool {\n            self.enabled.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::ContractAddress;\n    use super::{IContractBDispatcher, IContractADispatcher, IContractADispatcherTrait, IContractBDispatcherTrait};\n\n\n    fn deploy_contract_b() -> IContractBDispatcher {\n        let contract = declare(\"ContractB\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IContractBDispatcher { contract_address }\n    }\n\n    fn deploy_contract_a(contract_b_address: ContractAddress) -> IContractADispatcher {\n        let contract = declare(\"ContractA\").unwrap().contract_class();\n        let constructor_calldata = array![contract_b_address.into()];\n        let (contract_address, _) = contract.deploy(@constructor_calldata).unwrap();\n        IContractADispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_interoperability() {\n        // Deploy ContractB\n        let contract_b = deploy_contract_b();\n\n        // Deploy ContractA\n        let contract_a = deploy_contract_a(contract_b.contract_address);\n\n        // Enable contract_b to make the test pass\n        contract_b.enable();\n\n        // Tests\n        assert!(contract_a.set_value(300) == true, \"Could not set value\");\n        assert!(contract_a.get_value() == 300, \"Value was not set\");\n        assert!(contract_b.is_enabled() == true, \"Contract b is not enabled\");\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Address all the TODOs to make the tests pass!\n\n// I AM NOT DONE\n#[derive(Copy, Drop)]\nstruct ColorStruct { // TODO: Something goes here\n// TODO: Your struct needs to have red, green, blue felts\n}\n\n\n#[cfg(test)]\n#[test]\nfn classic_c_structs() {\n    // TODO: Instantiate a classic color struct!\n    // Green color neeeds to have green set to 255 and, red and blue, set to 0\n    // let green =\n\n    assert(green.red == 0, 0);\n    assert(green.green == 255, 0);\n    assert(green.blue == 0, 0);\n}\n```\n\nHint: Cairo has a single type of struct that are named collections of related data stored in fields.\nIn this exercise you need to complete and implement a struct.\nHere is how we describe a person struct that stores a name and an age,\n\n#[derive(Copy, Drop)]\nstruct Person {\n    name: felt252,\n    age: felt252,\n}\n\nYou'd use the struct like so,\n\nlet john = Person { name: 'John', age: 29 };\n\n\nRead more about structs in the Structs section of this article: https://book.cairo-lang.org/ch05-01-defining-and-instantiating-structs.html ",
      "reference": "// Address all the TODOs to make the tests pass!\n\n#[derive(Copy, Drop)]\nstruct ColorStruct {\n    red: u8,\n    green: u8,\n    blue: u8,\n}\n\n\n#[cfg(test)]\n#[test]\nfn classic_c_structs() {\n    // TODO: Instantiate a classic color struct!\n    // Green color neeeds to have green set to 255 and, red and blue, set to 0\n    let green = ColorStruct { red: 0, green: 255, blue: 0 };\n\n    assert(green.red == 0, 0);\n    assert(green.green == 255, 0);\n    assert(green.blue == 0, 0);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Custom data structure using dicts\n// Using Felt252Dict in structs allow us to simulate mutable data structures\n// In this exercise we have a struct Team where a Felt252Dict maps the name of a player to its level and keeps track of\n// the number of player.\n// Using the methods set and get from the Felt252DictTrait, implement the required functions to interact with the team\n// Make me compile and pass the test!\n\n// I AM NOT DONE\nuse core::dict::Felt252Dict;\n\n#[derive(Destruct)]\nstruct Team {\n    level: Felt252Dict<usize>,\n    players_count: usize\n}\n\n#[generate_trait]\nimpl TeamImpl of TeamTrait {\n    fn new() -> Team {\n        //TODO : initialize empty team with 0 player\n    }\n\n    fn get_level(ref self: Team, name: felt252) -> usize {\n        //TODO\n    }\n\n    fn add_player(ref self: Team, name: felt252, level: usize) -> () {\n        //TODO\n    }\n\n    fn level_up(ref self: Team, name: felt252) {\n        //TODO\n    }\n\n    fn players_count(self: @Team) -> usize {\n        //TODO\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_add_player() {\n    let mut team = TeamTrait::new();\n    team.add_player('bob', 10);\n    team.add_player('alice', 20);\n\n    assert!(team.players_count == 2, \"Wrong number of player\");\n    assert!(team.get_level('bob') == 10, \"Wrong level\");\n    assert!(team.get_level('alice') == 20, \"Wrong level\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_level_up() {\n    let mut team = TeamTrait::new();\n    team.add_player('bobby', 10);\n    team.level_up('bobby');\n\n    assert!(team.level.get('bobby') == 11, \"Wrong level\");\n}\n```\n\nHint: Example of dicts can be found in this chapter :\nhttps://book.cairo-lang.org/ch03-02-dictionaries.html\n",
      "reference": "// Custom data structure using dicts\n// Using Felt252Dict in structs allow us to simulate mutable data structures\n// In this exercise we have a struct Team where a Felt252Dict maps the name of a player to its level and keeps track of\n// the number of player.\n// Using the methods set and get from the Felt252DictTrait, implement the required functions to interact with the team\n// Make me compile and pass the test!\n\nuse core::dict::Felt252Dict;\n\n#[derive(Destruct)]\nstruct Team {\n    level: Felt252Dict<usize>,\n    players_count: usize\n}\n\n#[generate_trait]\nimpl TeamImpl of TeamTrait {\n    fn new() -> Team {\n        Team {\n            level: Default::default(),\n            players_count: 0\n        }\n    }\n\n    fn get_level(ref self: Team, name: felt252) -> usize {\n        self.level.get(name)\n    }\n\n    fn add_player(ref self: Team, name: felt252, level: usize) -> () {\n        self.level.insert(name, level);\n        self.players_count += 1;\n    }\n\n    fn level_up(ref self: Team, name: felt252) {\n        let current_level = self.level.get(name);\n        self.level.insert(name, current_level + 1);\n    }\n\n    fn players_count(self: @Team) -> usize {\n        *self.players_count\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_add_player() {\n    let mut team = TeamTrait::new();\n    team.add_player('bob', 10);\n    team.add_player('alice', 20);\n\n    assert!(team.players_count == 2, \"Wrong number of player\");\n    assert!(team.get_level('bob') == 10, \"Wrong level\");\n    assert!(team.get_level('alice') == 20, \"Wrong level\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_level_up() {\n    let mut team = TeamTrait::new();\n    team.add_player('bobby', 10);\n    team.level_up('bobby');\n\n    assert!(team.level.get('bobby') == 11, \"Wrong level\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Destructure the `cat` tuple to call print on each member.\n\n// I AM NOT DONE\n\nfn main() {\n    let cat = ('Furry McFurson', 3);\n    let // your pattern here = cat;\n    println!(\"name is {}\", name);\n    println!(\"age is {}\", age);\n}\n```\n\nHint: You'll need to make a pattern to bind `name` and `age` to the appropriate parts\nof the tuple.\nIf you're familiar with Rust, you should know that Cairo has a similar syntax to \ndestructure tuples into multiple variables.\nhttps://book.cairo-lang.org/ch02-02-data-types.html?highlight=destructu#the-tuple-type\nYou can do it!!\n",
      "reference": "// Destructure the `cat` tuple to call print on each member.\n\n\n\nfn main() {\n    let cat = ('Furry McFurson', 3);\n    let (name, age) = cat;\n    println!(\"name is {}\", name);\n    println!(\"age is {}\", age);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Dictionaries can be used to simulate dynamic array : the value they store can be accessed and modified.\n// Your task is to create a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\nuse core::dict::Felt252Dict;\n\n\nfn multiply_element_by_10(ref dict: Felt252Dict<u32>, n: usize) {\n    //TODO : make a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n\n\n}\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_3() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 3);\n\n    multiply_element_by_10(ref dict, 3);\n\n    assert!(dict.get(0) == 10, \"First element is not 10\");\n    assert!(dict.get(1) == 20, \"Second element is not 20\");\n    assert!(dict.get(2) == 30, \"Third element is not 30\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_4() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 5);\n    dict.insert(3, 10);\n\n    multiply_element_by_10(ref dict, 4);\n\n    assert!(dict.get(2) == 50, \"First element is not 50\");\n    assert!(dict.get(3) == 100, \"First element is not 100\");\n\n}\n```\n\nHint: More info about the Felt252Dict type can be found in the following chapter :\nhttps://book.cairo-lang.org/ch03-02-dictionaries.html\n",
      "reference": "// Dictionaries can be used to simulate dynamic array : the value they store can be accessed and modified.\n// Your task is to create a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n// Make me compile and pass the test!\n\nuse core::dict::Felt252Dict;\n\nfn multiply_element_by_10(ref dict: Felt252Dict<u32>, n: usize) {\n    //TODO : make a function that multiplies the elements stored at the indexes 0 to n of a dictionary by 10\n    for i in 0..n {\n        let current_value = dict.get(i.into());\n        dict.insert(i.into(), current_value * 10);\n    }\n}\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_3() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 3);\n\n    multiply_element_by_10(ref dict, 3);\n\n    assert!(dict.get(0) == 10, \"First element is not 10\");\n    assert!(dict.get(1) == 20, \"Second element is not 20\");\n    assert!(dict.get(2) == 30, \"Third element is not 30\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_4() {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    dict.insert(0, 1);\n    dict.insert(1, 2);\n    dict.insert(2, 5);\n    dict.insert(3, 10);\n\n    multiply_element_by_10(ref dict, 4);\n\n    assert!(dict.get(2) == 50, \"First element is not 50\");\n    assert!(dict.get(3) == 100, \"First element is not 100\");\n\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // A short string is a string whose length is at most 31 characters, and therefore can fit into a single field element.\n    // Short strings are actually felts, they are not a real string.\n    // Note the _single_ quotes that are used with short strings.\n\n    let mut my_first_initial = 'C';\n    if is_alphabetic(\n        ref my_first_initial\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref my_first_initial\n    ) {\n        println!(\" Numerical !\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n\n    let  // Finish this line like the example! What's your favorite short string?\n    // Try a letter, try a number, try a special character, try a short string!\n    if is_alphabetic(\n        ref your_character\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref your_character\n    ) {\n        println!(\" Numerical!\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n}\n\nfn is_alphabetic(ref char: felt252) -> bool {\n    if char >= 'a' {\n        if char <= 'z' {\n            return true;\n        }\n    }\n    if char >= 'A' {\n        if char <= 'Z' {\n            return true;\n        }\n    }\n    false\n}\n\nfn is_numeric(ref char: felt252) -> bool {\n    if char >= '0' {\n        if char <= '9' {\n            return true;\n        }\n    }\n    false\n}\n\n// Note: the following code is not part of the challenge, it's just here to make the code above work.\n// Direct felt252 comparisons have been removed from the core library, so we need to implement them ourselves.\n// There will probably be a string / short string type in the future\nimpl PartialOrdFelt of PartialOrd<felt252> {\n    #[inline(always)]\n    fn le(lhs: felt252, rhs: felt252) -> bool {\n        !(rhs < lhs)\n    }\n    #[inline(always)]\n    fn ge(lhs: felt252, rhs: felt252) -> bool {\n        !(lhs < rhs)\n    }\n    #[inline(always)]\n    fn lt(lhs: felt252, rhs: felt252) -> bool {\n        let lhs_u256: u256 = lhs.into();\n        let rhs_u256: u256 = rhs.into();\n        lhs_u256 < rhs_u256\n    }\n    #[inline(always)]\n    fn gt(lhs: felt252, rhs: felt252) -> bool {\n        rhs < lhs\n    }\n}\n```\n\nHint: No hints this time ;)",
      "reference": "// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\nfn main() {\n    // A short string is a string whose length is at most 31 characters, and therefore can fit into a single field element.\n    // Short strings are actually felts, they are not a real string.\n    // Note the _single_ quotes that are used with short strings.\n\n    let mut my_first_initial = 'C';\n    if is_alphabetic(\n        ref my_first_initial\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref my_first_initial\n    ) {\n        println!(\" Numerical !\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n\n    let mut your_character = 'A'; // Finish this line like the example! What's your favorite short string?\n    // Try a letter, try a number, try a special character, try a short string!\n    if is_alphabetic(\n        ref your_character\n    ) {\n        println!(\" Alphabetical !\");\n    } else if is_numeric(\n        ref your_character\n    ) {\n        println!(\" Numerical!\");\n    } else {\n        println!(\" Neither alphabetic nor numeric!\");\n    }\n}\n\nfn is_alphabetic(ref char: felt252) -> bool {\n    if char >= 'a' {\n        if char <= 'z' {\n            return true;\n        }\n    }\n    if char >= 'A' {\n        if char <= 'Z' {\n            return true;\n        }\n    }\n    false\n}\n\nfn is_numeric(ref char: felt252) -> bool {\n    if char >= '0' {\n        if char <= '9' {\n            return true;\n        }\n    }\n    false\n}\n\n// Note: the following code is not part of the challenge, it's just here to make the code above work.\n// Direct felt252 comparisons have been removed from the core library, so we need to implement them ourselves.\n// There will probably be a string / short string type in the future\nimpl PartialOrdFelt of PartialOrd<felt252> {\n    #[inline(always)]\n    fn le(lhs: felt252, rhs: felt252) -> bool {\n        !(rhs < lhs)\n    }\n    #[inline(always)]\n    fn ge(lhs: felt252, rhs: felt252) -> bool {\n        !(lhs < rhs)\n    }\n    #[inline(always)]\n    fn lt(lhs: felt252, rhs: felt252) -> bool {\n        let lhs_u256: u256 = lhs.into();\n        let rhs_u256: u256 = rhs.into();\n        lhs_u256 < rhs_u256\n    }\n    #[inline(always)]\n    fn gt(lhs: felt252, rhs: felt252) -> bool {\n        rhs < lhs\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n// I AM NOT DONE\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let // Finish the rest of this line like the example! Or make it be false!\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}\n```\n\nHint: No hints this time ;)",
      "reference": "// Fill in the rest of the line that has code missing!\n// No hints, there's no tricks, just get used to typing these :)\n\n\n\nfn main() {\n    // Booleans (`bool`)\n\n    let is_morning = true;\n    if is_morning {\n        println!(\"Good morning!\");\n    }\n\n    let is_evening = false;\n    if is_evening {\n        println!(\"Good evening!\");\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\n#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n\n    let result = loop {\n        if counter == 5 {\n    //TODO return a value from the loop\n        }\n        counter += 1;\n    };\n\n    assert!(result == 5, \"result should be 5\");\n}\n```\n\nHint: You can return values from loops by adding the value you want returned after the `break` expression you use to stop the loop. Don't forget that assigning a variable to the value returned from a `loop` is an expression, and thus must end with a semicolomn.\n",
      "reference": "#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n\n    let result = loop {\n        if counter == 5 {\n            break counter;\n        }\n        counter += 1;\n    };\n\n    assert!(result == 5, \"result should be 5\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\n#[cfg(test)]\n#[test]\nfn test_options() {\n    let target = 'starklings';\n    let optional_some = Option::Some(target);\n    let optional_none: Option<felt252> = Option::None;\n    simple_option(optional_some);\n    simple_option(optional_none);\n}\n\nfn simple_option(optional_target: Option<felt252>) {\n    // TODO: use the `is_some` and `is_none` methods to check if `optional_target` contains a value.\n    // Place the assertion and the print statement below in the correct blocks.\n    assert!(optional_target.unwrap() == 'starklings', \"err1\");\n    println!(\" option is empty ! \");\n}\n```\n\nHint: check out: https://github.com/starkware-libs/cairo/blob/main/corelib/src/option.cairo\nto see the implementation of the Option type and its methods.\n",
      "reference": "#[cfg(test)]\n#[test]\nfn test_options() {\n    let target = 'starklings';\n    let optional_some = Option::Some(target);\n    let optional_none: Option<felt252> = Option::None;\n    simple_option(optional_some);\n    simple_option(optional_none);\n}\n\nfn simple_option(optional_target: Option<felt252>) {\n    // TODO: use the `is_some` and `is_none` methods to check if `optional_target` contains a value.\n    // Place the assertion and the print statement below in the correct blocks.\n    if optional_target.is_some() {\n        assert!(optional_target.unwrap() == 'starklings');\n        println!(\" option is empty ! \");\n    } else {\n        assert!(optional_target.is_none());\n        println!(\" option is empty ! \");\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\n#[derive(Drop)]\nstruct Student {\n    name: felt252,\n    courses: Array<Option<felt252>>,\n}\n\n\nfn display_grades(student: @Student) {\n    let mut msg = ArrayTrait::new();\n    msg.append(*student.name);\n    msg.append('\\'s grades:');\n    println!(\"{:?}\", msg);\n\n    for course in student.courses.span() {\n        // TODO: Modify the following lines so that if there is a grade for the course, it is printed.\n        //       Otherwise, print \"No grade\".\n        //\n        println!(\"grade is {}\", course.unwrap());\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_all_defined() {\n    let courses = array![\n        Option::Some('A'),\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::Some('A'),\n    ];\n    let mut student = Student { name: 'Alice', courses: courses };\n    display_grades(@student);\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_some_empty() {\n    let courses = array![\n        Option::Some('A'),\n        Option::None,\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::None,\n    ];\n    let mut student = Student { name: 'Bob', courses: courses };\n    display_grades(@student);\n}\n```\n\nHint: Reminder: You can use a match statement with an Option to handle both the Some and None cases.\nThis syntax is more flexible than using unwrap, which only handles the Some case, and contributes to more robust code.\n",
      "reference": "#[derive(Drop)]\nstruct Student {\n    name: felt252,\n    courses: Array<Option<felt252>>,\n}\n\n\nfn display_grades(student: @Student) {\n    let mut msg = ArrayTrait::new();\n    msg.append(*student.name);\n    msg.append('\\'s grades:');\n    println!(\"{:?}\", msg);\n\n    for course in student.courses.span() {\n        if course.is_some() {\n            println!(\"grade is {}\", course.unwrap());\n        } else {\n            println!(\"No grade\");\n        }\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_all_defined() {\n    let courses = array![\n        Option::Some('A'),\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::Some('A'),\n    ];\n    let mut student = Student { name: 'Alice', courses: courses };\n    display_grades(@student);\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_some_empty() {\n    let courses = array![\n        Option::Some('A'),\n        Option::None,\n        Option::Some('B'),\n        Option::Some('C'),\n        Option::None,\n    ];\n    let mut student = Student { name: 'Bob', courses: courses };\n    display_grades(@student);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\n// This function returns how much icecream there is left in the fridge.\n// If it's before 10PM, there's 5 pieces left. At 10PM, someone eats them\n// all, so there'll be no more left :(\nfn maybe_icecream(\n    time_of_day: usize\n) -> Option<usize> { // We use the 24-hour system here, so 10PM is a value of 22 and 12AM is a value of 0\n// The Option output should gracefully handle cases where time_of_day > 23.\n// TODO: Complete the function body - remember to return an Option!\n}\n\n\n#[cfg(test)]\n#[test]\nfn check_icecream() {\n    assert!(maybe_icecream(9).unwrap() == 5, \"err_1\");\n    assert!(maybe_icecream(10).unwrap() == 5, \"err_2\");\n    assert!(maybe_icecream(23).unwrap() == 0, \"err_3\");\n    assert!(maybe_icecream(22).unwrap() == 0, \"err_4\");\n    assert!(maybe_icecream(25).is_none(), \"err_5\");\n}\n\n#[cfg(test)]\n#[test]\nfn raw_value() {\n    // TODO: Fix this test. How do you get at the value contained in the Option?\n    let icecreams = maybe_icecream(12);\n    assert!(icecreams == 5, \"err_6\");\n}\n```\n\nHint: Options can have a Some value, with an inner value, or a None value, without an inner value.\nThere's multiple ways to get at the inner value, you can use unwrap, or pattern match. Unwrapping\nis the easiest, but how do you do it safely so that it doesn't panic in your face later?\nhttps://book.cairo-lang.org/ch06-01-enums.html#the-option-enum-and-its-advantages\n",
      "reference": "// This function returns how much icecream there is left in the fridge.\n// If it's before 10PM, there's 5 pieces left. At 10PM, someone eats them\n// all, so there'll be no more left :(\nfn maybe_icecream(\n    time_of_day: usize\n) -> Option<usize> {\n    if time_of_day > 23 {\n        None\n    } else if time_of_day < 22 {\n        Some(5)\n    } else {\n        Some(0)\n    }\n}\n\n\n#[cfg(test)]\n#[test]\nfn check_icecream() {\n    assert!(maybe_icecream(9).unwrap() == 5, \"err_1\");\n    assert!(maybe_icecream(10).unwrap() == 5, \"err_2\");\n    assert!(maybe_icecream(23).unwrap() == 0, \"err_3\");\n    assert!(maybe_icecream(22).unwrap() == 0, \"err_4\");\n    assert!(maybe_icecream(25).is_none(), \"err_5\");\n}\n\n#[cfg(test)]\n#[test]\nfn raw_value() {\n    // TODO: Fix this test. How do you get at the value contained in the Option?\n    let icecreams = maybe_icecream(12);\n    assert!(icecreams.unwrap() == 5, \"err_6\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\nconst NUMBER = 3;\nconst SMALL_NUMBER = 3_u8;\nfn main() {\n    println!(\"NUMBER is {}\", NUMBER);\n    println!(\"SMALL_NUMBER is {}\", SMALL_NUMBER);\n}\n```\n\nHint: We know about variables and mutability, but there is another important type of\nvariable available: constants.\nConstants are always immutable and they are declared with keyword 'const' rather\nthan keyword 'let'.\nConstants types must also always be annotated.\nYou can read about the constants here: https://book.cairo-lang.org/ch02-01-variables-and-mutability.html?highlight=const#constants\n",
      "reference": "const NUMBER: felt252 = 3;\nconst SMALL_NUMBER: u8 = 3_u8;\nfn main() {\n    println!(\"NUMBER is {}\", NUMBER);\n    println!(\"SMALL_NUMBER is {}\", SMALL_NUMBER);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n\nfn call_me(num: u64) {\n    println!(\"num is {}\", num);\n}\n```\n\nHint: This time, the function *declaration* is okay, but there's something wrong\nwith the place where we're calling the function.\nAs a reminder, you can freely play around with different solutions in Starklings!\nWatch mode will only jump to the next exercise if you remove the I AM NOT DONE comment.",
      "reference": "fn main() {\n    call_me(5);\n}\n\nfn call_me(num: u64) {\n    println!(\"num is {}\", num);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    call_me();\n}\n```\n\nHint: This main function is calling a function that it expects to exist, but the\nfunction doesn't exist. It expects this function to have the name `call_me`.\nIt expects this function to not take any arguments and not return a value.\nSounds a lot like `main`, doesn't it?",
      "reference": "fn main() {\n    call_me();\n}\n\nfn call_me() {\n    println!(\"Hello, world!\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    call_me(3);\n}\n\nfn call_me(num:) {\n    println!(\"num is {}\", num);\n}\n```\n\nHint: Cairo requires that all parts of a function's signature have type annotations,\nbut `call_me` is missing the type annotation of `num`. What is the basic type in Cairo?",
      "reference": "fn main() {\n    call_me(3);\n}\n\nfn call_me(num: u32) {\n    println!(\"num is {}\", num);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    let number = 1_u8; // don't change this line\n    println!(\"number is {}\", number);\n    number = 3; // don't rename this variable\n    println!(\"number is {}\", number);\n}\n```\n\nHint: In variables4 we already learned how to make an immutable variable mutable\nusing a special keyword. Unfortunately this doesn't help us much in this exercise\nbecause we want to assign a different typed value to an existing variable. Sometimes\nyou may also like to reuse existing variable names because you are just converting\nvalues to different types like in this exercise.\nFortunately Cairo has a powerful solution to this problem: 'Shadowing'!\nYou can see an example of variables and 'shadowing' here: https://book.cairo-lang.org/ch02-01-variables-and-mutability.html?highlight=shadow#shadowing\nYou can read about the different integer types here: https://book.cairo-lang.org/ch02-02-data-types.html#integer-types\nTry to solve this exercise afterwards using this technique.",
      "reference": "fn main() {\n    let mut number = 1_u8;\n    println!(\"number is {}\", number);\n    number = 3; // don't rename this variable\n    println!(\"number is {}\", number);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    let x = 3;\n    println!(\"x is {}\", x);\n    x = 5; // don't change this line\n    println!(\"x is now {}\", x);\n}\n```\n\nHint: In Cairo, variable bindings are immutable by default. But here we're trying\nto reassign a different value to x! There's a keyword we can use to make\na variable binding mutable instead.",
      "reference": "fn main() {\n    let mut x = 3;\n    println!(\"x is {}\", x);\n    x = 5; // don't change this line\n    println!(\"x is now {}\", x);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    let x: felt252;\n    println!(\"x is {}\", x);\n}\n```\n\nHint: Oops! In this exercise, we have a variable binding that we've created on\nline 7, and we're trying to use it on line 8, but we haven't given it a\nvalue. We can't print out something that isn't there; try giving x a value!\nThis is an error that can cause bugs that's very easy to make in any\nprogramming language -- thankfully the Cairo compiler has caught this for us!",
      "reference": "fn main() {\n    let x: felt252 = 0;\n    println!(\"x is {}\", x);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\nfn main() {\n    let x;\n    if x == 10 {\n       println!(\"x is ten! \");\n    } else {\n        println!(\"x is not ten! \");\n    }\n}\n```\n\nHint: What happens if you annotate line 7 with a type annotation?\nWhat if you give x a value?\nWhat if you do both?\nWhat type should x be, anyway? (remember what the basic type in Cairo is?)\nWhat if x is the same type as 10? What if it's a different type? (e.g. a u8)",
      "reference": "fn main() {\n    let x = 10;\n    if x == 10 {\n       println!(\"x is ten! \");\n    } else {\n        println!(\"x is not ten! \");\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n\nuse core::fmt::{Display, Formatter, Error};\n\n#[derive(Copy, Drop)]\nenum Message { // TODO: define the different variants used below\n}\n\n\nfn main() { // don't change any of the lines inside main\n    let mut messages: Array<Message> = ArrayTrait::new();\n\n    //don't change any of the next 4 lines\n    messages.append(Message::Quit);\n    messages.append(Message::Echo('hello world'));\n    messages.append(Message::Move((10, 30)));\n    messages.append(Message::ChangeColor((0, 255, 255)));\n\n    print_messages_recursive(messages, 0)\n}\n\n// Utility function to print messages. Don't modify these.\n\ntrait MessageTrait<T> {\n    fn call(self: T);\n}\n\nimpl MessageImpl of MessageTrait<Message> {\n    fn call(self: Message) {\n        println!(\"{}\", self);\n    }\n}\n\nfn print_messages_recursive(messages: Array<Message>, index: u32) {\n    if index >= messages.len() {\n        return ();\n    }\n    let message = *messages.at(index);\n    message.call();\n    print_messages_recursive(messages, index + 1)\n}\n\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        println!(\"___MESSAGE BEGINS___\");\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo(msg) => format!(\"{}\", msg),\n            Message::Move((a, b)) => { format!(\"{} {}\", a, b) },\n            Message::ChangeColor((red, green, blue)) => { format!(\"{} {} {}\", red, green, blue) },\n        };\n        f.buffer.append(@str);\n        println!(\"___MESSAGE ENDS___\");\n        Result::Ok(())\n    }\n}\n```\n\nHint: You can create enumerations that have different variants with different types\nsuch as no data, structs, a single felt string, tuples, ...etc\nhttps://book.cairo-lang.org/ch06-01-enums.html\n",
      "reference": "use core::fmt::{Display, Formatter, Error};\n\n#[derive(Copy, Drop)]\nenum Message {\n    Quit,\n    Echo: felt252,\n    Move: (u32, u32),\n    ChangeColor: (u8, u8, u8),\n}\n\n\nfn main() { // don't change any of the lines inside main\n    let mut messages: Array<Message> = ArrayTrait::new();\n\n    //don't change any of the next 4 lines\n    messages.append(Message::Quit);\n    messages.append(Message::Echo('hello world'));\n    messages.append(Message::Move((10, 30)));\n    messages.append(Message::ChangeColor((0, 255, 255)));\n\n    print_messages_recursive(messages, 0)\n}\n\n// Utility function to print messages. Don't modify these.\n\ntrait MessageTrait<T> {\n    fn call(self: T);\n}\n\nimpl MessageImpl of MessageTrait<Message> {\n    fn call(self: Message) {\n        println!(\"{}\", self);\n    }\n}\n\nfn print_messages_recursive(messages: Array<Message>, index: u32) {\n    if index >= messages.len() {\n        return ();\n    }\n    let message = *messages.at(index);\n    message.call();\n    print_messages_recursive(messages, index + 1)\n}\n\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        println!(\"___MESSAGE BEGINS___\");\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo(msg) => format!(\"{}\", msg),\n            Message::Move((a, b)) => { format!(\"{} {}\", a, b) },\n            Message::ChangeColor((red, green, blue)) => { format!(\"{} {} {}\", red, green, blue) },\n        };\n        f.buffer.append(@str);\n        println!(\"___MESSAGE ENDS___\");\n        Result::Ok(())\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n    //TODO make the test pass without changing any existing line\n    loop {\n        break ();\n        counter += 1;\n    };\n    assert!(counter == 10, \"counter should be 10\")\n}\n```\n\nHint: The `break` condition is reached too early. Can you introduce a condition so that the loop runs a little more?",
      "reference": "#[cfg(test)]\n#[test]\nfn test_loop() {\n    let mut counter = 0;\n    //TODO make the test pass without changing any existing line\n    loop {\n        counter += 1;\n        if counter == 10 {\n            break ();\n        }\n    };\n    assert!(counter == 10, \"counter should be 10\")\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n// These modules have some issues, can you fix them?\n\nconst YEAR: u16 = 2050;\n\npub mod order {\n    #[derive(Copy, Drop)]\n    pub struct Order {\n        pub name: felt252,\n        pub year: u16,\n        pub made_by_phone: bool,\n        pub made_by_email: bool,\n        pub item: felt252,\n    }\n\n    pub fn new_order(name: felt252, made_by_phone: bool, item: felt252) -> Order {\n        Order { name, year: YEAR, made_by_phone, made_by_email: !made_by_phone, item,  }\n    }\n}\n\npub mod order_utils {\n    pub fn dummy_phoned_order(name: felt252) -> Order {\n        new_order(name, true, 'item_a')\n    }\n\n    pub fn dummy_emailed_order(name: felt252) -> Order {\n        new_order(name, false, 'item_a')\n    }\n\n    pub fn order_fees(order: Order) -> felt252 {\n        if order.made_by_phone {\n            return 500;\n        }\n\n        200\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_array() {\n    let order1 = order_utils::dummy_phoned_order('John Doe');\n    let fees1 = order_utils::order_fees(order1);\n    assert!(fees1 == 500, \"Order fee should be 500\");\n\n    let order2 = order_utils::dummy_emailed_order('Jane Doe');\n    let fees2 = order_utils::order_fees(order2);\n    assert!(fees2 == 200, \"Order fee should be 200\");\n}\n```\n\nHint: While using functions/structs and other items from outside the module,\nyou can refer to them with their full path or import them in the current context with the use keyword.\n",
      "reference": "// These modules have some issues, can you fix them?\n\nconst YEAR: u16 = 2050;\n\npub mod order {\n    #[derive(Copy, Drop)]\n    pub struct Order {\n        pub name: felt252,\n        pub year: u16,\n        pub made_by_phone: bool,\n        pub made_by_email: bool,\n        pub item: felt252,\n    }\n\n    pub fn new_order(name: felt252, made_by_phone: bool, item: felt252) -> Order {\n        Order { name, year: super::YEAR, made_by_phone, made_by_email: !made_by_phone, item,  }\n    }\n}\n\npub mod order_utils {\n    use super::order::{new_order, Order};\n\n    pub fn dummy_phoned_order(name: felt252) -> Order {\n        new_order(name, true, 'item_a')\n    }\n\n    pub fn dummy_emailed_order(name: felt252) -> Order {\n        new_order(name, false, 'item_a')\n    }\n\n    pub fn order_fees(order: Order) -> felt252 {\n        if order.made_by_phone {\n            return 500;\n        }\n\n        200\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_array() {\n    let order1 = order_utils::dummy_phoned_order('John Doe');\n    let fees1 = order_utils::order_fees(order1);\n    assert!(fees1 == 500, \"Order fee should be 500\");\n\n    let order2 = order_utils::dummy_emailed_order('Jane Doe');\n    let fees2 = order_utils::order_fees(order2);\n    assert!(fees2 == 200, \"Order fee should be 200\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\n// This exercise won't compile... Can you make it compile?\n\nfn main() {\n    // TODO: Fix the code to print \"Hello world!\".\n    printline!(\"Hello world!\");\n}\n```\n\nHint: No hints this time ;)\n",
      "reference": "// This exercise won't compile... Can you make it compile?\n\nfn main() {\n    println!(\"Hello world!\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\nfn main() {\n    let arr0 = array![];\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    //TODO fix the error here without modifying this line.\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\n\nHint: So you've got the \"ref argument must be a mutable variable.\" error on line 17,\nright? The fix for this is going to be adding one keyword, and the addition is NOT on line 17\nwhere the error is.\n\nAlso: Try accessing `arr0` after having called `fill_arr()`. See what happens!\n\nRead more about move semantics and ownership here: https://book.cairo-lang.org/ch04-01-what-is-ownership.html\n",
      "reference": "fn main() {\n    let mut arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    //TODO fix the error here without modifying this line.\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n\n}\n\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// I AM NOT DONE\nuse core::fmt::{Display, Formatter, Error};\n\n#[derive(Drop)]\nenum Message { // TODO: define a few types of messages as used below\n}\n\nfn main() { // don't change any of the lines inside main\n    println!(\"{}\", Message::Quit);\n    println!(\"{}\", Message::Echo);\n    println!(\"{}\", Message::Move);\n    println!(\"{}\", Message::ChangeColor);\n}\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo => format!(\"Echo\"),\n            Message::Move => format!(\"Move\"),\n            Message::ChangeColor => format!(\"ChangeColor\"),\n        };\n        f.buffer.append(@str);\n        Result::Ok(())\n    }\n}\n```\n\nHint: https://book.cairo-lang.org/ch06-01-enums.html",
      "reference": "use core::fmt::{Display, Formatter, Error};\n\n#[derive(Drop)]\nenum Message {\n    Quit,\n    Echo,\n    Move,\n    ChangeColor,\n}\n\nfn main() { // don't change any of the lines inside main\n    println!(\"{}\", Message::Quit);\n    println!(\"{}\", Message::Echo);\n    println!(\"{}\", Message::Move);\n    println!(\"{}\", Message::ChangeColor);\n}\n\nimpl MessageDisplay of Display<Message> {\n    fn fmt(self: @Message, ref f: Formatter) -> Result<(), Error> {\n        let str: ByteArray = match self {\n            Message::Quit => format!(\"Quit\"),\n            Message::Echo => format!(\"Echo\"),\n            Message::Move => format!(\"Move\"),\n            Message::ChangeColor => format!(\"ChangeColor\"),\n        };\n        f.buffer.append(@str);\n        Result::Ok(())\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Integer types implement basic comparison and arithmetic operators.\n// Felt252 operations should be avoided where possible, as they could have unwanted behavior.\n\n// I AM NOT DONE\n\n\nfn poly(x: usize, y: usize) -> usize {\n    // Return the solution of x^3 + y - 2\n    // FILL ME\n    res // Do not change\n}\n\n\n// Do not change the test function\n#[cfg(test)]\n#[test]\nfn test_poly() {\n    let res = poly(5, 3);\n    assert!(res == 126, \"Error message\");\n    assert!(res < 300, \"res < 300\");\n    assert!(res <= 300, \"res <= 300\");\n    assert!(res > 20, \"res > 20\");\n    assert!(res >= 2, \"res >= 2\");\n    assert!(res != 27, \"res != 27\");\n    assert!(res % 2 == 0, \"res %2 != 0\");\n}\n```\n\nHint: You can check the list of available operators here:\nhttps://book.cairo-lang.org/appendix-02-operators-and-symbols.html\n",
      "reference": "// Integer types implement basic comparison and arithmetic operators.\n// Felt252 operations should be avoided where possible, as they could have unwanted behavior.\n\n\n\n\nfn poly(x: usize, y: usize) -> usize {\n    // Return the solution of x^3 + y - 2\n    let res = x * x * x + y - 2;\n    res // Do not change\n}\n\n\n// Do not change the test function\n#[cfg(test)]\n#[test]\nfn test_poly() {\n    let res = poly(5, 3);\n    assert!(res == 126, \"Error message\");\n    assert!(res < 300, \"res < 300\");\n    assert!(res <= 300, \"res <= 300\");\n    assert!(res > 20, \"res > 20\");\n    assert!(res >= 2, \"res >= 2\");\n    assert!(res != 27, \"res != 27\");\n    assert!(res % 2 == 0, \"res %2 != 0\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Joe liked Jill's work very much. He really likes how useful storage can be.\n// Now they decided to write a contract to track the number of exercises they\n// complete successfully. Jill says they can use the owner code and allow\n// only the owner to update the contract, they agree.\n// Can you help them write this contract?\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IProgressTracker<TContractState> {\n    fn set_progress(ref self: TContractState, user: ContractAddress, new_progress: u16);\n    fn get_progress(self: @TContractState, user: ContractAddress) -> u16;\n    fn get_contract_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod ProgressTracker {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address; // Required to use get_caller_address function\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        // TODO: Set types for Map\n        progress: Map<>\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl ProgressTrackerImpl of super::IProgressTracker<ContractState> {\n        fn set_progress(\n            ref self: ContractState, user: ContractAddress, new_progress: u16\n        ) { // TODO: assert owner is calling\n        // TODO: set new_progress for user,\n        }\n\n        fn get_progress(self: @ContractState, user: ContractAddress) -> u16 { // Get user progress\n        }\n\n        fn get_contract_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::IProgressTrackerDispatcher;\n    use super::IProgressTrackerDispatcherTrait;\n    use super::ProgressTracker;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Sensei'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n        assert!(owner == dispatcher.get_contract_owner(), \"Mr. Sensei should be the owner\");\n    }\n\n    #[test]\n    fn test_set_progress() {\n        let owner = util_felt_addr('Sensei');\n        let dispatcher = deploy_contract();\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Set progress\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n        dispatcher.set_progress('Jill'.try_into().unwrap(), 25);\n\n        let joe_score = dispatcher.get_progress('Joe'.try_into().unwrap());\n        assert(joe_score == 20, 'Joe\\'s progress should be 20');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_progress_fail() {\n        let dispatcher = deploy_contract();\n\n        let jon_doe = util_felt_addr('JonDoe');\n        // Caller not owner\n        start_cheat_caller_address(dispatcher.contract_address, jon_doe);\n\n        // Try to set progress, should panic to pass test!\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> IProgressTrackerDispatcher {\n        let owner: felt252 = 'Sensei';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"ProgressTracker\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        IProgressTrackerDispatcher { contract_address }\n    }\n}\n```\n\nHint: No hints this time ;)\n",
      "reference": "// Joe liked Jill's work very much. He really likes how useful storage can be.\n// Now they decided to write a contract to track the number of exercises they\n// complete successfully. Jill says they can use the owner code and allow\n// only the owner to update the contract, they agree.\n// Can you help them write this contract?\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IProgressTracker<TContractState> {\n    fn set_progress(ref self: TContractState, user: ContractAddress, new_progress: u16);\n    fn get_progress(self: @TContractState, user: ContractAddress) -> u16;\n    fn get_contract_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod ProgressTracker {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address; // Required to use get_caller_address function\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map, StorageMapReadAccess, StorageMapWriteAccess};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        progress: Map<ContractAddress, u16>\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl ProgressTrackerImpl of super::IProgressTracker<ContractState> {\n        fn set_progress(\n            ref self: ContractState, user: ContractAddress, new_progress: u16\n        ) {\n            // Assert owner is calling\n            let caller = get_caller_address();\n            let owner = self.contract_owner.read();\n            assert!(caller == owner, \"Only owner can set progress\");\n\n            // Set new_progress for user\n            self.progress.write(user, new_progress);\n        }\n\n        fn get_progress(self: @ContractState, user: ContractAddress) -> u16 {\n            // Get user progress\n            self.progress.read(user)\n        }\n\n        fn get_contract_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::IProgressTrackerDispatcher;\n    use super::IProgressTrackerDispatcherTrait;\n    use super::ProgressTracker;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Sensei'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n        assert!(owner == dispatcher.get_contract_owner(), \"Mr. Sensei should be the owner\");\n    }\n\n    #[test]\n    fn test_set_progress() {\n        let owner = util_felt_addr('Sensei');\n        let dispatcher = deploy_contract();\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Set progress\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n        dispatcher.set_progress('Jill'.try_into().unwrap(), 25);\n\n        let joe_score = dispatcher.get_progress('Joe'.try_into().unwrap());\n        assert(joe_score == 20, 'Joe\\'s progress should be 20');\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_progress_fail() {\n        let dispatcher = deploy_contract();\n\n        let jon_doe = util_felt_addr('JonDoe');\n        // Caller not owner\n        start_cheat_caller_address(dispatcher.contract_address, jon_doe);\n\n        // Try to set progress, should panic to pass test!\n        dispatcher.set_progress('Joe'.try_into().unwrap(), 20);\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> IProgressTrackerDispatcher {\n        let owner: felt252 = 'Sensei';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"ProgressTracker\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        IProgressTrackerDispatcher { contract_address }\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Joe's contract in the last exercise showed that Joe is the owner of the contract.\n// He thanks you for helping him out!\n// Jill says that contract should allow setting the owner when contract is deployed.\n// Help Jill rewrite the contract with a Storage and a constructor.\n// There is a `ContractAddress` type which should be used for Wallet addresses.\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::contract]\nmod JillsContract {\n    // This is required to use ContractAddress type\n    use starknet::ContractAddress;\n\n    #[storage]\n    struct Storage { // TODO: Add `contract_owner` storage, with ContractAddress type\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, owner: ContractAddress,\n    ) { // TODO: Write `owner` to contract_owner storage\n    }\n\n    #[abi(embed_v0)]\n    impl IJillsContractImpl of super::IJillsContract<ContractState> {\n        fn get_owner(self: @ContractState) -> ContractAddress { // TODO: Read contract_owner storage\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IJillsContract<TContractState> {\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{ContractClassTrait, DeclareResultTrait, declare};\n    use super::{IJillsContractDispatcher, IJillsContractDispatcherTrait, JillsContract};\n\n    #[test]\n    fn test_owner_setting() {\n        let mut calldata = ArrayTrait::new();\n        calldata.append('Jill');\n\n        let contract = declare(\"JillsContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        let dispatcher = IJillsContractDispatcher { contract_address };\n        let owner = dispatcher.get_owner();\n        assert!(owner == 'Jill'.try_into().unwrap(), \"Owner should be Jill\");\n    }\n}\n```\n\nHint: No hints this time ;)\n",
      "reference": "// Joe's contract in the last exercise showed that Joe is the owner of the contract.\n// He thanks you for helping him out!\n// Jill says that contract should allow setting the owner when contract is deployed.\n// Help Jill rewrite the contract with a Storage and a constructor.\n// There is a `ContractAddress` type which should be used for Wallet addresses.\n\nuse starknet::ContractAddress;\n\n#[starknet::contract]\nmod JillsContract {\n    // This is required to use ContractAddress type\n    use starknet::ContractAddress;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n    }\n\n    #[constructor]\n    fn constructor(\n        ref self: ContractState, owner: ContractAddress\n    ) {\n        self.contract_owner.write(owner);\n    }\n\n    #[abi(embed_v0)]\n    impl IJillsContractImpl of super::IJillsContract<ContractState> {\n        fn get_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[starknet::interface]\ntrait IJillsContract<TContractState> {\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[cfg(test)]\nmod test {\n    use super::IJillsContractDispatcher;\n    use super::IJillsContractDispatcherTrait;\n    use super::JillsContract;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n\n    #[test]\n    fn test_owner_setting() {\n        let mut calldata = ArrayTrait::new();\n        calldata.append('Jill');\n\n        let contract = declare(\"JillsContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        let dispatcher = IJillsContractDispatcher { contract_address };\n        let owner = dispatcher.get_owner();\n        assert!(owner == 'Jill'.try_into().unwrap(), \"Owner should be Jill\");\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Liz, a friend of Jill, wants to manage inventory for her store on-chain.\n// This is a bit challenging for Joe and Jill, Liz prepared an outline\n// for how contract should work, can you help Jill and Joe write it?\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait ILizInventory<TContractState> {\n    fn add_stock(ref self: TContractState, product: felt252, new_stock: u32);\n    fn purchase(ref self: TContractState, product: felt252, quantity: u32);\n    fn get_stock(self: @TContractState, product: felt252) -> u32;\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod LizInventory {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        // TODO: add storage inventory, that maps product (felt252) to stock quantity (u32)\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl LizInventoryImpl of super::ILizInventory<ContractState> {\n        fn add_stock(ref self: ContractState, ) {\n            // TODO:\n            // * takes product and new_stock\n            // * adds new_stock to stock in inventory\n            // * only owner can call this\n        }\n\n        fn purchase(ref self: ContractState, ) {\n            // TODO:\n            // * takes product and quantity\n            // * subtracts quantity from stock in inventory\n            // * anybody can call this\n        }\n\n        fn get_stock(self: @ContractState, ) -> u32 {\n            // TODO:\n            // * takes product\n            // * returns product stock in inventory\n        }\n\n        fn get_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::LizInventory;\n    use super::ILizInventoryDispatcher;\n    use super::ILizInventoryDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Elizabeth'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n\n        // Check that contract owner is set\n        let contract_owner = dispatcher.get_owner();\n        assert!(contract_owner == owner, \"Elizabeth should be the owner\");\n    }\n\n    #[test]\n    fn test_stock() {\n        let dispatcher = deploy_contract();\n        let owner = util_felt_addr('Elizabeth');\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert!(stock == 10, \"stock should be 10\");\n\n        dispatcher.add_stock('Nano', 15);\n        let stock = dispatcher.get_stock('Nano');\n        assert!(stock == 25, \"stock should be 25\");\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    fn test_stock_purchase() {\n        let owner = util_felt_addr('Elizabeth');\n        let dispatcher = deploy_contract();\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert!(stock == 10, \"stock should be 10\");\n\n        // Call contract as different address\n        stop_cheat_caller_address(dispatcher.contract_address);\n        start_cheat_caller_address(dispatcher.contract_address, 0.try_into().unwrap());\n\n        dispatcher.purchase('Nano', 2);\n        let stock = dispatcher.get_stock('Nano');\n        assert!(stock == 8, \"stock should be 8\");\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_stock_fail() {\n        let dispatcher = deploy_contract();\n        // Try to add stock, should panic to pass test!\n        dispatcher.add_stock('Nano', 20);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_purchase_out_of_stock() {\n        let dispatcher = deploy_contract();\n        // Purchase out of stock\n        dispatcher.purchase('Nano', 2);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> ILizInventoryDispatcher {\n        let owner: felt252 = 'Elizabeth';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"LizInventory\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        ILizInventoryDispatcher { contract_address }\n    }\n}\n```\n\nHint: \nYou can use Map<felt252, u32> for inventory.\n",
      "reference": "// Liz, a friend of Jill, wants to manage inventory for her store on-chain.\n// This is a bit challenging for Joe and Jill, Liz prepared an outline\n// for how contract should work, can you help Jill and Joe write it?\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait ILizInventory<TContractState> {\n    fn add_stock(ref self: TContractState, product: felt252, new_stock: u32);\n    fn purchase(ref self: TContractState, product: felt252, quantity: u32);\n    fn get_stock(self: @TContractState, product: felt252) -> u32;\n    fn get_owner(self: @TContractState) -> ContractAddress;\n}\n\n#[starknet::contract]\nmod LizInventory {\n    use starknet::ContractAddress;\n    use starknet::get_caller_address;\n    use starknet::storage::{StoragePointerReadAccess, StoragePointerWriteAccess, StoragePathEntry, Map, StorageMapReadAccess, StorageMapWriteAccess};\n\n    #[storage]\n    struct Storage {\n        contract_owner: ContractAddress,\n        inventory: Map<felt252, u32>,\n    }\n\n    #[constructor]\n    fn constructor(ref self: ContractState, owner: ContractAddress) {\n        self.contract_owner.write(owner);\n    }\n\n\n    #[abi(embed_v0)]\n    impl LizInventoryImpl of super::ILizInventory<ContractState> {\n        fn add_stock(ref self: ContractState, product: felt252, new_stock: u32) {\n            // Only owner can call this\n            let caller = get_caller_address();\n            let owner = self.contract_owner.read();\n            assert!(caller == owner, \"Only owner can add stock\");\n\n            // Add new_stock to existing stock in inventory\n            let current_stock = self.inventory.entry(product).read();\n            let updated_stock = current_stock + new_stock;\n            self.inventory.entry(product).write(updated_stock);\n        }\n\n        fn purchase(ref self: ContractState, product: felt252, quantity: u32) {\n            // Anybody can call this\n            // Subtract quantity from stock in inventory\n            let current_stock = self.inventory.entry(product).read();\n            assert!(current_stock >= quantity, \"Insufficient stock\");\n\n            let updated_stock = current_stock - quantity;\n            self.inventory.entry(product).write(updated_stock);\n        }\n\n        fn get_stock(self: @ContractState, product: felt252) -> u32 {\n            // Returns product stock in inventory\n            self.inventory.entry(product).read()\n        }\n\n        fn get_owner(self: @ContractState) -> ContractAddress {\n            self.contract_owner.read()\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use starknet::ContractAddress;\n    use super::LizInventory;\n    use super::ILizInventoryDispatcher;\n    use super::ILizInventoryDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait, start_cheat_caller_address, stop_cheat_caller_address};\n\n    #[test]\n    fn test_owner() {\n        let owner: ContractAddress = 'Elizabeth'.try_into().unwrap();\n        let dispatcher = deploy_contract();\n\n        // Check that contract owner is set\n        let contract_owner = dispatcher.get_owner();\n        assert!(contract_owner == owner, \"Elizabeth should be the owner\");\n    }\n\n    #[test]\n    fn test_stock() {\n        let dispatcher = deploy_contract();\n        let owner = util_felt_addr('Elizabeth');\n\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert!(stock == 10, \"stock should be 10\");\n\n        dispatcher.add_stock('Nano', 15);\n        let stock = dispatcher.get_stock('Nano');\n        assert!(stock == 25, \"stock should be 25\");\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    fn test_stock_purchase() {\n        let owner = util_felt_addr('Elizabeth');\n        let dispatcher = deploy_contract();\n        // Call contract as owner\n        start_cheat_caller_address(dispatcher.contract_address, owner);\n\n        // Add stock\n        dispatcher.add_stock('Nano', 10);\n        let stock = dispatcher.get_stock('Nano');\n        assert!(stock == 10, \"stock should be 10\");\n\n        // Call contract as different address\n        stop_cheat_caller_address(dispatcher.contract_address);\n        start_cheat_caller_address(dispatcher.contract_address, 0.try_into().unwrap());\n\n        dispatcher.purchase('Nano', 2);\n        let stock = dispatcher.get_stock('Nano');\n        assert!(stock == 8, \"stock should be 8\");\n\n        stop_cheat_caller_address(dispatcher.contract_address);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_set_stock_fail() {\n        let dispatcher = deploy_contract();\n        // Try to add stock, should panic to pass test!\n        dispatcher.add_stock('Nano', 20);\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_purchase_out_of_stock() {\n        let dispatcher = deploy_contract();\n        // Purchase out of stock\n        dispatcher.purchase('Nano', 2);\n    }\n\n    fn util_felt_addr(addr_felt: felt252) -> ContractAddress {\n        addr_felt.try_into().unwrap()\n    }\n\n    fn deploy_contract() -> ILizInventoryDispatcher {\n        let owner: felt252 = 'Elizabeth';\n        let mut calldata = ArrayTrait::new();\n        calldata.append(owner);\n\n        let contract = declare(\"LizInventory\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@calldata).unwrap();\n        ILizInventoryDispatcher { contract_address }\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\nfn create_array() -> Array<felt252> {\n    let a = ArrayTrait::new(); // something to change here...\n    a.append(0);\n    a.append(1);\n    a.append(2);\n    a.pop_front().unwrap();\n    a\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_arrays3() {\n    let mut a = create_array();\n    //TODO modify the method called below to make the test pass.\n    // You should not change the index accessed.\n    a.at(2);\n}\n```\n\nHint: The test fails because you are trying to access an element that is out of bounds!\nBy using array.pop_front(), we remove the first element from the array, so the index of the last element is no longer 2.\nWithout changing the index accessed, how can we make the test pass? Is there a method that returns an option that could help us?\n",
      "reference": "// Make me compile and pass the test!\n\n\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new(); // something to change here...\n    a.append(0);\n    a.append(1);\n    a.append(2);\n    a.pop_front().unwrap();\n    a\n}\n\n\n#[cfg(test)]\n#[test]\nfn test_arrays3() {\n    let mut a = create_array();\n    let _ = a.get(2);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n\n// I AM NOT DONE\n\n#[cfg(test)]\n#[test]\nfn main() {\n    let mut a = ArrayTrait::new();\n    let mut b = pass_by_value(a);\n    pass_by_ref(ref a);\n    pass_by_ref(ref b);\n    pass_by_snapshot(@a);\n}\n\nfn pass_by_value(mut arr: Array<felt252>) -> Array<felt252> {\n    arr\n}\n\nfn pass_by_ref(ref arr: Array<felt252>) {}\n\nfn pass_by_snapshot(x: @Array<felt252>) {}\n```\n\nHint: Carefully reason about how each function takes ownership of the variable passed.\nIt depends on the keyword used to pass the variable.\nWhat happens when a function takes ownership of a variable and then returns it?\nCan we still use it later on?\n",
      "reference": "// Make me compile only by reordering the lines in `main()`, but without\n// adding, changing or removing any of them.\n\n\n\n#[cfg(test)]\n#[test]\nfn main() {\n    let mut a = ArrayTrait::new();\n    pass_by_ref(ref a);\n    pass_by_snapshot(@a);\n    let mut b = pass_by_value(a);\n    pass_by_ref(ref b);\n}\n\nfn pass_by_value(mut arr: Array<felt252>) -> Array<felt252> {\n    arr\n}\n\nfn pass_by_ref(ref arr: Array<felt252>) {}\n\nfn pass_by_snapshot(x: @Array<felt252>) {}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n\n// I AM NOT DONE\n\nfn main() {\n    let arr0 = array![];\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\n\nHint: The difference between this one and the previous ones is that the first line\nof `fn fill_arr` that had `let mut arr = arr;` is no longer there. You can,\ninstead of adding that line back, add `mut` in one place that will change\nan existing binding to be a mutable binding instead of an immutable one :)",
      "reference": "// Make me compile without adding new lines-- just changing existing lines!\n// (no lines with multiple semicolons necessary!)\n\nfn main() {\n    let arr0 = ArrayTrait::new();\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\nfn fill_arr(mut arr: Array<felt252>) -> Array<felt252> {\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Make me compile without changing the indicated lines\n\n// I AM NOT DONE\n\nfn main() {\n    let arr0 = array![];\n\n    let mut _arr1 = fill_arr(arr0);\n\n    // Do not change the following line!\n    print_arr(arr0);\n}\n\nfn print_arr(arr: Array<felt252>) {\n    println!(\"arr: {:?}\", arr);\n}\n\n// Do not change the following line!\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\n\nHint: So, `arr0` is passed into the `fill_arr` function as an argument. In Cairo,\nwhen an argument is passed to a function and it's not explicitly returned,\nyou can't use the original variable anymore. We call this \"moving\" a variable.\nVariables that are moved into a function (or block scope) and aren't explicitly\nreturned get \"dropped\" at the end of that function. This is also what happens here.\nThere's a few ways to fix this, try them all if you want:\n1. Make another, separate version of the data that's in `arr0` and pass that\n   to `fill_arr` instead.\n2. Make `fill_arr` *mutably* borrow a reference to its argument (which will need to be\n   mutable) with the `ref` keyword , modify it directly, then not return anything. Then you can get rid\n   of `arr1` entirely -- note that this will change what gets printed by the\n   first `print`\n3. Make `fill_arr` borrow an immutable view of its argument instead of taking ownership by using the snapshot operator `@`,\n   and then copy the data within the function in order to return an owned\n   `Array<felt>`. This requires an explicit clone of the array and should generally be avoided in Cairo, as the memory is write-once and cloning can be expensive. To clone an object, you will need to import the trait `clone::Clone` and the implementation of the Clone trait for the array located in `array::ArrayTCloneImpl`",
      "reference": "// Make me compile without changing the indicated lines\n\n\nfn main() {\n    let mut arr0 = ArrayTrait::new();\n\n    fill_arr(ref arr0);\n\n    // Do not change the following line!\n    print_arr(arr0);\n}\n\nfn print_arr(arr: Array<felt252>) {\n    println!(\"arr: {:?}\", arr);\n}\n\n// Do not change the following line!\nfn fill_arr(ref arr: Array<felt252>){\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Make me compile!\n\n// I AM NOT DONE\n\nfn main() {\n    x = 5 ;\n    println!(\" x is {}\", x)\n}\n```\n\nHint: The declaration on line 8 is missing a keyword that is needed in Cairo\nto create a new variable binding.",
      "reference": "// Make me compile!\n\n\n\nfn main() {\n    let x = 5;\n    println!(\" x is {}\", x)\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Make the tests pass.\n\n// I AM NOT DONE\n\nfn bigger(a: usize, b: usize) -> usize { // Complete this function to return the bigger number!\n// Do not use:\n// - another function call\n// - additional variables\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::bigger;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert(10 == bigger(10, 8), '10 bigger than 8');\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert(42 == bigger(32, 42), '42 bigger than 32');\n    }\n}\n```\n\nHint: Remember in Cairo that:\n- the `if` condition does not need to be surrounded by parentheses\n- `if`/`else` conditionals are expressions\n- Each condition is followed by a `{}` block.",
      "reference": "// Make the tests pass.\n\nfn bigger(a: usize, b: usize) -> usize {\n    if a > b {\n        a\n    } else {\n        b\n    }\n}\n\n// Don't mind this for now :)\n#[cfg(test)]\nmod tests {\n    use super::bigger;\n\n    #[test]\n    fn ten_is_bigger_than_eight() {\n        assert(10 == bigger(10, 8), '10 bigger than 8');\n    }\n\n    #[test]\n    fn fortytwo_is_bigger_than_thirtytwo() {\n        assert(42 == bigger(32, 42), '42 bigger than 32');\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 3 cairobucks.\n// - If Mary buys more than 40 apples, each apple only costs 2 cairobuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\n// I AM NOT DONE\n\nfn calculate_price_of_apples{\n\n}\n\n// Do not change the tests!\n#[cfg(test)]\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert!(105 == price1, \"Incorrect price\");\n    assert!(120 == price2, \"Incorrect price\");\n    assert!(82 == price3, \"Incorrect price\");\n    assert!(130 == price4, \"Incorrect price\");\n}\n```\n\nHint: No hints this time ;)",
      "reference": "// Mary is buying apples. The price of an apple is calculated as follows:\n// - An apple costs 3 cairobucks.\n// - If Mary buys more than 40 apples, each apple only costs 2 cairobuck!\n// Write a function that calculates the price of an order of apples given\n// the quantity bought. No hints this time!\n\nfn calculate_price_of_apples(quantity: u32) -> u32 {\n    if quantity > 40 {\n        quantity * 2\n    } else {\n        quantity * 3\n    }\n}\n\n// Do not change the tests!\n#[cfg(test)]\n#[test]\nfn verify_test() {\n    let price1 = calculate_price_of_apples(35);\n    let price2 = calculate_price_of_apples(40);\n    let price3 = calculate_price_of_apples(41);\n    let price4 = calculate_price_of_apples(65);\n\n    assert!(105 == price1, \"Incorrect price\");\n    assert!(120 == price2, \"Incorrect price\");\n    assert!(82 == price3, \"Incorrect price\");\n    assert!(130 == price4, \"Incorrect price\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Modify the integer types to make the tests pass.\n// Learn how to convert between integer types, and felts.\n\n// I AM NOT DONE\n\nfn sum_u8s(x: u8, y: u8) -> u8 {\n    x + y\n}\n\n//TODO modify the types of this function to prevent an overflow when summing big values\nfn sum_big_numbers(x: u8, y: u8) -> u8 {\n    x + y\n}\n\nfn convert_to_felt(x: u8) -> felt252 { //TODO return x as a felt252.\n}\n\nfn convert_felt_to_u8(x: felt252) -> u8 { //TODO return x as a u8.\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_u8s() {\n    assert(sum_u8s(1, 2_u8) == 3_u8, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_big_numbers() {\n    //TODO modify this test to use the correct integer types.\n    // Don't modify the values, just the types.\n    // See how using the _u8 suffix on the numbers lets us specify the type?\n    // Try to do the same thing with other integer types.\n    assert(sum_big_numbers(255_u8, 255_u8) == 510_u8, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_felt() {\n    assert!(convert_to_felt(1_u8) == 1, \"Type conversion went wrong\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_u8() {\n    assert!(convert_felt_to_u8(1) == 1_u8, \"Type conversion went wrong\");\n}\n```\n\nHint: There are multiple integer types in Cairo. You can read about them here:\nhttps://book.cairo-lang.org/ch02-02-data-types.html#integer-types\nIf you try to sum two integers and the result is bigger than the biggest integer of this type, you'll get a compilation error.\nYou can convert integers to felts using the `.into()` method. Make sure that you imported the `Into` trait.\nYou can convert felts to integers using the `.try_into()` method. Make sure that you imported the `TryInto` trait.\nThis method will return an `Option` type, so you'll need to unwrap it. To use the `unwrap()` method, you'll need to import the `OptionTrait` trait.\nTake a look at the top of the file to see how these traits are imported.\n",
      "reference": "// Modify the integer types to make the tests pass.\n// Learn how to convert between integer types, and felts.\n\n\nfn sum_u8s(x: u8, y: u8) -> u8 {\n    x + y\n}\n\n//TODO modify the types of this function to prevent an overflow when summing big values\nfn sum_big_numbers(x: u16, y: u16) -> u16 {\n    x + y\n}\n\nfn convert_to_felt(x: u8) -> felt252 {\n    x.into()\n}\n\nfn convert_felt_to_u8(x: felt252) -> u8 {\n    x.try_into().unwrap()\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_u8s() {\n    assert(sum_u8s(1, 2_u8) == 3_u8, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_sum_big_numbers() {\n    //TODO modify this test to use the correct integer types.\n    // Don't modify the values, just the types.\n    // See how using the _u8 suffix on the numbers lets us specify the type?\n    // Try to do the same thing with other integer types.\n    assert(sum_big_numbers(255_u16, 255_u16) == 510_u16, 'Something went wrong');\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_felt() {\n    assert!(convert_to_felt(1_u8) == 1, \"Type conversion went wrong\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_convert_to_u8() {\n    assert!(convert_felt_to_u8(1) == 1_u8, \"Type conversion went wrong\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Refactor this code so that instead of passing `arr0` into the `fill_arr` function,\n// the Array gets created in the function itself and passed back to the main\n// function.\n\n// I AM NOT DONE\n\nfn main() {\n    let arr0: Array<felt252> = array![];\n\n    let mut arr1 = fill_arr(arr0);\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\n// `fill_arr()` should no longer take `arr: Array<felt252>` as argument\nfn fill_arr(arr: Array<felt252>) -> Array<felt252> {\n    let mut arr = arr;\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}\n```\n\nHint: Stop reading whenever you feel like you have enough direction :) Or try\ndoing one step and then fixing the compiler errors that result!\nSo the end goal is to:\n   - get rid of the first line in main that creates the new array\n   - so then `arr0` doesn't exist, so we can't pass it to `fill_arr`\n   - we don't want to pass anything to `fill_arr`, so its signature should\n     reflect that it does not take any arguments\n   - since we're not creating a new array in `main` anymore, we need to create\n     a new array in `fill_arr`, similarly to the way we did in `main`",
      "reference": "// Refactor this code so that instead of passing `arr0` into the `fill_arr` function,\n// the Array gets created in the function itself and passed back to the main\n// function.\n\nfn main() {\n    let mut arr1 = fill_arr();\n\n    println!(\"arr1: {:?}\", arr1);\n\n    arr1.append(88);\n\n    println!(\"arr1: {:?}\", arr1);\n}\n\n// `fill_arr()` should no longer take `arr: Array<felt252>` as argument\nfn fill_arr() -> Array<felt252> {\n    let mut arr = ArrayTrait::<felt252>::new();\n\n    arr.append(22);\n    arr.append(44);\n    arr.append(66);\n\n    arr\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Remember last time you calculated division in Cairo0?\n// Now Cairo1 has native integer types e.g. u8, u32, ...u256, usize which support more operators than felts\n// And always watch out for overflows e.g in the last test\n// Let try to use them\n\n// I AM NOT DONE\n\nfn modulus(x: u8, y: u8) -> u8 {\n    // calculate the modulus of x and y\n    // FILL ME\n    res\n}\n\nfn floor_division(x: usize, y: usize) -> usize {\n    // calculate the floor_division of x and y\n    // FILL ME\n    res\n}\n\nfn multiplication(x: u64, y: u64) -> u64 {\n    // calculate the multiplication of x and y\n    // FILL ME\n    res\n}\n\n\n// Do not change the tests\n#[cfg(test)]\n#[test]\nfn test_modulus() {\n    let res = modulus(16, 2);\n    assert!(res == 0, \"Error message\");\n\n    let res = modulus(17, 3);\n    assert!(res == 2, \"Error message\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_floor_division() {\n    let res = floor_division(160, 2);\n    assert!(res == 80, \"Error message\");\n\n    let res = floor_division(21, 4);\n    assert!(res == 5, \"Error message\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_mul() {\n    let res = multiplication(16, 2);\n    assert!(res == 32, \"Error message\");\n\n    let res = multiplication(21, 4);\n    assert!(res == 84, \"Error message\");\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn test_u64_mul_overflow_1() {\n    let _res = multiplication(0x100000000, 0x100000000);\n}\n```\n\nHint: Use % for modulus, / for division, and * for multiplication.",
      "reference": "// Remember last time you calculated division in Cairo0?\n// Now Cairo1 has native integer types e.g. u8, u32, ...u256, usize which support more operators than felts\n// And always watch out for overflows e.g in the last test\n// Let try to use them\n\nfn modulus(x: u8, y: u8) -> u8 {\n    // calculate the modulus of x and y\n    x % y\n}\n\nfn floor_division(x: usize, y: usize) -> usize {\n    // calculate the floor_division of x and y\n    x / y\n}\n\nfn multiplication(x: u64, y: u64) -> u64 {\n    // calculate the multiplication of x and y\n    x * y\n}\n\n\n// Do not change the tests\n#[cfg(test)]\n#[test]\nfn test_modulus() {\n    let res = modulus(16, 2);\n    assert!(res == 0, \"Error message\");\n\n    let res = modulus(17, 3);\n    assert!(res == 2, \"Error message\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_floor_division() {\n    let res = floor_division(160, 2);\n    assert!(res == 80, \"Error message\");\n\n    let res = floor_division(21, 4);\n    assert!(res == 5, \"Error message\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_mul() {\n    let res = multiplication(16, 2);\n    assert!(res == 32, \"Error message\");\n\n    let res = multiplication(21, 4);\n    assert!(res == 84, \"Error message\");\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn test_u64_mul_overflow_1() {\n    let _res = multiplication(0x100000000, 0x100000000);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Starkling, Joe, is writing a really simple contract.\n// The contract shows that he is the owner of the contract.\n// However, his contract is not working. What's he missing?\n\n// I AM NOT DONE\n\n#[starknet::interface]\ntrait IJoesContract<TContractState> {\n    fn get_owner(self: @TContractState) -> felt252;\n}\n\n#[starknet::contract]\nmod JoesContract {\n    #[storage]\n    struct Storage {}\n\n    impl IJoesContractImpl of super::IJoesContract<ContractState> {\n        fn get_owner(self: @ContractState) -> felt252 {\n            'Joe'\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use snforge_std::{ContractClassTrait, DeclareResultTrait, declare};\n    use super::{IJoesContractDispatcher, IJoesContractDispatcherTrait, JoesContract};\n\n    #[test]\n    fn test_contract_view() {\n        let dispatcher = deploy_contract();\n        assert!('Joe' == dispatcher.get_owner(), \"Joe should be the owner.\");\n    }\n\n    fn deploy_contract() -> IJoesContractDispatcher {\n        let contract = declare(\"JoesContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IJoesContractDispatcher { contract_address }\n    }\n}\n```\n\nHint: No hints this time ;)\n",
      "reference": "// Starkling, Joe, is writing a really simple contract.\n// The contract shows that he is the owner of the contract.\n// However, his contract is not working. What's he missing?\n\n#[starknet::interface]\ntrait IJoesContract<TContractState> {\n    fn get_owner(self: @TContractState) -> felt252;\n}\n\n#[starknet::contract]\nmod JoesContract {\n    #[storage]\n    struct Storage {}\n\n    #[abi(embed_v0)]\n    impl IJoesContractImpl of super::IJoesContract<ContractState> {\n        fn get_owner(self: @ContractState) -> felt252 {\n            'Joe'\n        }\n    }\n}\n\n#[cfg(test)]\nmod test {\n    use super::JoesContract;\n    use super::IJoesContractDispatcher;\n    use super::IJoesContractDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n\n    #[test]\n    fn test_contract_view() {\n        let dispatcher = deploy_contract();\n        assert!('Joe' == dispatcher.get_owner(), \"Joe should be the owner.\");\n    }\n\n    fn deploy_contract() -> IJoesContractDispatcher {\n        let contract = declare(\"JoesContract\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IJoesContractDispatcher { contract_address }\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n\n// I AM NOT DONE\n\nfn foo_if_fizz(fizzish: felt252) -> felt252 {\n    // Complete this function using if, else if and/or else blocks.\n    // If fizzish is,\n    // 'fizz', return 'foo'\n    // 'fuzz', return 'bar'\n    // anything else, return 'baz'\n    if fizzish == 'fizz' {\n        'foo'\n    } else {\n        1_u32\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::foo_if_fizz;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert!(foo_if_fizz('fizz') == 'foo', \"fizz returns foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert!(foo_if_fizz('fuzz') == 'bar', \"fuzz returns bar\");\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert!(foo_if_fizz('literally anything') == 'baz', \"anything else returns baz\");\n    }\n}\n```\n\nHint: For that first compiler error, it's important in Cairo that each conditional\nblock returns the same type! To get the tests passing, you will need a couple\nconditions checking different input values.",
      "reference": "// Step 1: Make me compile!\n// Step 2: Get the bar_for_fuzz and default_to_baz tests passing!\n\n\n\nfn foo_if_fizz(fizzish: felt252) -> felt252 {\n    // Complete this function using if, else if and/or else blocks.\n    // If fizzish is,\n    // 'fizz', return 'foo'\n    // 'fuzz', return 'bar'\n    // anything else, return 'baz'\n    if fizzish == 'fizz' {\n        'foo'\n    } else if fizzish == 'fuzz' {\n        'bar'\n    } else {\n        'baz'\n    }\n}\n\n// No test changes needed!\n#[cfg(test)]\nmod tests {\n    use super::foo_if_fizz;\n\n    #[test]\n    fn foo_for_fizz() {\n        assert!(foo_if_fizz('fizz') == 'foo', \"fizz returns foo\")\n    }\n\n    #[test]\n    fn bar_for_fuzz() {\n        assert!(foo_if_fizz('fuzz') == 'bar', \"fuzz returns bar\");\n    }\n\n    #[test]\n    fn default_to_baz() {\n        assert!(foo_if_fizz('literally anything') == 'baz', \"anything else returns baz\");\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Package {\n    sender_country: felt252,\n    recipient_country: felt252,\n    weight_in_grams: usize,\n}\n\ntrait PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package;\n    fn is_international(ref self: Package) -> //???;\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> //???;\n}\nimpl PackageImpl of PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package {\n        assert!(weight_in_grams > 0, \"Weight must be greater than 0\");\n        Package { sender_country, recipient_country, weight_in_grams,  }\n    }\n\n    fn is_international(ref self: Package) -> //???\n    {\n    /// Something goes here...\n    }\n\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> //???\n    {\n    /// Something goes here...\n    }\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn fail_creating_weightless_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Austria';\n    PackageTrait::new(sender_country, recipient_country, 0);\n}\n\n#[cfg(test)]\n#[test]\nfn create_international_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Russia';\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert!(package.is_international() == true, \"Not international\");\n}\n\n#[cfg(test)]\n#[test]\nfn create_local_package() {\n    let sender_country = 'Canada';\n    let recipient_country = sender_country;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert!(package.is_international() == false, \"International\");\n}\n\n#[cfg(test)]\n#[test]\nfn calculate_transport_fees() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Spain';\n\n    let cents_per_gram = 3;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1500);\n\n    assert!(package.get_fees(cents_per_gram) == 4500, \"Wrong fees\");\n}\n```\n\nHint: For is_international: What makes a package international? Seems related to the places it goes through right?\n\nFor get_fees: This method takes an additional argument, is there a field in the Package struct that this relates to?\n\nLooking at the test functions will also help you understand more about the syntax.\nThis section will help you understanding more about methods https://book.cairo-lang.org/ch05-03-method-syntax.html\n",
      "reference": "// Structs contain data, but can also have logic. In this exercise we have\n// defined the Package struct and we want to test some logic attached to it.\n// Make the code compile and the tests pass!\n\n#[derive(Copy, Drop)]\nstruct Package {\n    sender_country: felt252,\n    recipient_country: felt252,\n    weight_in_grams: usize,\n}\n\ntrait PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package;\n    fn is_international(ref self: Package) -> bool;\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> usize;\n}\nimpl PackageImpl of PackageTrait {\n    fn new(sender_country: felt252, recipient_country: felt252, weight_in_grams: usize) -> Package {\n        assert!(weight_in_grams > 0, \"Weight must be greater than 0\");\n        Package { sender_country, recipient_country, weight_in_grams,  }\n    }\n\n    fn is_international(ref self: Package) -> bool {\n        self.sender_country != self.recipient_country\n    }\n\n    fn get_fees(ref self: Package, cents_per_gram: usize) -> usize {\n        self.weight_in_grams * cents_per_gram\n    }\n}\n\n#[cfg(test)]\n#[test]\n#[should_panic]\nfn fail_creating_weightless_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Austria';\n    PackageTrait::new(sender_country, recipient_country, 0);\n}\n\n#[cfg(test)]\n#[test]\nfn create_international_package() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Russia';\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert!(package.is_international() == true, \"Not international\");\n}\n\n#[cfg(test)]\n#[test]\nfn create_local_package() {\n    let sender_country = 'Canada';\n    let recipient_country = sender_country;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1200);\n\n    assert!(package.is_international() == false, \"International\");\n}\n\n#[cfg(test)]\n#[test]\nfn calculate_transport_fees() {\n    let sender_country = 'Spain';\n    let recipient_country = 'Spain';\n\n    let cents_per_gram = 3;\n\n    let mut package = PackageTrait::new(sender_country, recipient_country, 1500);\n\n    assert!(package.get_fees(cents_per_gram) == 4500, \"Wrong fees\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// The Felt252Dict maps a felt252 to a value of the specified type.\n// In this exercise, you will map a `felt252` key to a value of type `u32`.\n\n// Your task is to create a `Felt252Dict`  containing three elements of type `u32`.\n// The first element should map the key 'A' to the value 1, the second key 'B' to the value 2\n// and the third should map 'bob' to the value 3.\n// Make me compile and pass the test!\n\n// I AM NOT DONE\nuse core::dict::Felt252Dict;\n\nfn create_dictionary() -> Felt252Dict<u32> {\n    let mut dict: Felt252Dict<u32> = Default::default();\n//TODO\n\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_dict() {\n    let mut dict = create_dictionary();\n    assert!(dict.get('A') == 1, \"First element is not 1\");\n    assert!(dict.get('B') == 2, \"Second element is not 2\");\n    assert!(dict.get('bob') == 3, \"Third element is not 3\");\n}\n```\n\nHint: More info about the Felt252Dict type can be found in the following chapter :\nhttps://book.cairo-lang.org/ch03-02-dictionaries.html\n",
      "reference": "// The Felt252Dict maps a felt252 to a value of the specified type.\n// In this exercise, you will map a `felt252` key to a value of type `u32`.\n\n// Your task is to create a `Felt252Dict`  containing three elements of type `u32`.\n// The first element should map the key 'A' to the value 1, the second key 'B' to the value 2\n// and the third should map 'bob' to the value 3.\n// Make me compile and pass the test!\n\nuse core::dict::Felt252Dict;\n\nfn create_dictionary() -> Felt252Dict<u32> {\n    let mut dict: Felt252Dict<u32> = Default::default();\n    // Insert the required key-value pairs\n    dict.insert('A', 1);\n    dict.insert('B', 2);\n    dict.insert('bob', 3);\n\n    dict\n\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_dict() {\n    let mut dict = create_dictionary();\n    assert!(dict.get('A') == 1, \"First element is not 1\");\n    assert!(dict.get('B') == 2, \"Second element is not 2\");\n    assert!(dict.get('bob') == 3, \"Third element is not 3\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// The previous exercise did not make the distinction\n// between different types of animals, but this one does.\n// The trait `AnimalTrait` has two functions:\n// `new` and `make_noise`.\n// `new` should return a new instance of the type\n// implementing the trait.\n// `make_noise` should return the noise the animal makes.\n// The types `Cat` and `Cow` are already defined for you.\n// You need to implement the trait `AnimalTrait` for them.\n\n// No hints for this one!\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Cat {\n    noise: felt252,\n}\n\n#[derive(Copy, Drop)]\nstruct Cow {\n    noise: felt252,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n}\n\nimpl CatImpl of AnimalTrait<Cat> { // TODO: implement the trait Animal for the type Cat\n}\n\n// TODO: implement the trait Animal for the type Cow\n\n#[cfg(test)]\n#[test]\nfn test_traits2() {\n    let kitty: Cat = AnimalTrait::new();\n    assert!(kitty.make_noise() == 'meow', \"Wrong noise\");\n\n    let cow: Cow = AnimalTrait::new();\n    assert!(cow.make_noise() == 'moo', \"Wrong noise\");\n}\n```\n\nHint:  No hints for this one! It is very similar to the previous exercise.",
      "reference": "// The previous exercise did not make the distinction\n// between different types of animals, but this one does.\n// The trait `AnimalTrait` has two functions:\n// `new` and `make_noise`.\n// `new` should return a new instance of the type\n// implementing the trait.\n// `make_noise` should return the noise the animal makes.\n// The types `Cat` and `Cow` are already defined for you.\n// You need to implement the trait `AnimalTrait` for them.\n\n// No hints for this one!\n\n\n\n#[derive(Copy, Drop)]\nstruct Cat {\n    noise: felt252,\n}\n\n#[derive(Copy, Drop)]\nstruct Cow {\n    noise: felt252,\n}\n\ntrait AnimalTrait<T> {\n    fn new() -> T;\n    fn make_noise(self: T) -> felt252;\n}\n\nimpl CatImpl of AnimalTrait<Cat> {\n    fn new() -> Cat {\n        Cat { noise: 'meow' }\n    }\n\n    fn make_noise(self: Cat) -> felt252 {\n        self.noise\n    }\n}\n\nimpl CowImpl of AnimalTrait<Cow> {\n    fn new() -> Cow {\n        Cow { noise: 'moo' }\n    }\n\n    fn make_noise(self: Cow) -> felt252 {\n        self.noise\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_traits2() {\n    let kitty: Cat = AnimalTrait::new();\n    assert!(kitty.make_noise() == 'meow', \"Wrong noise\");\n\n    let cow: Cow = AnimalTrait::new();\n    assert!(cow.make_noise() == 'moo', \"Wrong noise\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// This code is using Starknet components to make a reusable owner feature.\n// This should add OwnableComponent containing functionality which any contracts can include.\n// But something is fishy here as this component is not working, can you find the error and make the tests pass?\n\n// I AM NOT DONE\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IOwnable<TContractState> {\n    fn owner(self: @TContractState) -> ContractAddress;\n    fn set_owner(ref self: TContractState, new_owner: ContractAddress);\n}\n\npub mod OwnableComponent {\n    use starknet::ContractAddress;\n    use super::IOwnable;\n\n    #[storage]\n    pub struct Storage {\n        owner: ContractAddress,\n    }\n\n    #[embeddable_as(Ownable)]\n    impl OwnableImpl<\n        TContractState, +HasComponent<TContractState>\n    > of IOwnable<ComponentState<TContractState>> {\n        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n            self.owner.read()\n        }\n        fn set_owner(ref self: ComponentState<TContractState>, new_owner: ContractAddress) {\n            self.owner.write(new_owner);\n        }\n    }\n}\n\n#[starknet::contract]\npub mod OwnableCounter {\n    use starknet::ContractAddress;\n    use super::OwnableComponent;\n\n    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);\n\n    #[abi(embed_v0)]\n    impl OwnableImpl = OwnableComponent::Ownable<ContractState>;\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        #[flat]\n        OwnableEvent: OwnableComponent::Event,\n    }\n    #[storage]\n    pub struct Storage {\n        counter: u128,\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::IOwnableDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::{contract_address_const, ContractAddress};\n    use super::IOwnableDispatcher;\n\n    fn deploy_ownable_counter() -> IOwnableDispatcher {\n        let contract = declare(\"OwnableCounter\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IOwnableDispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_contract_read() {\n        let dispatcher = deploy_ownable_counter();\n        let address_0 = 0;\n        dispatcher.set_owner(address_0.try_into().unwrap());\n        assert(address_0.try_into().unwrap() == dispatcher.owner(), 'Some fuck up happened');\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_contract_read_fail() {\n        let dispatcher = deploy_ownable_counter();\n        let address_0 = 0;\n        let address_1 = 1;\n        dispatcher.set_owner(address_0.try_into().unwrap());\n        assert(address_1.try_into().unwrap() == dispatcher.owner(), 'Some fuck up happened');\n    }\n}\n```\n\nHint: Is there maybe a decorator that annotates that a module is a component? \n",
      "reference": "// This code is using Starknet components to make a reusable owner feature.\n// This should add OwnableComponent containing functionality which any contracts can include.\n// But something is fishy here as this component is not working, can you find the error and make the tests pass?\n\nuse starknet::ContractAddress;\n\n#[starknet::interface]\ntrait IOwnable<TContractState> {\n    fn owner(self: @TContractState) -> ContractAddress;\n    fn set_owner(ref self: TContractState, new_owner: ContractAddress);\n}\n\n#[starknet::component]\npub mod OwnableComponent {\n    use starknet::ContractAddress;\n    use starknet::storage::*;\n    use super::IOwnable;\n\n    #[storage]\n    pub struct Storage {\n        owner: ContractAddress,\n    }\n\n    #[embeddable_as(Ownable)]\n    impl OwnableImpl<\n        TContractState, +HasComponent<TContractState>\n    > of IOwnable<ComponentState<TContractState>> {\n        fn owner(self: @ComponentState<TContractState>) -> ContractAddress {\n            self.owner.read()\n        }\n        fn set_owner(ref self: ComponentState<TContractState>, new_owner: ContractAddress) {\n            self.owner.write(new_owner);\n        }\n    }\n}\n\n#[starknet::contract]\npub mod OwnableCounter {\n    use starknet::ContractAddress;\n    use super::OwnableComponent;\n\n    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);\n\n    #[abi(embed_v0)]\n    impl OwnableImpl = OwnableComponent::Ownable<ContractState>;\n\n    #[event]\n    #[derive(Drop, starknet::Event)]\n    enum Event {\n        #[flat]\n        OwnableEvent: OwnableComponent::Event,\n    }\n    #[storage]\n    pub struct Storage {\n        counter: u128,\n        #[substorage(v0)]\n        ownable: OwnableComponent::Storage,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use crate::IOwnableDispatcherTrait;\n    use snforge_std::{declare, ContractClassTrait, DeclareResultTrait};\n    use starknet::{contract_address_const, ContractAddress};\n    use super::IOwnableDispatcher;\n\n    fn deploy_ownable_counter() -> IOwnableDispatcher {\n        let contract = declare(\"OwnableCounter\").unwrap().contract_class();\n        let (contract_address, _) = contract.deploy(@array![]).unwrap();\n        IOwnableDispatcher { contract_address }\n    }\n\n    #[test]\n    fn test_contract_read() {\n        let dispatcher = deploy_ownable_counter();\n        let address_0 = 0;\n        dispatcher.set_owner(address_0.try_into().unwrap());\n        assert(address_0.try_into().unwrap() == dispatcher.owner(), 'Some fuck up happened');\n    }\n\n    #[test]\n    #[should_panic]\n    fn test_contract_read_fail() {\n        let dispatcher = deploy_ownable_counter();\n        let address_0 = 0;\n        let address_1 = 1;\n        dispatcher.set_owner(address_0.try_into().unwrap());\n        assert(address_1.try_into().unwrap() == dispatcher.owner(), 'Some fuck up happened');\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// This exercise doesn't do anything yet but it still compiles! Cairo file getting run\n// needs to have a `main` function. So this file is a valid Cairo file.\n// Other exercises will require you to write Cairo code to make the exercise file compile.\n\n// I AM NOT DONE\n\nfn main() {\n    println!(\"       Welcome to...                      \");\n    println!(\"      _             _    _ _               \");\n    println!(\"  ___| |_ __ _ _ __| | _| (_)_ __   __ _ ___ \");\n    println!(\" / __| __/ _` | '__| |/ / | | '_ / / _` / __|\");\n    println!(\" |__ / || (_| | |  |   <| | | | | | (_| |__ \");\n    println!(\" |___/__/__,_|_|  |_|/_/_|_|_| |_|/__, |___/\");\n    println!(\"                                   |___/     \");\n    println!(\"\\n\");\n    println!(\"This exercise compiles successfully. The remaining exercises contain a compiler\");\n    println!(\"or logic error. The central concept behind Starklings is to fix these errors and\");\n    println!(\"solve the exercises. Good luck!\");\n    println!(\"\\n\");\n    println!(\"The file of this exercise is `exercises/intro/intro1.cairo`. Have a look!\");\n    println!(\"The current exercise path will be always shown under the progress bar.\");\n    println!(\"You can click on the path to open the exercise file in your editor.\");\n}\n```\n\nHint: No hints this time ;)\n",
      "reference": "// This exercise doesn't do anything yet but it still compiles! Cairo file getting run\n// needs to have a `main` function. So this file is a valid Cairo file.\n// Other exercises will require you to write Cairo code to make the exercise file compile.\n\nfn main() {\n    println!(\"       Welcome to...                      \");\n    println!(\"      _             _    _ _               \");\n    println!(\"  ___| |_ __ _ _ __| | _| (_)_ __   __ _ ___ \");\n    println!(\" / __| __/ _` | '__| |/ / | | '_ / / _` / __|\");\n    println!(\" |__ / || (_| | |  |   <| | | | | | (_| |__ \");\n    println!(\" |___/__/__,_|_|  |_|/_/_|_|_| |_|/__, |___/\");\n    println!(\"                                   |___/     \");\n    println!(\"\\n\");\n    println!(\"This exercise compiles successfully. The remaining exercises contain a compiler\");\n    println!(\"or logic error. The central concept behind Starklings is to fix these errors and\");\n    println!(\"solve the exercises. Good luck!\");\n    println!(\"\\n\");\n    println!(\"The file of this exercise is `exercises/intro/intro1.cairo`. Have a look!\");\n    println!(\"The current exercise path will be always shown under the progress bar.\");\n    println!(\"You can click on the path to open the exercise file in your editor.\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// This store is having a sale where if the price is an even number, you get\n// 10 Cairobucks off, but if it's an odd number, it's 3 Cairobucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\n// I AM NOT DONE\n\nfn main() {\n    let original_price = 51;\n    println!(\"sale_price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: u32) -> {\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: u32) -> bool {\n    num % 2 == 0\n}\n```\n\nHint: The error message points to line 18 and says it expects a type after the\n`->`. This is where the function's return type should be -- take a look at\nthe `is_even` function for an example!\n",
      "reference": "// This store is having a sale where if the price is an even number, you get\n// 10 Cairobucks off, but if it's an odd number, it's 3 Cairobucks off.\n// (Don't worry about the function bodies themselves, we're only interested\n// in the signatures for now. If anything, this is a good way to peek ahead\n// to future exercises!)\n\n\n\nfn main() {\n    let original_price = 51;\n    println!(\"sale_price is {}\", sale_price(original_price));\n}\n\nfn sale_price(price: u32) -> u32 {\n    if is_even(price) {\n        price - 10\n    } else {\n        price - 3\n    }\n}\n\nfn is_even(num: u32) -> bool {\n    num % 2 == 0\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Time to implement some traits!\n\n// Your task is to implement the trait\n// `AnimalTrait` for the type `Animal`\n//\n\n// Fill in the impl block to make the code work.\n\n// I AM NOT DONE\n\n#[derive(Copy, Drop)]\nstruct Animal {\n    noise: felt252\n}\n\ntrait AnimalTrait {\n    fn new(noise: felt252) -> Animal;\n    fn make_noise(self: Animal) -> felt252;\n}\n\nimpl AnimalImpl of AnimalTrait { // TODO: implement the trait AnimalTrait for Animal\n}\n\n#[cfg(test)]\n#[test]\nfn test_traits1() {\n    // TODO make the test pass by creating two instances of Animal\n    // and calling make_noise on them\n\n    assert!(cat.make_noise() == 'meow', \"Wrong noise\");\n    assert!(cow.make_noise() == 'moo', \"Wrong noise\");\n}\n```\n\nHint: \nIf you want to implement a trait for a type, you have to implement all the methods in the trait.\nBased on the signature of the method, you can easily implement it.\n\nIn the test, you need to instantiate two objects of type `Animal`.\nYou can call the method of a trait by using the MyTrait::foo() syntax.\nHow would you instantiate the two objects with AnimalTrait?\nMaybe you need to specify the type of the object?\nhttps://book.cairo-lang.org/ch08-02-traits-in-cairo.html\n",
      "reference": "// Time to implement some traits!\n\n// Your task is to implement the trait\n// `AnimalTrait` for the type `Animal`\n//\n\n// Fill in the impl block to make the code work.\n\n\n\n#[derive(Copy, Drop)]\nstruct Animal {\n    noise: felt252\n}\n\ntrait AnimalTrait {\n    fn new(noise: felt252) -> Animal;\n    fn make_noise(self: Animal) -> felt252;\n}\n\nimpl AnimalImpl of AnimalTrait { // TODO: implement the trait AnimalTrait for Animal\n    fn new(noise: felt252) -> Animal {\n        Animal { noise }\n    }\n\n    fn make_noise(self: Animal) -> felt252 {\n        self.noise\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_traits1() {\n    // TODO make the test pass by creating two instances of Animal\n    // and calling make_noise on them\n    let cat = AnimalTrait::new('meow');\n    let cow = AnimalTrait::new('moo');\n\n    assert!(cat.make_noise() == 'meow', \"Wrong noise\");\n    assert!(cow.make_noise() == 'moo', \"Wrong noise\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// We are writing an app for a restaurant,\n// but take_order functions are not being called correctly.\n// Can you fix this?\n\n// I AM NOT DONE\n\npub mod restaurant {\n    pub fn take_order() -> felt252 {\n        'order_taken'\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_mod_fn() {\n    // Fix this line to call take_order function from module\n    let order_result = take_order();\n\n    assert!(order_result == 'order_taken', \"Order not taken\");\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_super_fn() {\n        // Fix this line to call take_order function\n        let order_result = take_order();\n\n        assert!(order_result == 'order_taken', \"Order not taken\");\n    }\n}\n```\n\nHint: You can bring a parent's modules items in the current module with super::item_name\n",
      "reference": "// We are writing an app for a restaurant,\n// but take_order functions are not being called correctly.\n// Can you fix this?\n\npub mod restaurant {\n    pub fn take_order() -> felt252 {\n        'order_taken'\n    }\n}\n\n#[cfg(test)]\n#[test]\nfn test_mod_fn() {\n    // Fix this line to call take_order function from module\n    let order_result = restaurant::take_order();\n\n    assert!(order_result == 'order_taken', \"Order not taken\");\n}\n\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn test_super_fn() {\n        // Fix this line to call take_order function\n        let order_result = super::restaurant::take_order();\n\n        assert!(order_result == 'order_taken', \"Order not taken\");\n    }\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// You can't change anything except adding or removing references.\n\n// I AM NOT DONE\n\n#[derive(Drop)]\nstruct Number {\n    value: u32, \n}\n\nfn main() {\n    let mut number = Number { value: 1111111 };\n\n    get_value(number);\n\n    set_value(number);\n}\n\n// Should not take ownership and not modify the variable passed.\nfn get_value(number: Number) -> u32 {\n    number.value\n}\n\n// Should take ownership\nfn set_value(number: Number) {\n    let value = 2222222;\n    number = Number { value };\n    println!(\"Number is: {}\", number.value);\n}\n```\n\nHint: The first problem is that `get_value` is taking ownership of the Number struct.\nSo `Number` is moved and can't be used for `set_value`\n`number` is moved to `get_value` first, meaning that `set_value` cannot manipulate the data.\nWhat can we use to pass an immutable reference to `get_value`? What special operator do we use for that?\nWhat other operator do we use to \"desnap\" a snapshot?\nHint: It involves the `@` and `*` operators.\n\nOnce you've fixed that, `set_value`'s function signature will also need to be adjusted.\nCan you figure out how?\n",
      "reference": "// You can't change anything except adding or removing references.\n\n#[derive(Drop)]\nstruct Number {\n    value: u32,\n}\n\nfn main() {\n    let mut number = Number { value: 1111111 };\n\n    get_value(@number);\n\n    set_value(number);\n}\n\n// Should not take ownership and not modify the variable passed.\nfn get_value(number: @Number) -> u32 {\n    *number.value\n}\n\n// Should take ownership\nfn set_value(mut number: Number) {\n    let value = 2222222;\n    number = Number { value };\n    println!(\"Number is: {}\", number.value);\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Your task is to create an `Array` which holds three elements of type `felt252`.\n// The first element should be 0.\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\nfn create_array() -> Array<felt252> {\n    let a = ArrayTrait::new(); // something to change here...\n    a.append(1);\n    a\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_array_len() {\n    let mut a = create_array();\n    assert!(a.len() == 3, \"Array length is not 3\");\n    assert!(a.pop_front().unwrap() == 0, \"First element is not 0\");\n}\n```\n\nHint: You can declare an array in Cairo using the following syntax:\n`let your_array = ArrayTrait::new();`\nYou can append elements to an array using the following syntax:\n`your_array.append(element);`\n\nThe `pop_front` method removes the first element from the array and returns an Option::Some(value) if the array is not empty, or Option::None() if the array is empty.\n",
      "reference": "// Your task is to create an `Array` which holds three elements of type `felt252`.\n// The first element should be 0.\n// Make me compile and pass the test!\n\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new();\n    a.append(0);\n    a.append(1);\n    a.append(2);\n    a\n}\n\n\n// Don't change anything in the test\n#[cfg(test)]\n#[test]\nfn test_array_len() {\n    let mut a = create_array();\n    assert!(a.len() == 3, \"Array length is not 3\");\n    assert!(a.pop_front().unwrap() == 0, \"First element is not 0\");\n}"
    },
    {
      "query": "Complete the following Cairo code and address the TODOs:\n\n```cairo\n// Your task is to make the test pass without modifying the `create_array` function.\n// Make me compile and pass the test!\n\n// I AM NOT DONE\n\n// Don't modify this function\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new();\n    a.append(42);\n    a\n}\n\nfn remove_element_from_array(\n    ref a: Array<felt252>\n) { //TODO something to do here...Is there an array method I can use?\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2() {\n    let mut a = create_array();\n    assert!(*a.at(0) == 42, \"First element is not 42\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2_empty() {\n    let mut a = create_array();\n    remove_element_from_array(ref a);\n    assert!(a.len() == 0, \"Array length is not 0\");\n}\n```\n\nHint: How can you remove the first element from the array?\nTake a look at the previous exercise for a hint. Don't forget to call `.unwrap()` on the returned value.\nThis will prevent the `Variable not dropped` error.\n",
      "reference": "// Your task is to make the test pass without modifying the `create_array` function.\n// Make me compile and pass the test!\n\n\n\n// Don't modify this function\nfn create_array() -> Array<felt252> {\n    let mut a = ArrayTrait::new();\n    a.append(42);\n    a\n}\n\nfn remove_element_from_array(ref a: Array<felt252>) {\n    let _ = a.pop_front();\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2() {\n    let mut a = create_array();\n    assert!(a.len() == 1, \"Array should have one element\");\n    assert!(*a.at(0) == 42, \"First element should be 42\");\n}\n\n#[cfg(test)]\n#[test]\nfn test_arrays2_empty() {\n    let mut a = create_array();\n    remove_element_from_array(ref a);\n    assert!(a.len() == 0, \"Array length is not 0\");\n}"
    }
  ],
  "metadata": {
    "count": 55,
    "source": "starklings",
    "generated_at": "2025-09-24 17:45:02"
  }
}
