[
    {
        "query": "Implement a simple counter contract in Cairo that anyone can increment or decrement with events for each action"
    },
    {
        "query": "Create an ERC20 token contract named 'MY_ERC20' with 18 decimals and an initial supply minted to the deployer"
    },
    {
        "query": "Create an ERC721 NFT collection capped at 10,000 items with a base URI setter restricted to the owner"
    },
    {
        "query": "Write a Cairo function to find the smallest number in a u32 array input and return its index"
    },
    {
        "query": "Implement a minimal fixed-point math library using Q32.32 with a single add function"
    },
    {
        "query": "Write unit-testable Cairo modules for an ERC20: tests for mint, burn, transfer, allowance, and edge cases"
    },
    {
        "query": "Build an Ownable access control module with transfer_ownership and renounce_ownership functions"
    },
    {
        "query": "Implement an upgradable class hash manager that supports rolling back to a previous implementation (with events)"
    },
    {
        "query": "Create a Pausable module that can pause and unpause transfers for an ERC20 token"
    },
    {
        "query": "Implement a ReentrancyGuard pattern for external functions using a storage-based lock flag"
    },
    {
        "query": "Write a u256 arithmetic library (add, sub, mul, div, mod) using Cairo builtins and safe overflow checks"
    },
    {
        "query": "Develop an upgradeable proxy contract for Starknet with get_implementation, set_implementation (owner-only), and delegate calls"
    },
    {
        "query": "Implement an ERC1155 multi-token contract with mint, batch_mint, and safe_transfer_from"
    },
    {
        "query": "Write a library to compute Poseidon hash of an array and verify a given hash matches contents"
    },
    {
        "query": "Create a Merkle tree proof verifier for membership proofs over felt252 leaves"
    },
    {
        "query": "Implement a minimal time-lock contract that queues, executes, and cancels operations after a delay using block timestamp"
    },
    {
        "query": "Create a minimal Vesting contract that releases ERC20 tokens linearly over time to a beneficiary"
    },
    {
        "query": "Implement an airdrop contract that lets users claim ERC20 tokens with a Merkle proof"
    },
    {
        "query": "Create a simple AMM constant-product pool (x*y=k) for two ERC20 tokens with add/remove liquidity and swap"
    },
    {
        "query": "Implement a price oracle consumer contract that reads the latest price from an external oracle interface"
    },
    {
        "query": "Build a RateLimiter module that restricts function calls to once per address per N blocks"
    },
    {
        "query": "Write a lottery contract that collects entries and picks a winner using a VRF-like interface (mocked)"
    },
    {
        "query": "Implement an onchain allowlist where only approved addresses can mint NFTs; owner can add/remove addresses"
    },
    {
        "query": "Create a crowdfunding contract with a funding goal, deadline, refunds if goal not met, and payout if successful"
    },
    {
        "query": "Implement an L1->L2 message consumer that processes deposits from Ethereum and mints wrapped tokens"
    },
    {
        "query": "Implement an L2->L1 message sender that locks tokens on L2 and emits a message to unlock on L1"
    },
    {
        "query": "Create a cross-contract call example where Contract A calls a function on Contract B and handles the return value"
    },
    {
        "query": "Write a library for safe ERC20 transfer and transfer_from that returns a boolean and reverts on failure"
    },
    {
        "query": "Implement a minimal ERC4626-like tokenized vault for an underlying ERC20 with deposit, mint, withdraw, redeem"
    },
    {
        "query": "Create a governance token with checkpoints and vote delegation (compound-style) for onchain voting"
    },
    {
        "query": "Implement a Governor contract with proposal, voting, quorum, and timelock execution hooks"
    },
    {
        "query": "Write a contract that stores and updates a mapping from address to struct { balance: u256, last_update: u64 }"
    },
    {
        "query": "Implement a royalties standard for NFTs (percentage fee sent to a recipient on secondary sales)"
    },
    {
        "query": "Create a Soulbound (non-transferable) token that can be minted by the owner but not transferred"
    },
    {
        "query": "Write a batch executor contract that performs multiple arbitrary calls in a single transaction (multicall)"
    },
    {
        "query": "Implement a simple escrow contract between buyer and seller with an arbiter who can resolve disputes"
    },
    {
        "query": "Create a referral rewards contract where referred usersâ€™ actions accrue ERC20 rewards to referrers"
    },
    {
        "query": "Implement a gasless meta-transaction relayer pattern for an ERC20 transfer with EIP-712-like typed data"
    },
    {
        "query": "Write a contract that verifies a Schnorr signature over a message and stores the result"
    },
    {
        "query": "Implement a rate-limited mint for an ERC20 that allows a fixed amount to be minted every epoch"
    },
    {
        "query": "Create a Dutch auction minting contract for NFTs starting at a high price and decreasing every interval"
    },
    {
        "query": "Implement a sealed-bid auction where bids are hashed and later revealed; highest valid bid wins"
    },
    {
        "query": "Write a library to pack and unpack multiple small integers into a single felt252 using bitwise operations"
    },
    {
        "query": "Create a payment splitter contract that splits any incoming ERC20 transfer among N recipients by shares"
    },
    {
        "query": "Implement a contract that verifies a Merkle proof of inclusion for an offchain-stored JSON metadata root"
    },
    {
        "query": "Write a deterministic deployer (factory) that deploys contracts at predictable addresses from a salt"
    },
    {
        "query": "Create an NFT metadata registry that allows setting per-token metadata fields, with owner-only update"
    },
    {
        "query": "Implement a simple RNG interface that mixes block hash, caller, and salt into a pseudo-random output"
    },
    {
        "query": "Write a library for converting between fixed-point decimal strings and integer representation (parse/format)"
    },
    {
        "query": "Create an Account Abstraction contract compatible with Starknet validate/execute flow with nonce and replay protection"
    },
]
